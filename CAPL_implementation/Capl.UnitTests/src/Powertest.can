/*@!Encoding:1252*/
/*
Copyright ( C ) Continental AG 2015

Date of creation :  10.01.2015

Created by :                 Hans Jürgen Hipp


Version info

1.00	   10.2013	Inital versioning introduced

*/


variables
{
    const byte cKeyOff =    0;
    const byte cKeyIn =     1;
    const byte cAccessory = 2;
    const byte cRun =       4;
    const byte cCrank =     8;
    
    msTimer _tIgnSwitchOff_duration_msec;        // 0 - 60000 msec
    byte IgnSwitchOff_duration_minute;
    word IgnSwitchOff_delay = 0;                    // delay calcuated from CAN-timing
    msTimer _tIgnSwitchLock_duration_msec;      // 0 - 60000 msec
    word IgnSwitchLock_duration_msec;
    byte IgnSwitchLock_duration_minute;
    word IgnSwitchLock_delay = 0;                    // delay calcuated from CAN-timing
    msTimer _tIgnSwitchOn_duration_msec;        // 0 - 60000 msec
    byte IgnSwitchOn_duration_minute;
    word IgnSwitchOn_delay = 0;                    // delay calcuated from CAN-timing
    msTimer _t_Power_CheckCommActive;        // 0 - 60000 msec
    word _c_Power_CheckCommActive = 1000;                    // delay calcuated from CAN-timing
    msTimer _tNM_COM_StayActiveTimer;
    word _cNM_COM_StayActiveTimer = 9700;
    msTimer _tPowerOnToLogDelay;
    word _cPowerOnToLogDelay = 3000;

    msTimer tPC_Time_read;

// for WakeUp/GoToSleep-Measurement
    const int True  = 1;
    const int False = 0;

    int First;
    dword StartTime;
    dword FirstNMTime;
    dword StopTime;
    dword LastNMTime;
    long diff; 

    const int _c_Powertest_InitialReactionTime_msec = 5000;  // 5 sec
    int boWaitForIC_Sleep = False;
    word wtemp;

// ----  Switches with Keyboard -----------------

/*    msTimer tReleaseKeyCursorUp;
    msTimer tReleaseKeyCursorDown;
    msTimer tReleaseKeyCursorRight;
    msTimer tReleaseKeyCursorLeft;
    msTimer tReleaseKeyOK;
    msTimer tReleaseKeyBack;
    msTimer tReleaseKeyMenu;
    const dword cReleaseKeyTime = 100;
*/
/*    
    const byte cSWIllLvl_Raw_Default_old = 0;
    const byte cSWIllLvl_Raw_Default_new = 100;
    byte SWIllLvl_Raw_Default = cSWIllLvl_Raw_Default_new;
*/
  
// ----  SLA-Variablen --------------------------
    byte AnzSchleifen = 0;
    byte SLA_Framecounter = 1;

/*
    int WheelValue;               // für SBC Raddrehzahlen
    int WheelValueHilf;           // für SBC Raddrehzahlen

    msTimer _tTurnIndTimerOn;         // Timer for automated turn signals
    msTimer _tTurnIndTimerReload;     // Timer for automated turn signals
*/
    long readPara1;
    long readPara2;
    long defVal = -1;

    // Timers for calculating a new value
    mstimer _t_Stress_ChangeCoolTemp;
    mstimer _t_Stress_ChangeOutTemp;
    mstimer _t_Stress_ChangeParking;
    mstimer _t_Stress_ChangeRev;
    mstimer _t_Stress_ChangeSegBegin;
    mstimer _t_Stress_ChangeSegEnd;
    mstimer _t_Stress_ChangeSpeed;
    mstimer _t_Stress_ChangeTank;
    mstimer _t_Stress_ToggleDayNight;
    mstimer _t_Stress_ChangeGearBox;

//    msTimer _t_Dimm_Increment_Cancel;
    const long cDimm_Increment_Cancel_Preset = 100;

// Variables for sweep directions: 1 = positiv, -1 = negativ
    int iDirectionCoolTemp    = 1;
    int iDirectionOutTemp     = 1;
    int iDirectionParking     = 1;
    int iDirectionRev         = 1;
    int iDirectionSegBegin    = 1;
    int iDirectionSegEnd      = 1;
    int iDirectionSpeed       = 1;
    int iDirectionTank        = 1;
    int iDirectionGearBoxPos  = 1;
    int iDirectionGearBoxProg = 1;

    // Additional parameter for function "CalcNextPointerVal"
    // has to be declared here, because more than one should be returned
    long lCurrentVal;
    float fCurrentValue;

    // automatic ODO counting
    float fODO_RemainingWay;
    const float ODO_MaxDistRollCount = 50.8;

// Variables for ini-file read/write

//    char buffer[256];
    char func[20];
    long lTemp;
    long lWriteError = 1; // 0 = Error while writing ini-file

    // Default values for pointer coolant temp
    const long defCoolTempSweepActiv   =   1;
    const long defCoolTempMin          = -40;
    const long defCoolTempMax          = 140;
    const long defCoolTempStepWidth    =  10;
    const long defCoolTempTimeInterval = 500;

    // Default values for gearbox sweep
    const long defGearBoxSweepActiv   =   1;
    const long defGearBoxRandom       =   1;
    const long defGearBoxTimeInterval =  25;
    const int iPosArray_indexMax  = 0x18;
    const int iProgArray_indexMax = 0x08;
    byte abPosArray[iPosArray_indexMax+1]   = { 0x20,0x50,0x52,0x4E,0x44,0x41,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x46,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01 };
    byte abProgArray[iProgArray_indexMax+1] = { 0x20,0x57,0x53,0x4D,0x41,0x43,0x46,0x45,0x54 };
    int iPosArray_index = 0;
    int iProgArray_index = 0;

    // Default values for NightView
    const long defNightViewToggleActiv = 0;
    const long defNightViewTimeInterval = 30000;

    // Default values for DayNight
    const long defDayNightToggleActiv = 0;
    const long defDayNightTimeInterval = 2000;

    // Default values for outside airtemp sweep
    const long defOutTempSweepActiv   =     1;
    const long defOutTempMin          =   -10;
    const long defOutTempMax          =    10;
    const long defOutTempStepWidth    =     1;
    const long defOutTempTimeInterval =  1000;

    // Default values for Parking (left & right)
    const long defParkingSweepActiv   =   1;
    const long defParkingMin          =   0;
    const long defParkingMax          =  15;
    const long defParkingStepWidth    =   1;
    const long defParkingTimeInterval = 500;

    // Default values for pointer revolution
    const long defRevSweepActiv   =    1;
    const long defRevMin          =    0;
    const long defRevMax          = 6000;
    const long defRevStepWidth    = 6000;
    const long defRevTimeInterval = 1000;

    // Default values for Segmentring Begin
    const long defSegBeginSweepActiv   =   1;
    const long defSegBeginMin          =   0;
    const long defSegBeginMax          = 100;
    const long defSegBeginStepWidth    =   1;
    const long defSegBeginTimeInterval =  25;

    // Default values for Segmentring End
    const long defSegEndSweepActiv     =   1;
    const long defSegEndMin            = 101;
    const long defSegEndMax            = 252;
    const long defSegEndStepWidth      =   1;
    const long defSegEndTimeInterval   =  25;

    // Default values for pointer speed
    const long defSpeedSweepActiv   =   1;
    const long defSpeedMin          =   0;
    const long defSpeedMax          = 260;
    const long defSpeedStepWidth    =  10;
    const long defSpeedTimeInterval =  25;

    // Default values for pointer tank
    const long defTankSweepActiv   =   1;
    const long defTankMin          =   0;
    const long defTankMax          = 100;
    const long defTankStepWidth    =  10;
    const long defTankTimeInterval = 100;

    // Variable and constants for own tab in "Write"-window
    dword dwWriteSinkSimu;  // Sink identifier Stresstest-tab

    // write window sink-IDs (tabulators on write window)
    const long dwWriteSinkTrace  = -3;
    const long dwWriteSinkLog    = -2;
    const long dwWriteSinkDebug  = -1;
    const long dwWriteSinkSystem =  0;
    const long dwWriteSinkCapl   =  1;

    // write window severities (for writing at sinks)
    const dword dwWriteSeveritySuccess = 0;
    const dword dwWriteSeverityInfo    = 1;
    const dword dwWriteSeverityWarning = 2;
    const dword dwWriteSeverityError   = 3;

// Powermode 

    const long defPower_On_Min = 0;
    const long defPower_On_Msec = 10000;
    const long defPower_On_IncDec = 0;
    const long defPower_On_Msec_Step = 1;
    const long defPower_Off_Min = 0;
    const long defPower_Off_Msec = 5000;
    const long defPower_Off_IncDec = 0;
    const long defPower_Off_Msec_Step = 1;
    const long defPower_Lock_Min = 1;
    const long defPower_Lock_Msec = 0;
    const long defPower_Lock_IncDec = 1;
    const long defPower_Lock_Msec_Step = 1;
    const long defPower__PowertestMainActiv = 0;


// Configuration
   
    const byte CONFIG_MIN        = 0x00;      // everything ! is switched OFF
    const byte CONFIG_MAX               = 0x01;      // everything ! is switched ON
    const byte CONFIG_TYPICAL           = 0x02;      // medium equippement configuration, cannot be modified by user !!!
    const byte CONFIG_1            = 0x03;      // Free for own entries

    const byte CONFIG_2            = 0x04;      // Free for own entries
    const byte CONFIG_3            = 0x05;      // Free for own entries
    const byte CONFIG_4            = 0x06;      // Free for own entries
    const byte CONFIG_5            = 0x07;      // Free for own entries

    const byte CONFIG_6            = 0x08;      // Free for own entries
    const byte CONFIG_7            = 0x09;      // Free for own entries
    const byte CONFIG_8            = 0x0A;      // Free for own entries
    const byte CONFIG_9            = 0x0B;      // Free for own entries

    const byte CONFIG_10        = 0x0C;      // Free for own entries
    const byte CONFIG_11        = 0x0D;      // Free for own entries
    const byte CONFIG_12        = 0x0E;      // Free for own entries
    const byte CONFIG_13        = 0x0F;      // Free for own entries
    
    char cConfig_CFGiniSection[100];
    char cConfig_iniSection[100];                      // contains the current selected section string
    
    char cConfig_outtxt[15] ;                         // out text for the IND settings panel    

    dword KeyIdByte1;              // Für Ident.Schlüssel
    dword KeyIdByte2;              // Für Ident.Schlüssel
    dword KeyIdByte3;              // Für Ident.Schlüssel
    dword KeyIdByte4;              // Für Ident.Schlüssel

    msTimer t_Auto_Project_SelectorTimer;	    // event duration timer

}

CalcODO()
{
}

on envVar Env_Uebernehmen
{

    if( ( getvalue( Env_Uebernehmen ) ) && ( getvalue( Env_Modus_Manuell ) ) )
    {
    }
}

on envVar Env_Ignition_Status
{
    byte ActualStatus = 0;
    
    ActualStatus = getValue( this );
    if( getvalue( Env_Modus_Manuell ) == 0 )
    {
/*        if( getValue( this ) > 0 )
        {
              putValue( Env___start_Stop_DBKom_Timer, 1 );    // start all DBKom timers
        }
*/        
        if( ActualStatus & cKeyIn )
            putValue( KCAN_ZAS_Kl_S, 1 );
        else
            putValue( KCAN_ZAS_Kl_S, 0 );
        
        if( ActualStatus & cRun )
        {
            putValue( KCAN_ZAS_Kl_15, 1 );
        }
        else
        {
            putValue( KCAN_ZAS_Kl_15, 0 );
            putValue( KCAN_ZAS_Kl_X, 0 );
        }
        
        if( ActualStatus & cCrank )
        {
            putValue( KCAN_ZAS_Kl_50_Startanforderung, 1 );
            putValue( KCAN_ZAS_Kl_X, 0 );
        }
        else
        {
            putValue( KCAN_ZAS_Kl_50_Startanforderung, 0 );
            putValue( KCAN_ZAS_Kl_X, 1 );
        }
        
/*        if( ActualStatus & cAccessory )
            putValue( eZAS_Kl_SS, 1 );
        else
            putValue( eZAS_Kl_SS, 0 );
*/        
/*        switch( getValue(this) )
        {
            case 0: putValue( IMS_Ignition_Status, 0 );    // Lock
                break;
            case 1: putValue( IMS_Ignition_Status, 1 );    // Off
                break;
            case 2: putValue( IMS_Ignition_Status, 2 );    // Acc
                break;
            case 3: putValue( IMS_Ignition_Status, 4 );    // Run
                break;
            case 4: putValue( IMS_Ignition_Status, 8 );    // Crank
                break;
        }*/
        switch( getValue(this) )
        {
            case 0: putValue( Env_Ignition_Status_BMP_Switch, 0 );    // Lock
                break;
            case 1: putValue( Env_Ignition_Status_BMP_Switch, 1 );    // Off
                break;
            case 2: putValue( Env_Ignition_Status_BMP_Switch, 2 );    // Acc
                break;
            case 4: putValue( Env_Ignition_Status_BMP_Switch, 3 );    // Run
                break;
            case 8: putValue( Env_Ignition_Status_BMP_Switch, 4 );    // Crank
                break;
        }
    }
}

on envVar KCAN_ZAS_Kl_15
{
    
}
/*on envVar IMS_Ignition_Status
{
    if( getvalue( Env_Modus_Manuell ) == 0 )
    {
        switch( getValue(this) )
        {
            case 0: putValue( Env_Ignition_Status, 0 );
                    break;
            case 1: putValue( Env_Ignition_Status, 1 );
                    break;
            case 2: putValue( Env_Ignition_Status, 2 );
                    break;
            case 4: putValue( Env_Ignition_Status, 3 );
                    break;
            case 8: putValue( Env_Ignition_Status, 4 );
                    break;
        }
    }

}
*/

on envVar Env_Modus_Manuell
{

    if( getvalue(Env_Modus_Manuell ) == 0 )
    {
    
    }
}

on preStart
{
    //Create a new tab at the write window
    dwWriteSinkSimu= writeCreate("Stresstest");

    //Clear content of CAPL tab on write window
    writeclear(dwWriteSinkCapl);

    writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "");
    writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "     +------------+");
    writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "     | Stresstest |");
    writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "     +------------+");
    writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "");

    Stress__WriteSinkAll();

    if( getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "\n        started\n");
    }
}

on start
{
 //   putValue( Env_Power__PowertestMainActiv, 0 );
 //   putValue( HMI_WhlDir_FL_Stat, 1 );
 //   putValue( HMI_WhlDir_RL_Stat, 1 );
 //   putValue( HMI_WhlDir_FR_Stat, 1 );
 //   putValue( HMI_WhlDir_RR_Stat, 1 );
 //   putValue( HMI_WhlRPM_FL_Qual, 1 );
 //   putValue( HMI_WhlRPM_RL_Qual, 1 );
 //   putValue( HMI_WhlRPM_FR_Qual, 1 );
 //   putValue( HMI_WhlRPM_RR_Qual, 1 );
 //   putValue( Env_EngCoolTemp, 50 );
 //   putValue( Env_EngCoolTemp_Fehler, 0 );
 //   putValue( Env_EngRPM, 0 );
 //   putValue( Env_EngRPM_Fehler, 0 );
 //   putValue( HMI_TurnLmpOnDur, 0x3C /* 60 dez */ );
 //   putValue( Env_TurnLmpOnDur, 0x3C /* 60 dez */ );
 //   putValue( HMI_Teleaid_RD_A, 1 );
 //   putValue( Env_Panel_TurnInd_Right_On, 0 );
 //   putValue( Env_Panel_TurnInd_Left_On, 0 );
 //   putValue( IMS_TurnLghtLeftOn_B_Stat, 0 );
 //   putValue( IMS_TurnLghtRightOn_B_Stat, 0 );
 //   putValue( Env_TurnLghtLeftOn_B_Stat, 0 );
 //   putValue( Env_TurnLghtRightOn_B_Stat, 0 );
 //   putValue( Env_Ignition_Status, 0 );
 //   putValue( IMS_Ignition_Status, 0 );

 //   putValue( Env_TC_RollingCount_RUN, 0 );

//    putValue( Env_KeyId_EIS_V2_Byte2, 255 );
//    KeyIdByte1 = getvalue( Env_KeyId_EIS_V2_Byte1 );
//    KeyIdByte2 = getvalue( Env_KeyId_EIS_V2_Byte2 ) * 0x100;
//    KeyIdByte3 = getvalue( Env_KeyId_EIS_V2_Byte3 ) * 0x10000;
//    KeyIdByte4 = getvalue( Env_KeyId_EIS_V2_Byte4 ) * 0x1000000;
  
//    putValue( HMI_KeyId_EIS_V2, ( KeyIdByte4 + KeyIdByte3 + KeyIdByte2 + KeyIdByte1 ) );
/*    putValue( ,  );
    putValue( ,  );*/


//    putValue( Env___start_Stop_DBKom_Timer, 1 );    // start all DBKom timers

//    writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "      read Stress Test INI-file");
    Stress__iniReadAll("ini_data\\Stresstest.ini");
    Stress__CheckAll();

//    writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "      read Power Test INI-file");
    Power__iniReadAll("ini_data\\Powertest.ini");

//    writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "      read Config data INI-file");
    Config__iniReadAll("ini_data\\Config_Data.ini");

    setTimer( tPC_Time_read, 100 );

    setTimer( t_Auto_Project_SelectorTimer, 10 );

//    putValue( IMS_Dimming_Lvl, 18 );

}

on timer _tIgnSwitchOff_duration_msec
{
    word temp, temp_msec, temp_min;
    dword AbsStart_Time;
    dword AbsStop_Time;
    dword Actual_Time;

/*  deaktiviert, warten auf NM -> Sleep
    
    AbsStart_Time = getValue( Env_Power_Off_Min_Start ) * 60000 + getValue( Env_Power_Off_Msec_Start );
    AbsStop_Time = getValue( Env_Power_Off_Min_Stop ) * 60000 + getValue( Env_Power_Off_Msec_Stop );
    if( IgnSwitchOff_delay > 0 )                    // still some minutes missing
    {
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOff_duration_msec, IgnSwitchOff_delay );      // delay periode
        IgnSwitchOff_delay = 0;
        return;
    }
    if( IgnSwitchOff_duration_minute > 0 )                    // still some minutes missing?
    {
        IgnSwitchOff_duration_minute--;
        cancelTimer( _tIgnSwitchOff_duration_msec );
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOff_duration_msec, 60000 );      // 1 minute periode
    }
    else                                                    // timer elapsed, prepare next phase
    {
        StopTime = timeNow();
    Trace("IgnSwitch  Off --> Lock ", "");
        putValue( Env_Ignition_Status, 0 );        // switch PowerMode to RUN       
   //     if( getValue( DIAG_LOG_OneShotLogLinkedToIgnSwitch ) )
        {
        //    putValue( DIAG_LOG_SessionActiv, 0 );
        }                                    // switch Ign_Switch to next value
        boWaitForIC_Sleep = True;

        if( getValue( Env_Power_Off_IncDec ) > 0 )
        {
            temp_min = getValue( Env_Power_Off_Min );
            temp_msec = getValue( Env_Power_Off_Msec );
            Actual_Time = temp_min *60000 + temp_msec;
//          wtemp = getValue( Env_Power_Off_Msec_Step );
            // Inc / Dec Handling has to be done
            if( getValue( Env_Power_Off_IncDec ) == 1 )
            {    // Inc
                Actual_Time = Actual_Time + getValue( Env_Power_Off_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time > AbsStop_Time )
                {
                    Actual_Time = Actual_Time - AbsStop_Time + AbsStart_Time;
                }
            }
            else
            {    // Dec
                Actual_Time = Actual_Time - getValue( Env_Power_Off_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time < AbsStart_Time )
                {
                    Actual_Time = Actual_Time + AbsStop_Time - AbsStart_Time;
                }
            }
            putValue( Env_Power_Off_Min, ( Actual_Time / 60000 ) );
            putValue( Env_Power_Off_Msec, ( Actual_Time - ( getValue( Env_Power_Off_Min ) * 60000 )));
        }                                       // switch Ign_Switch to next value
        IgnSwitchLock_duration_minute = getValue( Env_Power_Lock_Min ); //restore orig value
//        IgnSwitchLock_duration_msec = getValue( Env_Power_Lock_Msec ); //restore orig value
        wtemp = getValue( Env_Power_Lock_Msec );                        // get msec value from Panel
        if( wtemp == 0 )                                                // if zero, chek Minute-value
        {
            wtemp = getValue( Env_Power_Lock_Min );
            if( wtemp == 0 )                                            // check minute-value of Timer
            {
                wtemp = 1;                                            // .. is also zero : set 1msec
            }
            else
            {
                wtemp = 60000;                                        // .. is not zero: so enter 1 minute
                IgnSwitchLock_duration_minute--;                        // and adjust counter
            }
        }
    if( getValue( Env_Power__PowertestMainActiv ) )
        setTimer( _tIgnSwitchLock_duration_msec, wtemp );    // set Timer for next phase "Off"
    }*/
}

on timer _tIgnSwitchOn_duration_msec
{
    word temp, temp_msec, temp_min;
    dword AbsStart_Time;
    dword AbsStop_Time;
    dword Actual_Time;

    AbsStart_Time = getValue( Env_Power_On_Min_Start ) * 60000 + getValue( Env_Power_On_Msec_Start );
    AbsStop_Time = getValue( Env_Power_On_Min_Stop ) * 60000 + getValue( Env_Power_On_Msec_Stop );
    if( IgnSwitchOn_delay > 0 )                    // still some minutes missing
    {
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOn_duration_msec, IgnSwitchOn_delay );      // delay periode
        IgnSwitchOn_delay = 0;
        return;
    }
    if( IgnSwitchOn_duration_minute > 0 )                    // still some minutes missing?
    {
        IgnSwitchOn_duration_minute--;
        cancelTimer( _tIgnSwitchOn_duration_msec );
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOn_duration_msec, 60000 );      // 1 minute periode
    }
    else                                                    // timer elapsed, prepare next phase
    {
        Trace("IgnSwitch  On --> Off ", "" );
        putValue( Env_Ignition_Status, cKeyOff );        // switch PowerMode to RUN                                       // switch Ign_Switch to next value
        putValue( eNMHControllerNodeAwake, 0 );
    //    putValue( DIAG_WEM_ReadStatus_Trigger, 0 );
        if( getValue( Env_Power_On_IncDec ) > 0 )
        {
            temp_min = getValue( Env_Power_On_Min );
            temp_msec = getValue( Env_Power_On_Msec );
            Actual_Time = temp_min *60000 + temp_msec;
//          wtemp = getValue( Env_Power_On_Msec_Step );
            // Inc / Dec Handling has to be done
            if( getValue( Env_Power_On_IncDec ) == 1 )
            {    // Inc
                Actual_Time = Actual_Time + getValue( Env_Power_On_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time > AbsStop_Time )
                {
                    Actual_Time = Actual_Time - AbsStop_Time + AbsStart_Time;
                }
            }
            else
            {    // Dec
                Actual_Time = Actual_Time - getValue( Env_Power_On_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time < AbsStart_Time )
                {
                    Actual_Time = Actual_Time + AbsStop_Time - AbsStart_Time;
                }
            }
            putValue( Env_Power_On_Min, ( Actual_Time / 60000 ) );
            putValue( Env_Power_On_Msec, ( Actual_Time - ( getValue( Env_Power_On_Min ) * 60000 )));
        }                                       // switch Ign_Switch to next value
        IgnSwitchOff_duration_minute = getValue( Env_Power_Off_Min ); //restore orig value
//        IgnSwitchOff_duration_msec = getValue( Env_Power_Off_Msec ); //restore orig value
        wtemp = getValue( Env_Power_Off_Msec );                        // get msec value from Panel
        if( wtemp == 0 )                                                // if zero, chek Minute-value
        {
            wtemp = getValue( Env_Power_Off_Min );
            if( wtemp == 0 )                                            // check minute-value of Timer
            {
                wtemp = 1;                                            // .. is also zero : set 1msec
            }
            else
            {
                wtemp = 60000;                                        // .. is not zero: so enter 1 minute
                IgnSwitchOff_duration_minute--;                        // and adjust counter
            }
        }
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOff_duration_msec, wtemp );    // set Timer for next phase "Off"
    }
}

on timer _tIgnSwitchLock_duration_msec
{
    word temp, temp_msec, temp_min;
    dword AbsStart_Time;
    dword AbsStop_Time;
    dword Actual_Time;

    AbsStart_Time = getValue( Env_Power_Lock_Min_Start ) * 60000 + getValue( Env_Power_Lock_Msec_Start );
    AbsStop_Time = getValue( Env_Power_Lock_Min_Stop ) * 60000 + getValue( Env_Power_Lock_Msec_Stop );
    if( IgnSwitchLock_delay > 0 )                    // still some minutes missing
    {
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchLock_duration_msec, IgnSwitchLock_delay );      // delay periode
        IgnSwitchLock_delay = 0;
        return;
    }
    if( IgnSwitchLock_duration_minute > 0 )                    // still some minutes missing?
    {
        IgnSwitchLock_duration_minute--;
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchLock_duration_msec, 60000 );      // 1 minute periode
    }
    else                                                    // timer elapsed, prepare next phase
    {
        Trace("IgnSwitch  Lock --> On ", "");
        putValue( Env_Ignition_Status, cRun );        // switch PowerMode to RUN
        putValue( eNMHControllerNodeAwake, 1 );
 //       putValue( IMS_Ignition_Status, 4 );        // switch PowerMode to RUN
        First = 1;             // Status für WakeUp-Messung setzen
        StartTime = timeNow(); // Zeit festhalten, für WakeUp-Messung
        if( getValue( Env_Power__PowertestMainActiv ) )
        {
            setTimer( _tPowerOnToLogDelay, _cPowerOnToLogDelay );
            setTimer( _t_Power_CheckCommActive, _c_Power_CheckCommActive ); // arm timer for checking if IC is answering
        }
        if( getValue( Env_Power_Lock_IncDec ) > 0 )
        {
            temp_min = getValue( Env_Power_Lock_Min );
            temp_msec = getValue( Env_Power_Lock_Msec );
            Actual_Time = temp_min *60000 + temp_msec;
//          wtemp = getValue( Env_Power_Lock_Msec_Step );
            // Inc / Dec Handling has to be done
            if( getValue( Env_Power_Lock_IncDec ) == 1 )
            {    // Inc
                Actual_Time = Actual_Time + getValue( Env_Power_Lock_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time < AbsStart_Time )
                    Actual_Time = AbsStart_Time;
                if( Actual_Time > AbsStop_Time )
                {
                    Actual_Time = Actual_Time - AbsStop_Time + AbsStart_Time;
                }
            }
            else
            {    // Dec
                Actual_Time = Actual_Time - getValue( Env_Power_Lock_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time > AbsStop_Time )
                    Actual_Time = AbsStop_Time;
                if( Actual_Time < AbsStart_Time )
                {
                    Actual_Time = Actual_Time + AbsStop_Time - AbsStart_Time;
                }
            }
            putValue( Env_Power_Lock_Min, ( Actual_Time / 60000 ) );
            putValue( Env_Power_Lock_Msec, ( Actual_Time - ( getValue( Env_Power_Lock_Min ) * 60000 )));
        }                                       // switch Ign_Switch to next value
        IgnSwitchOn_duration_minute = getValue( Env_Power_On_Min ); //restore orig value
//        IgnSwitchOn_duration_msec = getValue( Env_Power_On_Msec ); //restore orig value
        wtemp = getValue( Env_Power_On_Msec );                        // get msec value from Panel
        if( wtemp == 0 )                                                // if zero, chek Minute-value
        {
            wtemp = getValue( Env_Power_On_Min );
            if( wtemp == 0 )                                            // check minute-value of Timer
            {
                wtemp = 1;                                            // .. is also zero : set 1msec
            }
            else
            {
                wtemp = 60000;                                        // .. is not zero: so enter 1 minute
                IgnSwitchOn_duration_minute--;                        // and adjust counter
            }
        } 
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOn_duration_msec, wtemp );    // set Timer for next phase "Off"
    }
}

on envVar eNMHStateMachineState
{
    word temp, temp_msec, temp_min;
    dword AbsStart_Time;
    dword AbsStop_Time;
    dword Actual_Time;

    if( getValue( this ) == 5 ) // 5 === sleep
    {
    AbsStart_Time = getValue( Env_Power_Off_Min_Start ) * 60000 + getValue( Env_Power_Off_Msec_Start );
    AbsStop_Time = getValue( Env_Power_Off_Min_Stop ) * 60000 + getValue( Env_Power_Off_Msec_Stop );
    if( IgnSwitchOff_delay > 0 )                    // still some minutes missing
    {
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOff_duration_msec, IgnSwitchOff_delay );      // delay periode
        IgnSwitchOff_delay = 0;
        return;
    }
    if( IgnSwitchOff_duration_minute > 0 )                    // still some minutes missing?
    {
        IgnSwitchOff_duration_minute--;
        cancelTimer( _tIgnSwitchOff_duration_msec );
        if( getValue( Env_Power__PowertestMainActiv ) )
            setTimer( _tIgnSwitchOff_duration_msec, 60000 );      // 1 minute periode
    }
    else                                                    // timer elapsed, prepare next phase
    {
        StopTime = timeNow();
    Trace("IgnSwitch  Off --> Lock ", "");
        putValue( Env_Ignition_Status, cKeyOff );        // switch PowerMode to RUN       
   //     if( getValue( DIAG_LOG_OneShotLogLinkedToIgnSwitch ) )
        {
        //    putValue( DIAG_LOG_SessionActiv, 0 );
        }                                    // switch Ign_Switch to next value
        boWaitForIC_Sleep = True;

        if( getValue( Env_Power_Off_IncDec ) > 0 )
        {
            temp_min = getValue( Env_Power_Off_Min );
            temp_msec = getValue( Env_Power_Off_Msec );
            Actual_Time = temp_min *60000 + temp_msec;
//          wtemp = getValue( Env_Power_Off_Msec_Step );
            // Inc / Dec Handling has to be done
            if( getValue( Env_Power_Off_IncDec ) == 1 )
            {    // Inc
                Actual_Time = Actual_Time + getValue( Env_Power_Off_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time > AbsStop_Time )
                {
                    Actual_Time = Actual_Time - AbsStop_Time + AbsStart_Time;
                }
            }
            else
            {    // Dec
                Actual_Time = Actual_Time - getValue( Env_Power_Off_Msec_Step );
                // Begrenzung auf Stop-Zeit
                if( Actual_Time < AbsStart_Time )
                {
                    Actual_Time = Actual_Time + AbsStop_Time - AbsStart_Time;
                }
            }
            putValue( Env_Power_Off_Min, ( Actual_Time / 60000 ) );
            putValue( Env_Power_Off_Msec, ( Actual_Time - ( getValue( Env_Power_Off_Min ) * 60000 )));
        }                                       // switch Ign_Switch to next value
        IgnSwitchLock_duration_minute = getValue( Env_Power_Lock_Min ); //restore orig value
//        IgnSwitchLock_duration_msec = getValue( Env_Power_Lock_Msec ); //restore orig value
        wtemp = getValue( Env_Power_Lock_Msec );                        // get msec value from Panel
        if( wtemp == 0 )                                                // if zero, chek Minute-value
        {
            wtemp = getValue( Env_Power_Lock_Min );
            if( wtemp == 0 )                                            // check minute-value of Timer
            {
                wtemp = 1;                                            // .. is also zero : set 1msec
            }
            else
            {
                wtemp = 60000;                                        // .. is not zero: so enter 1 minute
                IgnSwitchLock_duration_minute--;                        // and adjust counter
            }
        }
    if( getValue( Env_Power__PowertestMainActiv ) )
        setTimer( _tIgnSwitchLock_duration_msec, wtemp );    // set Timer for next phase "Off"
    }
    }
}

on envVar Env_Power__PowertestMainActiv
{
    word temp;
    if(  getValue(this) )
    {

        switch(getValue( Env_Ignition_Status ))
          {
          case 0:       // Lock
            setTimer( _tIgnSwitchLock_duration_msec, _c_Powertest_InitialReactionTime_msec );      
            IgnSwitchLock_duration_minute = 0;
            break;
          case 1:       // Off
            setTimer( _tIgnSwitchOff_duration_msec, _c_Powertest_InitialReactionTime_msec );
            IgnSwitchOff_duration_minute = 0;
                    break;
          case 2:       // Acc
            setTimer( _tIgnSwitchOn_duration_msec, _c_Powertest_InitialReactionTime_msec );      
            IgnSwitchOn_duration_minute = 0;
                    break;
          case 4:       // Run
            setTimer( _tIgnSwitchOn_duration_msec, _c_Powertest_InitialReactionTime_msec );      
            IgnSwitchOn_duration_minute = 0;
                    break;
          case 5:       // Crank
            setTimer( _tIgnSwitchOn_duration_msec, _c_Powertest_InitialReactionTime_msec );      
            IgnSwitchOn_duration_minute = 0;
                    break;
        }
            Trace("Stopmode Test started ", "");

    IgnSwitchOn_duration_minute = getValue( Env_Power_Lock_Min );
    
        wtemp  = getValue( Env_Power_Lock_Msec );
        if( wtemp > 0 )                    // still some minutes missing?
        {
            setTimer( _tIgnSwitchOn_duration_msec, wtemp );      
        }
        else
        {
            IgnSwitchOn_duration_minute--;
            setTimer( _tIgnSwitchOn_duration_msec, 60000 );      // 1 minute periode
        }
    }
    else
    {
        cancelTimer( _tIgnSwitchOn_duration_msec );
        cancelTimer( _tIgnSwitchOff_duration_msec );
        cancelTimer( _tIgnSwitchLock_duration_msec );
//        cancelTimer( _t_Power_CheckCommActive );
    }
}    

on envVar Env_Power__SaveParameters
{
    if( getvalue( this ))
    {
        Power__iniWriteAll("ini_data\\Powertest.ini");
    }    
}

Power__iniWriteAll (char iniFilename[])
{
      char buffer [256];
   
      // Schreibe zwei INT-Paramter und einen String in die 
      // INI-Datei "Test.Ini".
      //  "WritePara1",
      //  "WritePara2", 
      //  "WriteMessage"   (Sektion "Output") 

      //
      // Wird der Pfad fuer die Schreiboperation nicht explizit 
      // gesetzt, so wird der Pfad der Konfigurationsdatei heran-
      // gezogen.
      // 
      snprintf (buffer,elcount(buffer),"%d",readPara1);
      writeProfileString ( "Output","WritePara1", buffer, iniFilename );

      snprintf (buffer,elcount(buffer),"%d",readPara2);
      writeProfileString ( "Output","WritePara2", buffer, iniFilename );

      writeProfileInt    ( "Output","WriteInt1", readPara1, iniFilename );
      writeProfileInt    ( "Output","WriteInt2", readPara2, iniFilename );
      writeProfileString ( "Output","WriteMessage", "TestString", iniFilename );

    lWriteError = 1; // 0 = Error while writing ini-file

    strncpy( func, "Power", 20 );    // Name of functionality

    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Min",                 getValue( Env_Power_On_Min ),               iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Msec",                getValue( Env_Power_On_Msec ),              iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_IncDec",              getValue( Env_Power_On_IncDec ),            iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Msec_Step",           getValue( Env_Power_On_Msec_Step ),         iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Min",                getValue( Env_Power_Off_Min ),              iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Msec",               getValue( Env_Power_Off_Msec ),             iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_IncDec",             getValue( Env_Power_Off_IncDec ),           iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Msec_Step",          getValue( Env_Power_Off_Msec_Step ),        iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Min",               getValue( Env_Power_Lock_Min ),             iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Msec",              getValue( Env_Power_Lock_Msec ),            iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_IncDec",            getValue( Env_Power_Lock_IncDec ),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Msec_Step",         getValue( Env_Power_Lock_Msec_Step ),       iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power__PowertestMainActiv",    getValue( Env_Power__PowertestMainActiv ),  iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Min_Start",           getValue( Env_Power_On_Min_Start ),         iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Msec_Start",          getValue( Env_Power_On_Msec_Start ),        iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Min_Stop",            getValue( Env_Power_On_Min_Stop ),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_On_Msec_Stop",           getValue( Env_Power_On_Msec_Stop ),         iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Min_Start",          getValue( Env_Power_Off_Min_Start ),        iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Msec_Start",         getValue( Env_Power_Off_Msec_Start ),       iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Min_Stop",           getValue( Env_Power_Off_Min_Stop ),         iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Off_Msec_Stop",          getValue( Env_Power_Off_Msec_Stop ),        iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Min_Start",         getValue( Env_Power_Lock_Min_Start ),       iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Msec_Start",        getValue( Env_Power_Lock_Msec_Start ),      iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Min_Stop",          getValue( Env_Power_Lock_Min_Stop ),        iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "Power_Lock_Msec_Stop",         getValue( Env_Power_Lock_Msec_Stop ),       iniFilename );



    if( lWriteError == 0 )    write( "!! Error while writing INI-file !!" );
}

on message NMH_Kombi
{
    if( getValue( Env_Ignition_Status ) == 0 )
    {
        cancelTimer( _tNM_COM_StayActiveTimer );
        setTimer( _tNM_COM_StayActiveTimer, _cNM_COM_StayActiveTimer );
    }
    cancelTimer( _t_Power_CheckCommActive );

    if(First) // first NM message after wakeup
    {
        FirstNMTime = timeNow();
        diff = (FirstNMTime - StartTime) / 100;
        putValue(Env_WakeupTime, diff);
        // WriteParametersToLog();
        write("Ign        WakeUp took %ld ms", diff);
        First = 0;
    }
}

on timer _t_Power_CheckCommActive
{
    cancelTimer( _tIgnSwitchOn_duration_msec );
    cancelTimer( _tIgnSwitchOff_duration_msec );
    cancelTimer( _tIgnSwitchLock_duration_msec );
    Trace("ERROR !!!    IC doesn't wake up   !!!", "");
    Trace("Stopmode Test halted ", "");
}

on timer _tNM_COM_StayActiveTimer
{
//    putValue( Env___start_Stop_DBKom_Timer, 0 );
}

on errorPassive
{
}

Power__iniReadAll (char iniFilename[])
{
      // Lese zwei INT-Parameter aus der INI Datei "Test.Ini" :
      //  "ReadPara1",
      //  "ReadPara2".     (Sektion "Input")
      // 
      readPara1 = getProfileInt("Input","ReadPara1",defVal,iniFilename );
      readPara2 = getProfileInt("Input","ReadPara2",defVal,iniFilename );
      //
      // Wird der Pfad fuer die Schreiboperation nicht explizit 
      // gesetzt, so wird der Pfad der Konfigurationsdatei heran-
      // gezogen.
      // 
//    writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "      read Power Test INI-file in fkt");

    strncpy(func, "Power", 20 );    // Name of functionality
//    writeLineEx(dwWriteSinkSimu, 1 /*Info*/, "read ini file '%s'",iniFilename );

//    putvalue( Env_Power_Lock_Min, getProfileInt( func, "Power_Lock_Min", defPower_Lock_Min, iniFilename));
    putvalue( Env_Power_On_Min,              getProfileInt( func, "Power_On_Min",               defPower_On_Min,              iniFilename));
    putvalue( Env_Power_On_Msec,             getProfileInt( func, "Power_On_Msec",              defPower_On_Msec,             iniFilename));
    putvalue( Env_Power_On_IncDec,           getProfileInt( func, "Power_On_IncDec",            defPower_On_IncDec,           iniFilename));
    putvalue( Env_Power_On_Msec_Step,        getProfileInt( func, "Power_On_Msec_Step",         defPower_On_Msec_Step,        iniFilename));
    putvalue( Env_Power_Off_Min,             getProfileInt( func, "Power_Off_Min",              defPower_Off_Min,             iniFilename));
    putvalue( Env_Power_Off_Msec,            getProfileInt( func, "Power_Off_Msec",             defPower_Off_Msec,            iniFilename));
    putvalue( Env_Power_Off_IncDec,          getProfileInt( func, "Power_Off_IncDec",           defPower_Off_IncDec,          iniFilename));
    putvalue( Env_Power_Off_Msec_Step,       getProfileInt( func, "Power_Off_Msec_Step",        defPower_Off_Msec_Step,       iniFilename));
    putvalue( Env_Power_Lock_Min,            getProfileInt( func, "Power_Lock_Min",             defPower_Lock_Min,            iniFilename));
    putvalue( Env_Power_Lock_Msec,           getProfileInt( func, "Power_Lock_Msec",            defPower_Lock_Msec,           iniFilename));
    putvalue( Env_Power_Lock_IncDec,         getProfileInt( func, "Power_Lock_IncDec",          defPower_Lock_IncDec,         iniFilename));
    putvalue( Env_Power_Lock_Msec_Step,      getProfileInt( func, "Power_Lock_Msec_Step",       defPower_Lock_Msec_Step,      iniFilename));
    putvalue( Env_Power__PowertestMainActiv, getProfileInt( func, "Power__PowertestMainActiv",  defPower__PowertestMainActiv, iniFilename));
    putvalue( Env_Power_On_Min_Start,        getProfileInt( func, "Power_On_Min_Start",         defPower_On_Min,              iniFilename));
    putvalue( Env_Power_On_Msec_Start,       getProfileInt( func, "Power_On_Msec_Start",        defPower_On_Msec,             iniFilename));
    putvalue( Env_Power_On_Min_Stop,         getProfileInt( func, "Power_On_Min_Stop",          defPower_On_Min,              iniFilename));
    putvalue( Env_Power_On_Msec_Stop,        getProfileInt( func, "Power_On_Msec_Stop",         defPower_On_Msec,             iniFilename));
    putvalue( Env_Power_Off_Min_Start,       getProfileInt( func, "Power_Off_Min_Start",        defPower_Off_Min,             iniFilename));
    putvalue( Env_Power_Off_Msec_Start,      getProfileInt( func, "Power_Off_Msec_Start",       defPower_Off_Msec,            iniFilename));
    putvalue( Env_Power_Off_Min_Stop,        getProfileInt( func, "Power_Off_Min_Stop",         defPower_Off_Min,             iniFilename));
    putvalue( Env_Power_Off_Msec_Stop,       getProfileInt( func, "Power_Off_Msec_Stop",        defPower_Off_Msec,            iniFilename));
    putvalue( Env_Power_Lock_Min_Start,      getProfileInt( func, "Power_Lock_Min_Start",       defPower_Lock_Min,            iniFilename));
    putvalue( Env_Power_Lock_Msec_Start,     getProfileInt( func, "Power_Lock_Msec_Start",      defPower_Lock_Msec,           iniFilename));
    putvalue( Env_Power_Lock_Min_Stop,       getProfileInt( func, "Power_Lock_Min_Stop",        defPower_Lock_Min,            iniFilename));
    putvalue( Env_Power_Lock_Msec_Stop,      getProfileInt( func, "Power_Lock_Msec_Stop",       defPower_Lock_Msec,           iniFilename));
}

Config__iniReadAll (char iniFilename[])
{
      // Lese zwei INT-Parameter aus der INI Datei "Test.Ini" :
      //  "ReadPara1",
      //  "ReadPara2".     (Sektion "Input")
      // 
      readPara1 = getProfileInt("Input","ReadPara1",defVal,iniFilename );
      readPara2 = getProfileInt("Input","ReadPara2",defVal,iniFilename );
      //
      // Wird der Pfad fuer die Schreiboperation nicht explizit 
      // gesetzt, so wird der Pfad der Konfigurationsdatei heran-
      // gezogen.
      // 

    strncpy(func, "Power", 20 );    // Name of functionality

//    putvalue( Env_Power_Lock_Min, getProfileInt( func, "Power_Lock_Min", defPower_Lock_Min, iniFilename));
/*    putvalue( Env_Power_On_Min,                 getProfileInt( func, "Power_On_Min",                 defPower_On_Min,                 iniFilename));
    putvalue( Env_Power_On_Msec,             getProfileInt( func, "Power_On_Msec",                 defPower_On_Msec,                 iniFilename));
    putvalue( Env_Power_On_IncDec,             getProfileInt( func, "Power_On_IncDec",             defPower_On_IncDec,             iniFilename));
    putvalue( Env_Power_On_Msec_Step,          getProfileInt( func, "Power_On_Msec_Step",             defPower_On_Msec_Step,             iniFilename));
    putvalue( Env_Power_Off_Min,              getProfileInt( func, "Power_Off_Min",                 defPower_Off_Min,                 iniFilename));
    putvalue( Env_Power_Off_Msec,              getProfileInt( func, "Power_Off_Msec",                 defPower_Off_Msec,                 iniFilename));
    putvalue( Env_Power_Off_IncDec,          getProfileInt( func, "Power_Off_IncDec",             defPower_Off_IncDec,             iniFilename));
    putvalue( Env_Power_Off_Msec_Step,          getProfileInt( func, "Power_Off_Msec_Step",         defPower_Off_Msec_Step,            iniFilename));
    putvalue( Env_Power_Lock_Min,              getProfileInt( func, "Power_Lock_Min",                 defPower_Lock_Min,                 iniFilename));
    putvalue( Env_Power_Lock_Msec,              getProfileInt( func, "Power_Lock_Msec",             defPower_Lock_Msec,             iniFilename));
    putvalue( Env_Power_Lock_IncDec,          getProfileInt( func, "Power_Lock_IncDec",             defPower_Lock_IncDec,             iniFilename));
    putvalue( Env_Power_Lock_Msec_Step,      getProfileInt( func, "Power_Lock_Msec_Step",         defPower_Lock_Msec_Step,         iniFilename));
    putvalue( Env_Power__PowertestMainActiv, getProfileInt( func, "Power__PowertestMainActiv",     defPower__PowertestMainActiv,     iniFilename));


*/
}

void Config_vFindCurrentSelectedSection()
{
 char cConfig_TMPiniSection[100];
  write("Config_eSelConfiguration=[%x]",getValue(Env_Config__Config_Variant));
 switch(getValue(Env_Config__Config_Variant))
    {
        case CONFIG_MIN:      // CONFIG_MAX
            strncpy(cConfig_iniSection, "CONFIG_MIN", 16);
        break;
        case CONFIG_MAX:      // CONFIG_MAX
            strncpy(cConfig_iniSection, "CONFIG_MAX", 16);
        break;
        case CONFIG_TYPICAL:      // CONFIG_TYPICAL
            strncpy(cConfig_iniSection, "CONFIG_TYPICAL", 16);
        break;
        case CONFIG_1:      // CONFIG_1
            strncpy(cConfig_iniSection, "CONFIG_1", 16);
        break;
        case CONFIG_2:      // CONFIG_2
            strncpy(cConfig_iniSection, "CONFIG_2", 16);
        break;
        case CONFIG_3:      // CONFIG_3
            strncpy(cConfig_iniSection, "CONFIG_3", 16);
        break;
        case CONFIG_4:      // CONFIG_4
            strncpy(cConfig_iniSection, "CONFIG_4", 16);
        break;
        case CONFIG_5:      // CONFIG_5
            strncpy(cConfig_iniSection, "CONFIG_5", 16);
        break;
        case CONFIG_6:      // CONFIG_6
            strncpy(cConfig_iniSection, "CONFIG_6", 16);
        break;
        case CONFIG_7:      // CONFIG_7
            strncpy(cConfig_iniSection, "CONFIG_7", 16);
        break;
        case CONFIG_8:      // CONFIG_8
            strncpy(cConfig_iniSection, "CONFIG_8", 16);
        break;
        case CONFIG_9:      // CONFIG_9
            strncpy(cConfig_iniSection, "CONFIG_9", 16);
        break;
        case CONFIG_10:      // CONFIG_10
            strncpy(cConfig_iniSection, "CONFIG_10", 16);
        break;
        case CONFIG_11:      // CONFIG_11
            strncpy(cConfig_iniSection, "CONFIG_11", 16);
        break;
        case CONFIG_12:      // CONFIG_12
            strncpy(cConfig_iniSection, "CONFIG_12", 16);
        break;
        case CONFIG_13:      // CONFIG_13
            strncpy(cConfig_iniSection, "CONFIG_13", 16);
        break;
        default:
            strncpy(cConfig_iniSection, "DEFAULT", 16);
        break;
     }   

   
}

void Config__vInitializeEnvVar()
{
    
    char cConfig_iniFile[100] = "\\Config\\Config.ini";
    char cConfig_iniDefaultVal[100]="Not in *.ini file";
    char cConfig_iniDefaultCfgVal[100]="n.a.";
    
    char cReadBuffer[100];

       Config_vFindCurrentSelectedSection();

    getProfileString(cConfig_iniSection, "Config_eDataSectiontxt",  "Not Defined", cReadBuffer, elcount(cReadBuffer), cConfig_iniFile);putValue(Env_Config_eDataSectiontxt,cReadBuffer);




}

byte Config__vInitEnvVarCfgToNumber(char cIND_intxt[])
{
    byte u8RetVal = 0; // default:  n.a.
   
    if(!strncmp(cIND_intxt,"0",strlen(cIND_intxt)))  u8RetVal = 0x0;
    else if(!strncmp(cIND_intxt,"1",strlen(cIND_intxt))) u8RetVal = 0x1;
    else  u8RetVal = 0;

    return u8RetVal;

}

void Config_vDataSave()
{
       // load the confog fields with the corresponding data from ini file
    byte u8chekcode= 1;
    char cIND_iniFile[100] = "\\Config\\IND.ini";
    char cIND_iniSection[100];
    char cIND_iniTagBase[100]="IND_eIndData";
    char cIND_iniTag0[100],cIND_iniTag1[100],cIND_iniTag2[100],cIND_iniTag3[100],cIND_iniTag4[100],cIND_iniTag5[100],cIND_iniTag6[100],cIND_iniTag7[100];
    char cWriteBuffer[100];
    char cNum[4];

       Config_vFindCurrentSelectedCFGSection();
    
    // create the TAGs  e.G. "IND_eIndData0_0_txt", when Data set 0 is selected
//    ltoa( getValue( IND_eIndDataX_X_Selector ), cNum, 10 );
    
    //write the descriptions
} 

void Config_vFindCurrentSelectedCFGSection()
{
    switch(getValue(Env_Config_eSelConfigSetup))
    {
        case CONFIG_MIN:      // CONFIG_MAX
            strncpy(cConfig_iniSection, "CONFIG_MIN", 16);
        break;
        case CONFIG_MAX:      // CONFIG_MAX
            strncpy(cConfig_iniSection, "CONFIG_MAX", 16);
        break;
        case CONFIG_TYPICAL:      // CONFIG_TYPICAL
            strncpy(cConfig_iniSection, "CONFIG_TYPICAL", 16);
        break;
        case CONFIG_1:      // CONFIG_1
            strncpy(cConfig_iniSection, "CONFIG_1", 16);
        break;
        case CONFIG_2:      // CONFIG_2
            strncpy(cConfig_iniSection, "CONFIG_2", 16);
        break;
        case CONFIG_3:      // CONFIG_3
            strncpy(cConfig_iniSection, "CONFIG_3", 16);
        break;
        case CONFIG_4:      // CONFIG_4
            strncpy(cConfig_iniSection, "CONFIG_4", 16);
        break;
        case CONFIG_5:      // CONFIG_5
            strncpy(cConfig_iniSection, "CONFIG_5", 16);
        break;
        case CONFIG_6:      // CONFIG_6
            strncpy(cConfig_iniSection, "CONFIG_6", 16);
        break;
        case CONFIG_7:      // CONFIG_7
            strncpy(cConfig_iniSection, "CONFIG_7", 16);
        break;
        case CONFIG_8:      // CONFIG_8
            strncpy(cConfig_iniSection, "CONFIG_8", 16);
        break;
        case CONFIG_9:      // CONFIG_9
            strncpy(cConfig_iniSection, "CONFIG_9", 16);
        break;
        case CONFIG_10:      // CONFIG_10
            strncpy(cConfig_iniSection, "CONFIG_10", 16);
        break;
        case CONFIG_11:      // CONFIG_11
            strncpy(cConfig_iniSection, "CONFIG_11", 16);
        break;
        case CONFIG_12:      // CONFIG_12
            strncpy(cConfig_iniSection, "CONFIG_12", 16);
        break;
        case CONFIG_13:      // CONFIG_13
            strncpy(cConfig_iniSection, "CONFIG_13", 16);
        break;
        default:
            strncpy(cConfig_iniSection, "DEFAULT", 16);
        break;
     }   
}

void Trace( char functionName[], char info[])
{
  Trace( functionName, info, "");
}

void Trace( char functionName[], char info[], char verbose[])
{
  char sep[2] = "/";
  sep[0] = functionName[0] ? '/' : 0;
  if( verbose[0])
  {
    write( "[%.3f] HGW_VDO %s%s: %s", timeNow()/100000.0
           , sep
           , functionName
           , verbose
           );
  } else
  {
    write( "[%.3f] HGW_VDO %s%s: %s", timeNow()/100000.0
           , sep
           , functionName
           , info
           );
  }
}

void Trace( char functionName[], char info[], char verbose[], long argument)
{
  char line[100];
  snprintf( line, elcount(line ), verbose, argument);
  Trace( functionName, info, line );
}

void TraceCall( char functionName[], long callResult)
{
  char line[100];
  if( callResult == 1 )
    snprintf( line, elcount(line ), "calling %s", functionName );
  else
    snprintf( line, elcount(line ), "call to %s failed - wrong state?", functionName );
  Trace( "", "", line );
}

on timer _tPowerOnToLogDelay
{
 //   if( getValue( DIAG_LOG_OneShotLogLinkedToIgnSwitch ) )
    {
    //    putValue( DIAG_LOG_SessionActiv, 1 );
    }
}

Time_GetPC_Time()
{
    int i;
    char temp[64];
    byte bLength;
    byte bResult;
    byte acLineData[40];

    long tm[9];
    getLocalTime(tm);
// now tm contains the following entries:
// tm[0] = 3; (seconds)
// tm[1] = 51; (minutes)
// tm[2] = 16; (hours)
// tm[3] = 21; (day of month)
// tm[4] = 7; (month stating with 0)
// tm[5] = 98; (year)
// tm[6] = 5; (weekday)
// tm[7] = 232;(day of year)
// tm[8] = 1; (Summer time)
    putValue( Env_PC_Time_Second, tm[0] );
    putValue( Env_PC_Time_Minute, tm[1] );
    putValue( Env_PC_Time_Hour,   tm[2] );
    putValue( Env_PC_Time_Day,    tm[3] );
    putValue( Env_PC_Time_Month,  tm[4] + 1 );
    putValue( Env_PC_Time_Year,   tm[5] + 1900 );
//    putValue( Env_PC_Time_Update_IPC, 1 );
    //putValue( Env_PC_Time_Update_IPC, 0 );
}

on timer tPC_Time_read
{
    Time_GetPC_Time();
    setTimer( tPC_Time_read, 100 );
}

on envVar Env_PC_Time_Update_IPC
{
    if( getValue( this ) )
    {
    //    putValue( HMI_DateTmSecond_Rq, getValue( Env_PC_Time_Second ));
    //    putValue( HMI_DateTmMinute_Rq, getValue( Env_PC_Time_Minute ));
    //    putValue( HMI_DateTmHour_Rq, getValue( Env_PC_Time_Hour ));
    //    putValue( HMI_DateTmDay_Rq, getValue( Env_PC_Time_Day ));
    //    putValue( HMI_DateTmMonth_Rq, getValue( Env_PC_Time_Month ));
    //    putValue( HMI_DateTmYear_Rq, getValue( Env_PC_Time_Year ) );
    //    putValue( HMI_DateTmStat_Rq, 3 );
    }
 //   else
    //    putValue( HMI_DateTmStat_Rq, 2 );
}

on envVar Env_Stress__SaveParameters
// **************************************************************************************************
// ******************************************************* Stresstest *******************************
// **************************************************************************************************

{
    if( getvalue(this))
    {
        Stress__iniWriteAll("ini_data\\Stresstest.ini");
    }    
}

on envVar Env_Stress__StresstestMainActiv
{
    if( getvalue(this))
    {
//        writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "\n        started\n");
        putvalue(Env_Modus_Manuell, 0 ); // Data automatically sended
    }
    else
    {
//        writeLineEx(dwWriteSinkSimu, dwWriteSeveritySuccess, "\n        stopped\n");
    }

    Stress__CheckAll();
    Stress__WriteSinkAll();
}

int Stress__CalcNext_Index(int iDirection, int iIndexMax)
{
    
    if( ((lCurrentVal >= iIndexMax) && (iDirection == 1)) || ((lCurrentVal <= 0) && (iDirection == -1)))
    {
        iDirection *= -1;
    }
    
    lCurrentVal += iDirection;

    return (iDirection);
}

int Stress__CalcNext_PointerVal (long lStepWidth,    int iDirection,    long lMinVal,    long lMaxVal)
{
    // additional (global) function changeable parameter is: lCurrentVal
    // returning new direction

    if( ((lCurrentVal >= lMaxVal) && (iDirection == 1)) || ((lCurrentVal <= lMinVal) && (iDirection == -1)))
    {
        iDirection *= -1;
    }

    lCurrentVal += (iDirection * lStepWidth);

    if( lCurrentVal >= lMaxVal)
    {
        lCurrentVal = lMaxVal;
    }

    if( lCurrentVal <= lMinVal)
    {
        lCurrentVal = lMinVal;
    }

    return(iDirection);
}

Stress__CheckAll()
{
    if( Stress_CoolantTemp_CheckActiv())    putvalue(Env_EngClnt_Te_Actl_Fehler, 0 ); // always take stresstest cooling temp values
    Stress_GearBox_CheckActiv();
    Stress_OutsideAirtemp_CheckActiv();
    Stress_Parking_CheckActiv();
    if( Stress_Revolution_CheckActiv())    putvalue(Env_EngAout_N_Actl_Fehler, 0 ); // always take stresstest revolution values
    Stress_SegBegin_CheckActiv();
    Stress_SegEnd_CheckActiv();
    Stress_DayNight_CheckActiv();
    Stress_Speed_CheckActiv();
    Stress_Tank_CheckActiv();
}

Stress__WriteSinkAll()
{
    Stress_CoolantTemp_WriteSink();
    Stress_GearBox_WriteSink();
    Stress_OutsideAirtemp_WriteSink();
    Stress_Parking_WriteSink();
    Stress_Revolution_WriteSink();
    Stress_SegBegin_WriteSink();
    Stress_SegEnd_WriteSink();
    Stress_DayNight_WriteSink();
    Stress_Speed_WriteSink();
    Stress_Tank_WriteSink();
}

Stress__iniReadAll (char iniFilename[])
{
      // Lese zwei INT-Parameter aus der INI Datei "Test.Ini" :
      //  "ReadPara1",
      //  "ReadPara2".     (Sektion "Input")
      // 
      readPara1 = getProfileInt("Input","ReadPara1",defVal,iniFilename );
      readPara2 = getProfileInt("Input","ReadPara2",defVal,iniFilename );
      //
      // Wird der Pfad fuer die Schreiboperation nicht explizit 
      // gesetzt, so wird der Pfad der Konfigurationsdatei heran-
      // gezogen.
      // 

    Stress_CoolantTemp_IniRead( iniFilename );
    Stress_GearBox_IniRead( iniFilename );
    Stress_DayNight_IniRead( iniFilename );
    Stress_OutsideAirtemp_IniRead( iniFilename );
    Stress_Parking_IniRead( iniFilename );
    Stress_Revolution_IniRead( iniFilename );
    Stress_SegBegin_IniRead( iniFilename );
    Stress_SegEnd_IniRead( iniFilename );
    Stress_Speed_IniRead( iniFilename );
    Stress_Tank_IniRead( iniFilename );

}

Stress__iniWriteAll (char iniFilename[])
{
      char buffer [256];
   
      // Schreibe zwei INT-Paramter und einen String in die 
      // INI-Datei "Test.Ini".
      //  "WritePara1",
      //  "WritePara2", 
      //  "WriteMessage"   (Sektion "Output") 

      //
      // Wird der Pfad fuer die Schreiboperation nicht explizit 
      // gesetzt, so wird der Pfad der Konfigurationsdatei heran-
      // gezogen.
      // 
      snprintf (buffer,elcount(buffer),"%d",readPara1);
      writeProfileString ("Output","WritePara1",buffer,iniFilename );

      snprintf (buffer,elcount(buffer),"%d",readPara2);
      writeProfileString ("Output","WritePara2",buffer,iniFilename );

      writeProfileInt    ("Output","WriteInt1",readPara1,iniFilename );
      writeProfileInt    ("Output","WriteInt2",readPara2,iniFilename );
      writeProfileString ("Output","WriteMessage","TestString",iniFilename );

    lWriteError = 1; // 0 = Error while writing ini-file

    if( lWriteError != 0)    Stress_CoolantTemp_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_GearBox_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_DayNight_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_OutsideAirtemp_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_Parking_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_Revolution_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_SegBegin_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_SegEnd_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_Speed_IniWrite( iniFilename );
    if( lWriteError != 0)    Stress_Tank_IniWrite( iniFilename );

    if( lWriteError == 0)    write("!! Error while writing INI-file !!");
}

on envVar Env_Stress_CoolantTemp_SweepActiv
{
    Stress_CoolantTemp_WriteSink();
    if( Stress_CoolantTemp_CheckActiv() )    putvalue( Env_EngAout_N_Actl_Fehler, 0 ); // always take stresstest cooling temp values
}

on envVar Env_Stress_CoolantTemp_TimeInterval
{
    Stress_CoolantTemp_CheckActiv();
}

on timer _t_Stress_ChangeCoolTemp
{
    if( Stress_CoolantTemp_CheckActiv())
    {
        Stress_CoolantTemp_CalcNext();
    }
}

Stress_CoolantTemp_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_CoolantTemp_CurrentVal ); // aditional changeable parameter
    iDirectionCoolTemp = Stress__CalcNext_PointerVal(getvalue( Env_Stress_CoolantTemp_StepWidth ), iDirectionCoolTemp, getvalue( Env_Stress_CoolantTemp_Min ), getvalue( Env_Stress_CoolantTemp_Max ));
//    putvalue( Env_Stress_CoolantTemp_CurrentVal, lCurrentVal );
//    putvalue( Env_EngClnt_Te_Actl, lCurrentVal );
}

int Stress_CoolantTemp_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeCoolTemp);
    iTemp = getvalue( Env_Stress_CoolantTemp_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv);
//    write("CoolTempActiv = %d und _StresstestMainActiv = %d, verUNDed = %d",getvalue( CoolTempSweepActiv), getvalue(_StresstestMainActiv), iTemp);
    if( iTemp)
    {
        settimer(_t_Stress_ChangeCoolTemp, getvalue( Env_Stress_CoolantTemp_TimeInterval ));
    }

    return(iTemp);
}

Stress_CoolantTemp_IniRead (char iniFilename[])
{
    strncpy(func, "CoolantTemp", 20 );    // Name of functionality

/*    putvalue( Env_Stress_CoolantTemp_SweepActiv,   getProfileInt( func, "CoolTempSweepActiv", defCoolTempSweepActiv, iniFilename));
    putvalue( Env_Stress_CoolantTemp_Min,          getProfileInt( func, "CoolTempMin", defCoolTempMin, iniFilename));
    putvalue( Env_Stress_CoolantTemp_Max,          getProfileInt( func, "CoolTempMax", defCoolTempMax, iniFilename));
    putvalue( Env_Stress_CoolantTemp_StepWidth,    getProfileInt( func, "CoolTempStepWidth", defCoolTempStepWidth, iniFilename));
    putvalue( Env_Stress_CoolantTemp_TimeInterval, getProfileInt( func, "CoolTempTimeInterval", defCoolTempTimeInterval, iniFilename));
*/}

Stress_CoolantTemp_IniWrite (char iniFilename[])
{
    strncpy(func, "CoolantTemp", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "CoolTempSweepActiv",   getValue( Env_Stress_CoolantTemp_SweepActiv ), iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "CoolTempMin",          getValue( Env_Stress_CoolantTemp_Min), iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "CoolTempMax",          getValue( Env_Stress_CoolantTemp_Max), iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "CoolTempStepWidth",    getValue( Env_Stress_CoolantTemp_StepWidth ), iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "CoolTempTimeInterval", getValue( Env_Stress_CoolantTemp_TimeInterval ), iniFilename );
*/}

Stress_CoolantTemp_WriteSink()
{
    if( getvalue( Env_Stress_CoolantTemp_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep CoolantTemp");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep CoolantTemp");
    }
}

on envVar Env_Stress_DayNightToggleActiv
{
 //   if( getValue ( HMI_LgtSens_Night) != 1 ) // if not SLOW_ON
    {
 //       putValue ( HMI_LgtSens_Night, 0 );   // set SLOW_OFF
    }
    Stress_DayNight_WriteSink();
    Stress_DayNight_CheckActiv();
}

on envVar Env_Stress_DayNightTimeInterval
{
    Stress_DayNight_CheckActiv();
}

on timer _t_Stress_ToggleDayNight
{
    if( Stress_DayNight_CheckActiv())
    {
        Stress_DayNight_CalcNext();
    }
}

Stress_DayNight_CalcNext()
{
/*    if( getvalue( IMS_Dimming_Lvl ) != 18 )
    {
        putValue( IMS_Dimming_Lvl, 18 );
        return;
    }

    if( getvalue( IMS_Dimming_Lvl ) != 7 )
    {
        putValue( IMS_Dimming_Lvl, 7 );
    }*/
}

int Stress_DayNight_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ToggleDayNight );
    iTemp = getvalue( Env_Stress_DayNightToggleActiv ) && getvalue( Env_Stress__StresstestMainActiv );
//    write("GearBoxActiv = %d und _StresstestMainActiv = %d, verUNDed = %d",getvalue(GearBoxSweepActiv), getvalue(_StresstestMainActiv), iTemp);
    if( iTemp )
    {
        settimer( _t_Stress_ToggleDayNight, getvalue( Env_Stress_DayNightTimeInterval ) );
    }

    return( iTemp );
}

Stress_DayNight_IniRead (char iniFilename[])
{
    strncpy(func, "NightView", 20 );    // Name of functionality

//    putvalue( Env_Stress_DayNightToggleActiv, getProfileInt( func, "DayNightToggleActiv", defDayNightToggleActiv, iniFilename));
//    putvalue( Env_Stress_DayNightTimeInterval, getProfileInt( func, "DayNightTimeInterval", defDayNightTimeInterval, iniFilename));
}

Stress_DayNight_IniWrite (char iniFilename[])
{
    strncpy(func, "DayNight", 20 );    // Name of functionality

//    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "DayNightToggleActiv", getValue( Env_Stress_DayNightToggleActiv ), iniFilename );
//    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "DayNightTimeInterval", getValue( Env_Stress_DayNightTimeInterval ), iniFilename );
}

Stress_DayNight_WriteSink()
{
    if( getvalue( Env_Stress_DayNightToggleActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx( dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Toggle DayNight");
    }
    else
    {
        writeLineEx( dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Toggle DayNight");
    }
}

on envVar Env_Stress_GearBoxSweepActiv
{
    Stress_GearBox_WriteSink();
    Stress_GearBox_CheckActiv();
}

on envVar Env_Stress_GearBoxTimeInterval
{
    Stress_GearBox_CheckActiv();
}

on timer _t_Stress_ChangeGearBox
{
    if( Stress_GearBox_CheckActiv())
    {
        Stress_GearBox_CalcNext();
    }
}

Stress_GearBox_CalcNext()
{
    if( getvalue( Env_Stress_GearBoxRandom ))
    {
        iPosArray_index  = random(iPosArray_indexMax);
        iProgArray_index = random(iProgArray_indexMax);
    }
    else
    {
        lCurrentVal = iPosArray_index; // aditional changeable parameter
        iDirectionGearBoxPos = Stress__CalcNext_Index(iDirectionGearBoxPos, iPosArray_indexMax);
        iPosArray_index = lCurrentVal;

        lCurrentVal = iProgArray_index; // aditional changeable parameter
        iDirectionGearBoxProg = Stress__CalcNext_Index(iDirectionGearBoxProg, iProgArray_indexMax);
        iProgArray_index = lCurrentVal;
    }

 //   putvalue( Env_Stress_GearBoxPosCurrentVal,  abPosArray[iPosArray_index] );
//    putvalue( Env_Stress_GearBoxProgCurrentVal, abProgArray[iProgArray_index] );
 //   putvalue( HMI_TxDrvPosn_Disp_Rq_TCM,  abPosArray[iPosArray_index] );
 //   putvalue( HMI_TxDrvProg_Disp_Rq_TCM, abProgArray[iProgArray_index] );
}

int Stress_GearBox_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeGearBox);
    iTemp = getvalue( Env_Stress_GearBoxSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
//    write("GearBoxActiv = %d und _StresstestMainActiv = %d, verUNDed = %d",getvalue(GearBoxSweepActiv), getvalue(_StresstestMainActiv), iTemp);
    if( iTemp)
    {
        settimer(_t_Stress_ChangeGearBox, getvalue( Env_Stress_GearBoxTimeInterval ));
    }
    return(iTemp);
}

Stress_GearBox_IniRead (char iniFilename[])
{
    strncpy(func, "GearBox", 20 );    // Name of functionality

//    putvalue( Env_Stress_GearBoxSweepActiv,   getProfileInt( func, "GearBoxSweepActiv",   defGearBoxSweepActiv,   iniFilename ) );
//    putvalue( Env_Stress_GearBoxRandom,       getProfileInt( func, "GearBoxRandom",       defGearBoxRandom,       iniFilename ) );
//    putvalue( Env_Stress_GearBoxTimeInterval, getProfileInt( func, "GearBoxTimeInterval", defGearBoxTimeInterval, iniFilename ) );
}

Stress_GearBox_IniWrite (char iniFilename[])
{
    strncpy(func, "GearBox", 20 );    // Name of functionality

//    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "GearBoxSweepActiv",   getValue( Env_Stress_GearBoxSweepActiv ),   iniFilename );
//    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "GearBoxRandom",       getValue( Env_Stress_GearBoxRandom ),       iniFilename );
//    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "GearBoxTimeInterval", getValue( Env_Stress_GearBoxTimeInterval ), iniFilename );
}

Stress_GearBox_WriteSink()
{
    if( getvalue( Env_Stress_GearBoxSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep GearBox");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep GearBox");
    }
}

on envVar Env_Stress_OutsideAirtemp_SweepActiv
{
    Stress_OutsideAirtemp_WriteSink();
    Stress_OutsideAirtemp_CheckActiv();
}

on envVar Env_Stress_OutsideAirtemp_TimeInterval
{
    Stress_OutsideAirtemp_CheckActiv();
}

on timer _t_Stress_ChangeOutTemp
{
    if( Stress_OutsideAirtemp_CheckActiv())
    {
        Stress_OutsideAirtemp_CalcNext();
    }
}

int Stress_OutsideAirtemp_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeOutTemp);
    iTemp = getvalue( Env_Stress_OutsideAirtemp_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
//    write("OutTempActiv = %d und _StresstestMainActiv = %d, verUNDed = %d",getvalue(OutTempSweepActiv), getvalue(_StresstestMainActiv), iTemp);
    if( iTemp)
    {
        settimer(_t_Stress_ChangeOutTemp, getvalue( Env_Stress_OutsideAirtemp_TimeInterval ));
    }

    return(iTemp);
}

Stress_OutsideAirtemp_CalcNext()
{
    fCurrentValue = getvalue( Env_Stress_OutsideAirtemp_CurrentVal ); // aditional changeable parameter
    iDirectionOutTemp = Stress__CalcNext_PointerVal_float( getvalue( Env_Stress_OutsideAirtemp_StepWidth ), iDirectionOutTemp, getvalue( Env_Stress_OutsideAirtemp_Min ), getvalue( Env_Stress_OutsideAirtemp_Max ));
//    putvalue( Env_Stress_OutsideAirtemp_CurrentVal, fCurrentValue );
//    putvalue( Env_Outside_Air_Temp_Stat, fCurrentValue );
}

Stress_OutsideAirtemp_IniRead (char iniFilename[])
{
    strncpy(func, "OutsideAirtemp", 20 );    // Name of functionality

/*    putvalue( Env_Stress_OutsideAirtemp_SweepActiv,   getProfileInt(   func, "OutTempSweepActiv",   defOutTempSweepActiv,   iniFilename ));
    putvalue( Env_Stress_OutsideAirtemp_Min,          getProfileFloat( func, "OutTempMin",          defOutTempMin,          iniFilename ));
    putvalue( Env_Stress_OutsideAirtemp_Max,          getProfileFloat( func, "OutTempMax",          defOutTempMax,          iniFilename ));
    putvalue( Env_Stress_OutsideAirtemp_StepWidth,    getProfileFloat( func, "OutTempStepWidth",    defOutTempStepWidth,    iniFilename ));
    putvalue( Env_Stress_OutsideAirtemp_TimeInterval, getProfileInt(   func, "OutTempTimeInterval", defOutTempTimeInterval, iniFilename ));
*/}

Stress_OutsideAirtemp_IniWrite (char iniFilename[])
{
    strncpy(func, "OutsideAirtemp", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt(   func, "OutTempSweepActiv",   getValue( Env_Stress_OutsideAirtemp_SweepActiv ),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "OutTempMin",          getValue( Env_Stress_OutsideAirtemp_Min ),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "OutTempMax",          getValue( Env_Stress_OutsideAirtemp_Max ),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "OutTempStepWidth",    getValue( Env_Stress_OutsideAirtemp_StepWidth ),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt(   func, "OutTempTimeInterval", getValue( Env_Stress_OutsideAirtemp_TimeInterval ), iniFilename );
*/}

Stress_OutsideAirtemp_WriteSink()
{
    if( getvalue( Env_Stress_OutsideAirtemp_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep OutsideAirtemp");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep OutsideAirtemp");
    }
}

on envVar Env_Stress_ParkingSweepActiv
{
    Stress_Parking_WriteSink();
    Stress_Parking_CheckActiv();
}

on envVar Env_Stress_ParkingTimeInterval
{
    Stress_Parking_CheckActiv();
}

on timer _t_Stress_ChangeParking
{
    if( Stress_Parking_CheckActiv())
    {
        Stress_Parking_CalcNext();
    }
}

int Stress_Parking_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeParking);
    iTemp = getvalue( Env_Stress_ParkingSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
    if( iTemp)
    {
        settimer(_t_Stress_ChangeParking, getvalue( Env_Stress_ParkingTimeInterval ));
    }

    return(iTemp);
}

Stress_Parking_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_ParkingCurrentVal ); // aditional changeable parameter
    iDirectionParking = Stress__CalcNext_PointerVal(getvalue( Env_Stress_ParkingStepWidth ), iDirectionParking, getvalue(Env_Stress_ParkingMin ), getvalue(Env_Stress_ParkingMax ));
    putvalue( Env_Stress_ParkingCurrentVal, lCurrentVal );
//    putvalue( pDemo_ParkLeft, lCurrentVal );

    // inverted behaviour of ParkLeft and ParkRight 
//    lTemp = getvalue(Env_Stress_ParkingMax ) - lCurrentVal;
//    putvalue( pDemo_ParkRight, lTemp );
}

Stress_Parking_IniRead (char iniFilename[])
{
    strncpy(func, "Parking", 20 );    // Name of functionality

/*    putvalue( Env_Stress_ParkingSweepActiv,   getProfileInt( func, "ParkingSweepActiv",   defParkingSweepActiv,   iniFilename));
    putvalue( Env_Stress_ParkingMin,          getProfileInt( func, "ParkingMin",          defParkingMin,          iniFilename));
    putvalue( Env_Stress_ParkingMax,          getProfileInt( func, "ParkingMax",          defParkingMax,          iniFilename));
    putvalue( Env_Stress_ParkingStepWidth,    getProfileInt( func, "ParkingStepWidth",    defParkingStepWidth,    iniFilename));
    putvalue( Env_Stress_ParkingTimeInterval, getProfileInt( func, "ParkingTimeInterval", defParkingTimeInterval, iniFilename));
*/}

Stress_Parking_IniWrite (char iniFilename[])
{
    strncpy(func, "Parking", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "ParkingSweepActiv",   getValue( Env_Stress_ParkingSweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "ParkingMin",          getValue( Env_Stress_ParkingMin),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "ParkingMax",          getValue( Env_Stress_ParkingMax),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "ParkingStepWidth",    getValue( Env_Stress_ParkingStepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "ParkingTimeInterval", getValue( Env_Stress_ParkingTimeInterval), iniFilename );
*/}

Stress_Parking_WriteSink()
{
    if( getvalue( Env_Stress_ParkingSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep Parking");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep Parking");
    }
}

on envVar Env_Stress_RevSweepActiv
{
    Stress_Revolution_WriteSink();
    if( Stress_Revolution_CheckActiv() )    putvalue(Env_EngAout_N_Actl_Fehler, 0 ); // always take stresstest revolution values
}

on envVar Env_Stress_RevTimeInterval
{
    Stress_Revolution_CheckActiv();
}

on timer _t_Stress_ChangeRev
{
    if( Stress_Revolution_CheckActiv())
    {
        Stress_Revolution_CalcNext();
    }
}

Stress_Revolution_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_RevCurrentVal ); // aditional changeable parameter
    iDirectionRev = Stress__CalcNext_PointerVal(getvalue( Env_Stress_RevStepWidth ), iDirectionRev, getvalue( Env_Stress_RevMin ), getvalue( Env_Stress_RevMax ));
//    putvalue( Env_Stress_RevCurrentVal, lCurrentVal );
//    putValue( Env_EngAout_N_Actl, lCurrentVal );
}

int Stress_Revolution_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeRev);
    iTemp = getvalue( Env_Stress_RevSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
//    write("RevActiv = %d und _StresstestMainActiv = %d, verUNDed = %d",getvalue(RevSweepActiv), getvalue(_StresstestMainActiv), iTemp);
    if( iTemp)
    {
        settimer(_t_Stress_ChangeRev, getvalue(Env_Stress_RevTimeInterval ));
    }

    return(iTemp);
}

Stress_Revolution_IniRead (char iniFilename[])
{
    strncpy(func, "Revolution", 20 );    // Name of functionality

/*    putvalue( Env_Stress_RevSweepActiv,   getProfileInt( func, "RevSweepActiv",   defRevSweepActiv,   iniFilename));
    putvalue( Env_Stress_RevMin,          getProfileInt( func, "RevMin",          defRevMin,          iniFilename));
    putvalue( Env_Stress_RevMax,          getProfileInt( func, "RevMax",          defRevMax,          iniFilename));
    putvalue( Env_Stress_RevStepWidth,    getProfileInt( func, "RevStepWidth",    defRevStepWidth,    iniFilename));
    putvalue( Env_Stress_RevTimeInterval, getProfileInt( func, "RevTimeInterval", defRevTimeInterval, iniFilename));
*/}

Stress_Revolution_IniWrite (char iniFilename[])
{
    strncpy(func, "Revolution", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "RevSweepActiv",   getValue( Env_Stress_RevSweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "RevMin",          getValue( Env_Stress_RevMin),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "RevMax",          getValue( Env_Stress_RevMax),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "RevStepWidth",    getValue( Env_Stress_RevStepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "RevTimeInterval", getValue( Env_Stress_RevTimeInterval), iniFilename );
*/}

Stress_Revolution_WriteSink()
{
    if( getvalue( Env_Stress_RevSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep Revolution");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep Revolution");
    }
}

on envVar Env_Stress_SegBeginSweepActiv
{
    Stress_SegBegin_WriteSink();
    Stress_SegBegin_CheckActiv();
}

on envVar Env_Stress_SegBeginTimeInterval
{
    Stress_SegBegin_CheckActiv();
}

on timer _t_Stress_ChangeSegBegin
{
    if( Stress_SegBegin_CheckActiv())
    {
        Stress_SegBegin_CalcNext();
    }
}

Stress_SegBegin_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_SegBeginCurrentVal ); // aditional changeable parameter
    iDirectionSegBegin = Stress__CalcNext_PointerVal(getvalue( Env_Stress_SegBeginStepWidth ), iDirectionSegBegin, getvalue(Env_Stress_SegBeginMin ), getvalue(Env_Stress_SegBeginMax ));
//    putvalue( Env_Stress_SegBeginCurrentVal, lCurrentVal );
 //   putvalue( pDemo_DistronicBegin, lCurrentVal );
}

int Stress_SegBegin_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeSegBegin);
    iTemp = getvalue( Env_Stress_SegBeginSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
    if( iTemp)
    {
        settimer(_t_Stress_ChangeSegBegin, getvalue( Env_Stress_SegBeginTimeInterval ));
    }

    return(iTemp);
}

Stress_SegBegin_IniRead (char iniFilename[])
{
    strncpy(func, "SegBegin", 20 );    // Name of functionality

/*    putvalue( Env_Stress_SegBeginSweepActiv,   getProfileInt( func, "SegBeginSweepActiv",   defSegBeginSweepActiv,   iniFilename));
    putvalue( Env_Stress_SegBeginMin,          getProfileInt( func, "SegBeginMin",          defSegBeginMin,          iniFilename));
    putvalue( Env_Stress_SegBeginMax,          getProfileInt( func, "SegBeginMax",          defSegBeginMax,          iniFilename));
    putvalue( Env_Stress_SegBeginStepWidth,    getProfileInt( func, "SegBeginStepWidth",    defSegBeginStepWidth,    iniFilename));
    putvalue( Env_Stress_SegBeginTimeInterval, getProfileInt( func, "SegBeginTimeInterval", defSegBeginTimeInterval, iniFilename));
*/}

Stress_SegBegin_IniWrite (char iniFilename[])
{
    strncpy(func, "SegBegin", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegBeginSweepActiv",   getValue( Env_Stress_SegBeginSweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegBeginMin",          getValue( Env_Stress_SegBeginMin),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegBeginMax",          getValue( Env_Stress_SegBeginMax),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegBeginStepWidth",    getValue( Env_Stress_SegBeginStepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegBeginTimeInterval", getValue( Env_Stress_SegBeginTimeInterval), iniFilename );
*/}

Stress_SegBegin_WriteSink()
{
    if( getvalue( Env_Stress_SegBeginSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep SegmentringBegin");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep SegmentringBegin");
    }
}

on envVar Env_Stress_SegEndSweepActiv
{
    Stress_SegEnd_WriteSink();
    Stress_SegEnd_CheckActiv();
}

on envVar Env_Stress_SegEndTimeInterval
{
    Stress_SegEnd_CheckActiv();
}

on timer _t_Stress_ChangeSegEnd
{
    if( Stress_SegEnd_CheckActiv())
    {
        Stress_SegEnd_CalcNext();
    }
}

Stress_SegEnd_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_SegEndCurrentVal ); // aditional changeable parameter
    iDirectionSegEnd = Stress__CalcNext_PointerVal(getvalue( Env_Stress_SegEndStepWidth ), iDirectionSegEnd, getvalue(Env_Stress_SegEndMin ), getvalue(Env_Stress_SegEndMax ));
//    putvalue( Env_Stress_SegEndCurrentVal, lCurrentVal );
 //   putvalue( pDemo_DistronicEnd, lCurrentVal );
}

int Stress_SegEnd_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeSegEnd);
    iTemp = getvalue( Env_Stress_SegEndSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
    if( iTemp)
    {
        settimer(_t_Stress_ChangeSegEnd, getvalue( Env_Stress_SegEndTimeInterval ));
    }

    return(iTemp);
}

Stress_SegEnd_IniRead (char iniFilename[])
{
    strncpy(func, "SegEnd", 20 );    // Name of functionality

/*    putvalue( Env_Stress_SegEndSweepActiv,   getProfileInt( func, "SegEndSweepActiv",   defSegEndSweepActiv,   iniFilename));
    putvalue( Env_Stress_SegEndMin,          getProfileInt( func, "SegEndMin",          defSegEndMin,          iniFilename));
    putvalue( Env_Stress_SegEndMax,          getProfileInt( func, "SegEndMax",          defSegEndMax,          iniFilename));
    putvalue( Env_Stress_SegEndStepWidth,    getProfileInt( func, "SegEndStepWidth",    defSegEndStepWidth,    iniFilename));
    putvalue( Env_Stress_SegEndTimeInterval, getProfileInt( func, "SegEndTimeInterval", defSegEndTimeInterval, iniFilename));
*/}

Stress_SegEnd_IniWrite (char iniFilename[])
{
    strncpy(func, "SegEnd", 20 );    // Name of functionality
/*
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegEndSweepActiv",   getValue( Env_Stress_SegEndSweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegEndMin",          getValue( Env_Stress_SegEndMin),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegEndMax",          getValue( Env_Stress_SegEndMax),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegEndStepWidth",    getValue( Env_Stress_SegEndStepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "SegEndTimeInterval", getValue( Env_Stress_SegEndTimeInterval), iniFilename );
*/}

Stress_SegEnd_WriteSink()
{
    if( getvalue( Env_Stress_SegEndSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep SegmentringEnd");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep SegmentringEnd");
    }
}

on envVar Env_Stress_SpeedSweepActiv
{
    Stress_Speed_WriteSink();
    Stress_Speed_CheckActiv();
}

on envVar Env_Stress_SpeedTimeInterval
{
    Stress_Speed_CheckActiv();
}

on timer _t_Stress_ChangeSpeed
{
    if( Stress_Speed_CheckActiv())
    {
        Stress_Speed_CalcNext();
    }
}

Stress_Speed_CalcNext()
{
    fCurrentValue = getvalue( Env_Stress_SpeedCurrentVal ); // aditional changeable parameter
    iDirectionSpeed = Stress__CalcNext_PointerVal_float(getvalue( Env_Stress_SpeedStepWidth ), iDirectionSpeed, getvalue( Env_Stress_SpeedMin ), getvalue(Env_Stress_SpeedMax ));
//    putvalue( Env_Stress_SpeedCurrentVal, fCurrentValue );
//    putValue( Env_Veh_V_ActlEng, fCurrentValue );
//    if( getValue( Env_Veh_V_ODO_coupled ) )
//        putValue( Env_Veh_V_ODO, fCurrentValue );
}

int Stress_Speed_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeSpeed);
    iTemp = getvalue( Env_Stress_SpeedSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
    if( iTemp)
    {
        settimer(_t_Stress_ChangeSpeed, getvalue( Env_Stress_SpeedTimeInterval ));
    }

    return(iTemp);
}

Stress_Speed_IniRead (char iniFilename[])
{
    strncpy(func, "Speedometer", 20 );    // Name of functionality

/*    putvalue( Env_Stress_SpeedSweepActiv,   getProfileInt(   func, "SpeedSweepActiv",   defSpeedSweepActiv,   iniFilename));
    putvalue( Env_Stress_SpeedMin,          getProfileFloat( func, "SpeedMin",          defSpeedMin,          iniFilename));
    putvalue( Env_Stress_SpeedMax,          getProfileFloat( func, "SpeedMax",          defSpeedMax,          iniFilename));
    putvalue( Env_Stress_SpeedStepWidth,    getProfileFloat( func, "SpeedStepWidth",    defSpeedStepWidth,    iniFilename));
    putvalue( Env_Stress_SpeedTimeInterval, getProfileInt(   func, "SpeedTimeInterval", defSpeedTimeInterval, iniFilename));
*/}

Stress_Speed_IniWrite (char iniFilename[])
{
    strncpy(func, "Speedometer", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt(   func, "SpeedSweepActiv",   getValue( Env_Stress_SpeedSweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "SpeedMin",          getValue( Env_Stress_SpeedMin),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "SpeedMax",          getValue( Env_Stress_SpeedMax),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileFloat( func, "SpeedStepWidth",    getValue( Env_Stress_SpeedStepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt(   func, "SpeedTimeInterval", getValue( Env_Stress_SpeedTimeInterval), iniFilename );
*/}

Stress_Speed_WriteSink()
{
    if( getvalue( Env_Stress_SpeedSweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep Speed");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep Speed");
    }
}

on envVar Env_Stress_Tank_SweepActiv
{
    Stress_Tank_WriteSink();
    Stress_Tank_CheckActiv();
}

on envVar Env_Stress_Tank_TimeInterval
{
    Stress_Tank_CheckActiv();
}

on timer _t_Stress_ChangeTank
{
    if( Stress_Tank_CheckActiv())
    {
        Stress_Tank_CalcNext();
    }
}

Stress_Tank_CalcNext()
{
    lCurrentVal = getvalue( Env_Stress_Tank_CurrentVal ); // aditional changeable parameter
    iDirectionTank = Stress__CalcNext_PointerVal(getvalue( Env_Stress_Tank_StepWidth ), iDirectionTank, getvalue(Env_Stress_Tank_Min ), getvalue(Env_Stress_Tank_Max ));
//    putvalue( Env_Stress_Tank_CurrentVal, lCurrentVal );
//    putvalue( Env_FuelLvl_Pc_DsplyEng, lCurrentVal );
}

int Stress_Tank_CheckActiv()
{
    int iTemp;

    canceltimer(_t_Stress_ChangeTank);
    iTemp = getvalue( Env_Stress_Tank_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv );
    if( iTemp)
    {
        settimer(_t_Stress_ChangeTank, getvalue( Env_Stress_Tank_TimeInterval ));
    }

    return(iTemp);
}

Stress_Tank_IniRead (char iniFilename[])
{
    strncpy(func, "Tank", 20 );    // Name of functionality

/*    putvalue( Env_Stress_Tank_SweepActiv,   getProfileInt( func, "TankSweepActiv",   defTankSweepActiv,   iniFilename));
    putvalue( Env_Stress_Tank_Min,          getProfileInt( func, "TankMin",          defTankMin,          iniFilename));
    putvalue( Env_Stress_Tank_Max,          getProfileInt( func, "TankMax",          defTankMax,          iniFilename));
    putvalue( Env_Stress_Tank_StepWidth,    getProfileInt( func, "TankStepWidth",    defTankStepWidth,    iniFilename));
    putvalue( Env_Stress_Tank_TimeInterval, getProfileInt( func, "TankTimeInterval", defTankTimeInterval, iniFilename));
*/}

Stress_Tank_IniWrite (char iniFilename[])
{
    strncpy(func, "Tank", 20 );    // Name of functionality

/*    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "TankSweepActiv",   getValue( Env_Stress_Tank_SweepActiv),   iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "TankMin",          getValue( Env_Stress_Tank_Min),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "TankMax",          getValue( Env_Stress_Tank_Max),          iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "TankStepWidth",    getValue( Env_Stress_Tank_StepWidth),    iniFilename );
    if( lWriteError != 0)    lWriteError = writeProfileInt( func, "TankTimeInterval", getValue( Env_Stress_Tank_TimeInterval), iniFilename );
*/}

Stress_Tank_WriteSink()
{
    if( getvalue( Env_Stress_Tank_SweepActiv ) && getvalue( Env_Stress__StresstestMainActiv ))
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Activ   Sweep Tank");
    }
    else
    {
        writeLineEx(dwWriteSinkSimu, dwWriteSeverityInfo, "  Inactiv Sweep Tank");
    }
}

int Stress__CalcNext_PointerVal_float (float fStepWidth,    int iDirection,    float fMinVal,    float fMaxVal)
{
    // additional (global) function changeable parameter is: lCurrentVal
    // returning new direction

    if( ((fCurrentValue >= fMaxVal) && (iDirection == 1)) || ((fCurrentValue <= fMinVal) && (iDirection == -1)))
    {
        iDirection *= -1;
    }

    fCurrentValue += (iDirection * fStepWidth);

    if( fCurrentValue >= fMaxVal)
    {
        fCurrentValue = fMaxVal;
    }

    if( fCurrentValue <= fMinVal)
    {
        fCurrentValue = fMinVal;
    }

    return(iDirection);
}

on timer t_Auto_Project_SelectorTimer
{
//    putValue( DIAG_CTRL_IC_Type_Selector, 1 ); 
//    putValue( DIAG_CTRL_IC_Variant_Selector, 0);
}

