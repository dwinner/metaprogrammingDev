/*@!Encoding:1252*/
/********************************************************************************/ 
/*  Author:      Jonas Eduard Pagel                                             */ 
/*  Department:  IAV, VC-F-23                                                   */ 
/*  Email (IAV): jonas.eduard.pagel@IAV.de                                      */
/*  Email (VW):  extern.jonas.eduard.pagel@Volkswagen.de                        */
/*  Phone:       +49-5371-805-2920                                              */ 
/*  Mobil:       +49 152 57952588                                               */ 
/*                                                                              */ 
/*  Substitute:  Christian Franz                                                */ 
/*  Department:  VW, EECF/1                                                     */ 
/*  Phone:       +49-5361-9-42880                                               */ 
/*                                                                              */ 
/*  Purpose:     CANoe simulation for stand alone Navigation secondary Display	*/ 
/********************************************************************************/ 


/* Global variables for the AudioSD CANoe BAP simulation */
variables
{
    const REQUESTBUFFER_LINES    =100;
    const BAP_BUFFER_SIZE        =4000;

    char dbc_path[255]  = "DBs\\BAP_only_MQB_MLBevo_v1.19.dbc";    		//relative path for dbc-file											
    //char xml_path[255]  = "XML\\BAP_SW17_KI_FPK_MQB_v1_71_F_mod.xml";   //relative path for xml-file
    char xml_path[255]  = "XML\\BAP_SW18_KI_Medium_Colour_MQB_v2_00_F_mod.xml";   //relative path for xml-file

    int gBAP_Requestbuffer_status [REQUESTBUFFER_LINES];				//datalength
    int gBAP_Requestbuffer_BAPDataTyp [REQUESTBUFFER_LINES];			//data type

    dword gBAP_Indication[BAP_BUFFER_SIZE];								//Bap-Indication-buffer
    dword gBAP_Request [REQUESTBUFFER_LINES] [BAP_BUFFER_SIZE];			//ringbuffer for BAP-Request

    int gwrite_requestbuffer_line   =0;									//next free position
    int gstatus_requestbuffer       =0;                                 //next position to send
									
    // adresses of output Windows
    dword gBAP_Trace, gError_Trace;

    //Timers
    mstimer TaskTimer;													//timer for BAP-Task
    mstimer Powerontimer; 
    mstimer ASGCapa_startTimer;   
    const gBAP_datalength_error =0x41;

    // general values for readable code
  	const FALSE             =0;
  	const TRUE              =1;
  	const NULL              =0x00;
    const VALID             =0x01;
    const INVALID           =0x00;
    const FORWARD           =0;
    const BACKWARD          =1;
    char empty_string [3]   ={0,0,0};
    
    char gstring_reserved [10]      ="reserved";
    char gstring_defect [10]        ="defect";
    char gstring_not_supported [20] ="not supported";
    char gstring_unknown [20]       ="unknown";
    
    //BAP Data Type 
    const Bap_Void			    =0;
    const Bap_UInt8			    =1;
    const Bap_UInt16		    =2;
    const Bap_UInt32		    =3;
    const Bap_ByteSequence	    =4;
    const Bap_Error			    =5;
    const Bap_Acknowledge       =6;

    //BAP request types (ASG)
    const DataSetGet_REQ	=0x00;
    const DataSet_REQ		=0x01;
    const DataGet_REQ		=0x02;
    const Start_REQ			=0x05;
    const StartResult_REQ	=0x06;
    const AbortResult_REQ	=0x07;
    const Ack_REQ           =0x0B;    
    const Invalid_REQ    	=0x1F;  // Interne Kennzeichnung fuer einen ungueltigen Request

    //eigene Error-Definition
    const Error_REQ=0x55;


    //BAP indication types (ASG)
    const Data_IND			=0x00;
    const Reset_IND         =0x01;
    const DataAck_IND       =0x02;
    const Result_IND		=0x03;
    const Processing_IND	=0x04;  
    const Changed_IND		=0x05;
    const Invalid_IND		=0x1F;  // Interne Kennzeichnung fuer eine ungueltige Indication

    //eigene Error-Definition
    const Error_IND =0x55;

	// node index and LSG-IDs
    dword NODE_INDEX;

    const LSG_AudioSD	=0x31;

    // BAP and LSG-Version information (these are not used, just informations; see XML-file for current definitions!)
	const BAP_VERSION_MAJOR =0x03;
	const BAP_VERSION_MINOR =0x00;
	const LSG_CLASS_1       =LSG_AudioSD;
	const LSG_SUBCLASS_1    =0x00;
	const LSG_VERSION_MAJOR =0x04;
	const LSG_VERSION_MINOR =0x08;

    // BAP and BAL error codes
	const BAP_NO_ERROR               =0x00;

	const BAP_BAL_OUT_OF_RANGE       =0x41;
	const BAP_BAL_TEMP_NOT_AVAILABLE =0x42;
	const BAP_BAL_MAX_DL_EXCEEDED    =0x43;
	const BAP_BAL_UNIT_MISMATCH      =0x44;

	// Error codes from BAP API (refer to BAP manual)
	const BAP_ERR_OK = 0x00;

    char gerror_codes_BCL [16][30] = {  0,
									"Media not accesible",
									"illegal sequence",
									"Sequenzfehler Segmentierung",
									"Timeout Segmentierung",
									"BCL not running",
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0};

    char gerror_codes_BPL [16][30] = {  0,
									"Heartbeat Timeout",
									"Retry Timeout",
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0};

    char gerror_codes_BAL [16][40] = {  0,
									"Falsche Adressierung",
									"Inkompatible Protokollversion",
									"Inkompatible Version Datenfestlegung",
									"Daten ungültig",
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0};

    char gerror_codes_0x40_0x7F [17][40] = {"reserved",
										"Apll-out of range",
										"Appl-temporary not available",
										"Appl-max data length exceeded",
										"Appl - unit mismatch",
										"Appl - parameter mismatch",
										"Appl - invalid argument",
										"Appl - FailedToCreateNewListMember",
										"reserved",
										"reserved",
										"reserved",
										"reserved",
										"reserved",
										"reserved",
										"reserved",
										"reserved",
										"Appl-method aborted"};

    byte FunctionList_flag  =FALSE;


    // Function-IDs
    
    //common function-IDs
    const FctID_GetAll				=0x01;
    const FctID_BAP_Config			=0x02;
    const FctID_FunctionList		=0x03;
    const FctID_HeartBeat			=0x04;
    const FctID_FSG_Setup			=0x0E;
    const FctID_FSG_OperationState	=0x0F;

    // specific function-IDs
    const FctID_ActiveSource			=0x10;
    const FctID_ActiveSourceName		=0x11;
    const FctID_CurrentVolume			=0x12;
    const FctID_Mute					=0x13;
    const FctID_SourceState				=0x14;
    const FctID_CurrentStationInfo		=0x15;
    const FctID_CurrentStation_Handle   =0x16;
    const FctID_ReceptionList			=0x17;
    const FctID_DedicatedAudioControl	=0x18;
    const FctID_GeneralInfoSwitches		=0x19;
    const FctID_TPMemoInfo				=0x1A;
    const FctID_TPMemoList				=0x1B;
    const FctID_AnnouncementInfo    	=0x1C;
    const FctID_AnnouncementEscape  	=0x1D;
    const FctID_InfoStates				=0x1E;
    const FctID_ReceptionListType		=0x1F;
    const FctID_SourceList				=0x20;
    const FctID_RadioTV_PresetList      =0x21;
    const FctID_SwitchSource			=0x22;
    const FctID_MediaBrowser_FolderLevel=0x23;
    const FctID_MediaBrowser            =0x24;
    const FctID_MediaPath               =0x25;    
    const FctID_MediaBrowserControl     =0x26;
    const FctID_MediaFileInfo           =0x27;
    const FctID_PreferredList           =0x28;
    const FctID_SDS_State               =0x29;
    const FctID_FunctionSynchronisation =0x2A;
    const FctID_ASG_Capabilities        =0x2B;
    const FctID_GetNextListPos          =0x2C;
    const FctID_SwitchRadioMedia        =0x2D;
    const FctID_MediaImportState        =0x2E;
    const FctID_CurrentVolumeExtended   =0x2F;
    const FctID_CustomerDownloadState   =0x30;
    const FctID_OnlineMusic_State       =0x31;
    const FctID_CommonList              =0x32;
    const FctID_SiriusAlertList         =0x32;
    const FctID_CurrentStation_Handle2  =0x33;
    const FctID_PlayPosition            =0x34;
    const FctID_SDS_RecognizerState     =0x35;
    const FctID_CurrentStationInfo2     =0x36;
    const FctID_CurrentStation_Handle3  =0x37;
    const FctID_LastStationList         =0x38;
    const FctID_SiriusAlertInfo         =0x39;
    const FctID_Picture                 =0x3A;
    const FctID_FavoriteList            =0x3B;
    const FctID_Station_Track_Switch    =0x3C;
    
         
    // ASG specific global variables and consts.

    /***FSG-Setup***/
    byte gAudioSD_FSGSetup_maxVolume            =0;
    
    byte gAudioSD_FSGSetup_supportedVolumeTypes =0;
    byte gAudioSD_FSGSetup_entertainmentVolume  =FALSE;
    byte gAudioSD_FSGSetup_navigationVolume     =FALSE;
    byte gAudioSD_FSGSetup_announcementVolume   =FALSE;
    byte gAudioSD_FSGSetup_phoneVolume          =FALSE;
    byte gAudioSD_FSGSetup_SDSVolume            =FALSE;
    byte gAudioSD_FSGSetup_phoneRingingVolume   =FALSE;
    byte gAudioSD_FSGSetup_carParkingFader      =FALSE;
    byte gAudioSD_FSGSetup_readMessageVolume    =FALSE;
    char gAudioSD_FSGSetup_supportedVolumeTypes_string[2][15] ={"not available",
                                                                "available"};
    
    byte gAudioSD_FSGSetup_ReceptionList_AutoUpdate =0;
    byte gAudioSD_FSGSetup_FMReceptionList      =FALSE;
    byte gAudioSD_FSGSetup_AMReceptionList      =FALSE;
    byte gAudioSD_FSGSetup_DABReceptionList     =FALSE;
    byte gAudioSD_FSGSetup_SDARSReceptionList   =FALSE;
    byte gAudioSD_FSGSetup_AMLWReceptionList    =FALSE;
    byte gAudioSD_FSGSetup_AMSWReceptionList    =FALSE;
    byte gAudioSD_FSGSetup_TVDVBReceptionList   =FALSE;
    byte gAudioSD_FSGSetup_ORReceptionList      =FALSE;
    char gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[2][30] = {"not automatically updated",
                                                                     "automatically updated"};
    
    byte gAudioSD_FSGSetup_Setup_Extensions     =0;                                                                
    byte gAudioSD_FSGSetup_Setup_Extensions_DAB =FALSE;
    char gAudioSD_FSGSetup_Setup_Extensions_DAB_string[2][30] = {"DAB ensemble sorted list",
                                                                 "DAB service sorted list"};
    byte gAudioSD_FSGSetup_Setup_Extensions_CL =FALSE;
    char gAudioSD_FSGSetup_Setup_Extensions_CL_string[2][30] = {"common list not automatically",
                                                                 "common list automatically"};
    byte gAudioSD_FSGSetup_Setup_Extensions_CA =FALSE;
    char gAudioSD_FSGSetup_Setup_Extensions_CA_string[2][30] = {"CoverArt not available",
                                                                 "CoverArt available"};
    byte gAudioSD_FSGSetup_Setup_Extensions_SA =FALSE;
    char gAudioSD_FSGSetup_Setup_Extensions_SA_string[2][30] = {"StationArt not available",
                                                                 "StationArt available"};
    byte gAudioSD_FSGSetup_Setup_Extensions_Su =FALSE;
    char gAudioSD_FSGSetup_Setup_Extensions_Su_string[2][30] = {"StationArt only for presets",
                                                                 "StationArt always supp."};
    
    /*** FSG-OperationState***/    
    const FSGOPERATIONSTATE_NORMALOPERATION =0x00;
    const FSGOPERATIONSTATE_OFF             =0x01;
    const FSGOPERATIONSTATE_INITIALIZING    =0x03;
    const FSGOPERATIONSTATE_DEFECT          =0x0F;

    byte gAudioSD_FSG_OperationState_OpState =FSGOPERATIONSTATE_OFF;
    
    char gAudioSD_FSG_OperationState_OpState_string [4] [30] = { "normal operation",
												            "Off/standby",
                                                            "reserved",
												            "initializing"};

    const NO_ANIMATION_RUNNING_ON_FSG       =0x00;
    const WELCOME_ANIMATION_RUNNING_ON_FSG  =0x01;

    byte gAudioSD_FSG_OperationState_HMI_State =NO_ANIMATION_RUNNING_ON_FSG;
    
    char gAudioSD_FSG_OperationState_HMI_State_string[2][35] ={ "no animation running on FSG",
                                                                "'welcome' animation running on FSG"};

    /***FunctionList***/
    byte gFunctionList_FctList[8];

    /***activeSource***/
    const ACTIVESOURCE_UNKNOWNSOURCE =0xFF;

    byte gAudioSD_activeSource_SourceType =0;
    
    char gAudioSD_activeSource_SourceType_string[46][50] = {"no source active",
                      											                "FM",
                      											                "AM",
                      											                "DAB",
                      											                "SDARS-XM",
                      											                "SDARS-Sirius",
                      											                "CD",
                      											                "CD changer",
                      											                "DVD",
                      											                "TV",
                      											                "HDD",
                      											                "SD",
                      											                "TP-Memo/TIM",
                      											                "Aux-in Audio",
                      											                "Aux-In Video",
                      											                "portable device (MDI, AMI)",
                      											                "generic player",
                      											                "AM-TI",
                      											                "DVD changer",
                                                            "USB",
                                                            "Jukebox",
                                                            "Bluetooth connection - BT stream",
                                                            "Bluetooth connection - remote control protocol",
                                                            "DVB - video service",
                                                            "DVB - audio service",
                                                            "AM-SW (Kurzwelle)",
                                                            "AM-LW (Langwelle)",
                                                            "WLAN connection - mass storage",
                                                            "WLAN connection - RCP (Remote Control Player)",
                                                            "BlueRay",
                                                            "BlueRay changer",
                                                            "Flash (flash memory)", 
                                                            "Aux-in Video (TV)",
                                                            "HDMI (DF4.1)",
                                                            "online mass storage(DF4.1)",
                                                            "online radio (DF4.1)",
                                                            "commonList(DF4.2)",
                                                            "mobileDevice (apple)(DF4.2)",
                                                            "mobileDevice (mirror)(DF4.2)",
                                                            "mobileDevice (google)(DF4.2)",
                                                            "mobileDevice (baidu)(DF4.4)",
                                                            "RSE",
                                                            "DMB",
                                                            "online music streaming",
                                                            "online TV",
                                                            "online video"};
    
    char gAudioSD_activeSource_SourceType_unknown_s[20] = "unknown source";
    
    word gAudioSD_audioSource_SourceList_Reference  =0;
    
    const ACTIVESOURCE_INVALIDNUMBER =0xF;

    byte gAudioSD_audioSource_TypeOfNumber          =0;
    char gAudioSD_audioSource_TypeOfNumber_string[6][30] ={     "any meaning",
                                                                "preset bank ID",
                                                                "preset ID",
                                                                "auto store bank ID",
                                                                "auto store ID",
                                                                "CD/DVD/BlueRay-ID"};
    
    char gAudioSD_activeSource_SourceType_InvalidNumber_s[20] = "Invalid 'number'";
    
    byte gAudioSD_audioSource_ListAvailable         =0;
    byte gAudioSD_audioSource_ReceptionList         =0;
    byte gAudioSD_audioSource_PresetList            =0;
    byte gAudioSD_audioSource_MediaBrowserList      =0;
    byte gAudioSD_audioSource_SiriusAlertList      =0;
    char gAudioSD_audioSource_ListAvailable_string[2][15]  ={   "not available",
                                                                "available"};
    
    byte gAudioSD_audioSource_ListAvailable2        =0;
    byte gAudioSD_audioSource_LastStationList       =0;
    byte gAudioSD_audioSource_FavoriteList          =0;
    char gAudioSD_audioSource_ListAvailable2_string[2][15]  ={   "not available",
                                                                "available"};

    byte gAudioSD_audioSource_ListState             =0;
    
    char gAudioSD_audioSource_ListState_string[5][30] ={"unknown list state",
                                                        "list is being loaded",
                                                        "list is incompletely loaded",
                                                        "list completely loaded",
                                                        "list is being updated"};

    byte gAudioSD_audioSource_Reserve               =0;
    byte gAudioSD_audioSource_Number                =0;

    /***activeSourceName***/
    const ACTIVE_SOURCE_NAME_LENGTH =61;
    char gAudioSD_activeSourceName [ACTIVE_SOURCE_NAME_LENGTH];

    /***currentVolume***/
    byte gAudioSD_currentVolume_EntertainmentVolume =0;
    byte gAudioSD_currentVolume_NavigationVolume    =0;
    byte gAudioSD_currentVolume_TaVolume            =0;
    byte gAudioSD_currentVolume_PhoneVolume         =0;
    byte gAudioSD_currentVolume_SDSVolume           =0;
    byte gAudioSD_currentVolume_ChangingVolumeType  =0;
    
    char gAudioSD_currentVolume_ChangingVolumeType_string [17][40]  ={  "no volume is changed",
                                                                        "entertainment volume is being changed",
                                                                        "navigation volume is being changed",
                                                                        "reserved",
                                                                        "TA volume is being changed",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "phone volume is being changed",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "reserved",
                                                                        "SDS volume is being changed"}; 
    
    /***Mute***/
    byte gAudioSD_Mute_MuteState        =0;
    byte gAudioSD_Mute_Entertainment    =0;
    byte gAudioSD_Mute_DAB              =0;
    byte gAudioSD_Mute_DVB              =0;
    byte gAudioSD_Mute_SDARS            =0;
    byte gAudioSD_Mute_IBOC             =0;
    byte gAudioSD_Mute_sync_IBOC        =0;
    byte gAudioSD_Mute_Phone            =0;
    byte gAudioSD_Mute_OnlineRadio      =0;

    /***SourceState***/
    byte gAudioSD_SourceState_StateInfo =0;
    
    char gAudioSD_SourceState_StateInfo_string [8][20] = {  "unknown",
							                                "scan",
							                                "mix",
							                                "repeat",
                                                            "repeat/mix",
                                                            "manual tuning",
                                                            "seek",
                                                            "play more like this"};

    byte gAudioSD_SourceState_Scope =0;
    
    char gAudioSD_SourceState_Scope_string [9][40] ={   "unknown scope /any scope",
                                                        "file/track",
                                                        "device",
                                                        "medium",
                                                        "directory without subdirectories",
                                                        "directory with subdirectories",
                                                        "all directories /all folders",
                                                        "playlist",
                                                        "all playlists"};


    /***CurrentStationInfo***/
    const PRIMARYINFORMATION_TEXTLENGTH =73;
    char gAudioSD_CSI_PrimaryInformation [PRIMARYINFORMATION_TEXTLENGTH];

    byte gAudioSD_CSI_PI_Type =0;
    char gAudioSD_CSI_PI_Type_string [86][50] ={ "any type / unknown",
                                                "folder",
                                                "track",
                                                "playlist",
                                                "playlist folder",
                                                "any category / unknown category",
                                                "audio file",
                                                "video file",
                                                "legacy audio track (CD)",
                                                "CD audio track - CD text",
                                                "voicememo file",
                                                "image file",
                                                "audio folder",
                                                "video folder",
                                                "image folder",
                                                "voicememo folder",
                                                "category - genre",
                                                "category - genres",
                                                "category - unknown genre",
                                                "category - unknown genres",
                                                "category - artist",
                                                "category - artists",
                                                "category - unknown artist",
                                                "category - unknown artists",
                                                "category - composer",
                                                "category - composers",
                                                "category - unknown composer",
                                                "category - unknown composers",
                                                "category - year",
                                                "category - unknown year",
                                                "category - comment",
                                                "category - unknown comment",
                                                "category - album",
                                                "category - albums",
                                                "category - unknown album",
                                                "category - unknown albums",
                                                "category - song",
                                                "category - songs",
                                                "category - unknown song",
                                                "category - unknown songs",
                                                "category - audiobook",
                                                "category - audiobooks",
                                                "category - all",
                                                "category - podcast",
                                                "category - podcasts",
                                                "category - dynamic playlist not rated",
                                                "category - dynamic playlist 1 star",
                                                "category - dynamic playlist 2 stars",
                                                "category - dynamic playlist 3 stars",
                                                "category - dynamic playlist 4 stars",
                                                "category - dynamic playlist 5 stars",
                                                "category - dynamic playlist most played",
                                                "category - dynamic playlist last played",
                                                "category - dynamic playlist on-the-go",
                                                "category - dynamic playlists",
                                                "category - movies (DF4.1)",
                                                "category - music videos (DF4.1)",
                                                "category - video podcasts (DF4.1)",
                                                "category - borrowed videos (DF4.1)",
                                                "category - last copied files (DF4.1)",
                                                "category - favorites (DF4.1)",
                                                "category - unknown podcast (DF4.1)",
                                                "category - unknown podcasts (DF4.1)",
                                                "category - various artists (DF4.1)",
                                                "DVD main menue",
                                                "DVD chapter",
                                                "DVD title",
                                                "channel",
                                                "radio station (FM, AM, AM-SW; AM-LW)",
                                                "SDARS station",
                                                "DAB service",
                                                "DVB service",
                                                "title (forbidden in case of legacy audio CD)",
                                                "artist",
                                                "album",
                                                "DAB ensemble (DF 4.1)",
                                                "DAB secondary service (DF 4.1)",
                                                "moderator (DF 4.1)",
                                                "conductor (DF 4.1)",
                                                "composer (DF 4.1)",
                                                "program now (DF 4.1)",
                                                "category - unknown audiobook (DF4.1)",
                                                "category - unknown audiobooks (DF4.1)",
                                                "category - mood (DF4.1)",
                                                "category - unknown mood (DF4.1)",
                                                "online radio station (DF4.2)"};
    
    word gAudioSD_CSI_PIID =0;

    const SECONDARYINFORMATION_TEXTLENGTH =73;
    char gAudioSD_CSI_SecondaryInformation [SECONDARYINFORMATION_TEXTLENGTH];
    
    byte gAudioSD_CSI_SI_Type =0;
    char gAudioSD_CSI_SI_Type_string[86][50] ={ "any type / unknown",
                                                "folder",
                                                "track",
                                                "playlist",
                                                "playlist folder",
                                                "any category / unknown category",
                                                "audio file",
                                                "video file",
                                                "legacy audio track (CD)",
                                                "CD audio track - CD text",
                                                "voicememo file",
                                                "image file",
                                                "audio folder",
                                                "video folder",
                                                "image folder",
                                                "voicememo folder",
                                                "category - genre",
                                                "category - genres",
                                                "category - unknown genre",
                                                "category - unknown genres",
                                                "category - artist",
                                                "category - artists",
                                                "category - unknown artist",
                                                "category - unknown artists",
                                                "category - composer",
                                                "category - composers",
                                                "category - unknown composer",
                                                "category - unknown composers",
                                                "category - year",
                                                "category - unknown year",
                                                "category - comment",
                                                "category - unknown comment",
                                                "category - album",
                                                "category - albums",
                                                "category - unknown album",
                                                "category - unknown albums",
                                                "category - song",
                                                "category - songs",
                                                "category - unknown song",
                                                "category - unknown songs",
                                                "category - audiobook",
                                                "category - audiobooks",
                                                "category - all",
                                                "category - podcast",
                                                "category - podcasts",
                                                "category - dynamic playlist not rated",
                                                "category - dynamic playlist 1 star",
                                                "category - dynamic playlist 2 stars",
                                                "category - dynamic playlist 3 stars",
                                                "category - dynamic playlist 4 stars",
                                                "category - dynamic playlist 5 stars",
                                                "category - dynamic playlist most played",
                                                "category - dynamic playlist last played",
                                                "category - dynamic playlist on-the-go",
                                                "category - dynamic playlists",
                                                "category - movies (DF4.1)",
                                                "category - music videos (DF4.1)",
                                                "category - video podcasts (DF4.1)",
                                                "category - borrowed videos (DF4.1)",
                                                "category - last copied files (DF4.1)",
                                                "category - favorites (DF4.1)",
                                                "category - unknown podcast (DF4.1)",
                                                "category - unknown podcasts (DF4.1)",
                                                "category - various artists (DF4.1)",
                                                "DVD main menue",
                                                "DVD chapter",
                                                "DVD title",
                                                "channel",
                                                "radio station (FM, AM, AM-SW; AM-LW)",
                                                "SDARS station",
                                                "DAB service",
                                                "DVB service",
                                                "title (forbidden in case of legacy audio CD)",
                                                "artist",
                                                "album",
                                                "DAB ensemble (DF 4.1)",
                                                "DAB secondary service (DF 4.1)",
                                                "moderator (DF 4.1)",
                                                "conductor (DF 4.1)",
                                                "composer (DF 4.1)",
                                                "program now (DF 4.1)",
                                                "category - unknown audiobook (DF4.1)",
                                                "category - unknown audiobooks (DF4.1)",
                                                "category - mood (DF4.1)",
                                                "category - unknown mood (DF4.1)",
                                                "online radio station (DF4.2)"};
    
    const TERTIARYINFORMATION_TEXTLENGTH =73;
    char gAudioSD_CSI_TertiaryInformation[TERTIARYINFORMATION_TEXTLENGTH];
    
    byte gAudioSD_CSI_TI_Type =0;
    char gAudioSD_CSI_TI_Type_string[86][50] ={ "any type / unknown",
                                                "folder",
                                                "track",
                                                "playlist",
                                                "playlist folder",
                                                "any category / unknown category",
                                                "audio file",
                                                "video file",
                                                "legacy audio track (CD)",
                                                "CD audio track - CD text",
                                                "voicememo file",
                                                "image file",
                                                "audio folder",
                                                "video folder",
                                                "image folder",
                                                "voicememo folder",
                                                "category - genre",
                                                "category - genres",
                                                "category - unknown genre",
                                                "category - unknown genres",
                                                "category - artist",
                                                "category - artists",
                                                "category - unknown artist",
                                                "category - unknown artists",
                                                "category - composer",
                                                "category - composers",
                                                "category - unknown composer",
                                                "category - unknown composers",
                                                "category - year",
                                                "category - unknown year",
                                                "category - comment",
                                                "category - unknown comment",
                                                "category - album",
                                                "category - albums",
                                                "category - unknown album",
                                                "category - unknown albums",
                                                "category - song",
                                                "category - songs",
                                                "category - unknown song",
                                                "category - unknown songs",
                                                "category - audiobook",
                                                "category - audiobooks",
                                                "category - all",
                                                "category - podcast",
                                                "category - podcasts",
                                                "category - dynamic playlist not rated",
                                                "category - dynamic playlist 1 star",
                                                "category - dynamic playlist 2 stars",
                                                "category - dynamic playlist 3 stars",
                                                "category - dynamic playlist 4 stars",
                                                "category - dynamic playlist 5 stars",
                                                "category - dynamic playlist most played",
                                                "category - dynamic playlist last played",
                                                "category - dynamic playlist on-the-go",
                                                "category - dynamic playlists",
                                                "category - movies (DF4.1)",
                                                "category - music videos (DF4.1)",
                                                "category - video podcasts (DF4.1)",
                                                "category - borrowed videos (DF4.1)",
                                                "category - last copied files (DF4.1)",
                                                "category - favorites (DF4.1)",
                                                "category - unknown podcast (DF4.1)",
                                                "category - unknown podcasts (DF4.1)",
                                                "category - various artists (DF4.1)",
                                                "DVD main menue",
                                                "DVD chapter",
                                                "DVD title",
                                                "channel",
                                                "radio station (FM, AM, AM-SW; AM-LW)",
                                                "SDARS station",
                                                "DAB service",
                                                "DVB service",
                                                "title (forbidden in case of legacy audio CD)",
                                                "artist",
                                                "album",
                                                "DAB ensemble (DF 4.1)",
                                                "DAB secondary service (DF 4.1)",
                                                "moderator (DF 4.1)",
                                                "conductor (DF 4.1)",
                                                "composer (DF 4.1)",
                                                "program now (DF 4.1)",
                                                "category - unknown audiobook (DF4.1)",
                                                "category - unknown audiobooks (DF4.1)",
                                                "category - mood (DF4.1)",
                                                "category - unknown mood (DF4.1)",
                                                "online radio station (DF4.2)"};

    const QUATERNARYINFORMATION_TEXTLENGTH =73;
    char gAudioSD_CSI_QuarternaryInformation[QUATERNARYINFORMATION_TEXTLENGTH];
    
    byte gAudioSD_CSI_QI_Type =0;
    char gAudioSD_CSI_QI_Type_string[86][50] ={ "any type / unknown",
                                                "folder",
                                                "track",
                                                "playlist",
                                                "playlist folder",
                                                "any category / unknown category",
                                                "audio file",
                                                "video file",
                                                "legacy audio track (CD)",
                                                "CD audio track - CD text",
                                                "voicememo file",
                                                "image file",
                                                "audio folder",
                                                "video folder",
                                                "image folder",
                                                "voicememo folder",
                                                "category - genre",
                                                "category - genres",
                                                "category - unknown genre",
                                                "category - unknown genres",
                                                "category - artist",
                                                "category - artists",
                                                "category - unknown artist",
                                                "category - unknown artists",
                                                "category - composer",
                                                "category - composers",
                                                "category - unknown composer",
                                                "category - unknown composers",
                                                "category - year",
                                                "category - unknown year",
                                                "category - comment",
                                                "category - unknown comment",
                                                "category - album",
                                                "category - albums",
                                                "category - unknown album",
                                                "category - unknown albums",
                                                "category - song",
                                                "category - songs",
                                                "category - unknown song",
                                                "category - unknown songs",
                                                "category - audiobook",
                                                "category - audiobooks",
                                                "category - all",
                                                "category - podcast",
                                                "category - podcasts",
                                                "category - dynamic playlist not rated",
                                                "category - dynamic playlist 1 star",
                                                "category - dynamic playlist 2 stars",
                                                "category - dynamic playlist 3 stars",
                                                "category - dynamic playlist 4 stars",
                                                "category - dynamic playlist 5 stars",
                                                "category - dynamic playlist most played",
                                                "category - dynamic playlist last played",
                                                "category - dynamic playlist on-the-go",
                                                "category - dynamic playlists",
                                                "category - movies (DF4.1)",
                                                "category - music videos (DF4.1)",
                                                "category - video podcasts (DF4.1)",
                                                "category - borrowed videos (DF4.1)",
                                                "category - last copied files (DF4.1)",
                                                "category - favorites (DF4.1)",
                                                "category - unknown podcast (DF4.1)",
                                                "category - unknown podcasts (DF4.1)",
                                                "category - various artists (DF4.1)",
                                                "DVD main menue",
                                                "DVD chapter",
                                                "DVD title",
                                                "channel",
                                                "radio station (FM, AM, AM-SW; AM-LW)",
                                                "SDARS station",
                                                "DAB service",
                                                "DVB service",
                                                "title (forbidden in case of legacy audio CD)",
                                                "artist",
                                                "album",
                                                "DAB ensemble (DF 4.1)",
                                                "DAB secondary service (DF 4.1)",
                                                "moderator (DF 4.1)",
                                                "conductor (DF 4.1)",
                                                "composer (DF 4.1)",
                                                "program now (DF 4.1)",
                                                "category - unknown audiobook (DF4.1)",
                                                "category - unknown audiobooks (DF4.1)",
                                                "category - mood (DF4.1)",
                                                "category - unknown mood (DF4.1)",
                                                "online radio station (DF4.2)"};

    byte gAudioSD_CSI_StationInfoSwitches =0;
    char gAudioSD_CSI_StationInfoSwitches_string[2][15] = { "not available",
                                                            "available"};

    byte gAudioSD_CSI_TATP  =0;
    byte gAudioSD_CSI_TMC   =0;
    byte gAudioSD_CSI_VICS  =0;
    byte gAudioSD_CSI_IBOC  =0;

    byte gAudioSD_CSI_StationProperties =0;
    byte gAudioSD_CSI_StationProperties_DABlinked   =0;
    byte gAudioSD_CSI_StationProperties_IBOC        =0;
    byte gAudioSD_CSI_StationProperties_DABservice  =0;
    byte gAudioSD_CSI_StationProperties_OnlineRad   =0;

    char gAudioSD_CSI_StationProperties_Bit0_string[2][30] = {  "not linked or not applicable",
                                                                "DAB service linked to FM"};

    char gAudioSD_CSI_StationProperties_Bit1_string[2][30] = {  "no IBOC live transmission",
                                                                "IBOC live transmission active"};

    char gAudioSD_CSI_StationProperties_Bit2_string[2][33] = {  "no DAB service or audio signal",
                                                                "DAB service contain audio signal"};

    char gAudioSD_CSI_StationProperties_Bit3_string[2][35] = {  "station not linked to online Radio",
                                                                "station linked to online Radio"};


    word gAudioSD_CSI_ChannelID =0;

    /***CurrentStationInfo_Handle***/
    word gAudioSD_CSIhandle_FSGhandle               =0;
    word gAudioSD_CSIhandle_FSGhandle_absolutePOS   =0;
    byte gAudioSD_CSIhandle_PresetListRef           =0;
    byte gAudioSD_CSIhandle_PresetListabsolutePos   =0;
    word gAudioSD_CSIhandle_DABEnsembleHandle       =0;
    word gAudioSD_CSIhandle_DABEnsembleAbsPos       =0;

    /***GeneralInfoSwitches***/
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches =0;
    
    char gAudioSD_GeneralInfoSwitches_OnOffSwitches_string[2][5] ={ "On",
                                                                    "Off"};    

    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA          =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS           =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic     =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC           =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS          =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online        =0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB           =0;

    byte gAudioSD_GeneralInfoSwitches_Reserve       =0;

    byte gAudioSD_GeneralInfoSwitches_Modification  =0;
    
    char gAudioSD_GeneralInfoSwitches_Modification_string[2][20] ={ "cannot be modified",
                                                                    "can be modified"};
    
    byte gAudioSD_GeneralInfoSwitches_Modification_TPTA          =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_RDS           =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_JPtraffic     =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_TMC           =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_VICS          =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_Online        =0;
    byte gAudioSD_GeneralInfoSwitches_Modification_DAB           =0;
    /***TPMemoInfo***/
    byte gAudioSD_TPMemoInfo_CurrentMsgNumber   =0;
    byte gAudioSD_TPMemoInfo_TotalMsgNumber     =0;
    byte gAudioSD_TPMemoInfo_hour               =0;
    byte gAudioSD_TPMemoInfo_minute             =0;

    const STATIONNAME_TEXTLENGTH =49;
    char gAudioSD_TPMemoInfo_StationName [STATIONNAME_TEXTLENGTH];

    /***AnnouncementInfo***/
    byte gAudioSD_AnnouncementInfo_Type         =0;
    char gAudioSD_AnnouncementInfo_Type_string[14][50]  ={  "no message/announcement active",
                                                            "RDS PTY31 announcement ('Katastrophenmeldung')",
                                                            "traffic announcement",
                                                            "transport flash",
                                                            "news",
                                                            "area weather",
                                                            "event announcement",
                                                            "special event",
                                                            "programme information",
                                                            "sport report",
                                                            "financial report",
                                                            "emergency information",
                                                            "TMC TTS",
                                                            "warning/service"};

    const ANNOUNCEMENT_STATIONNAME_TEXTLENGTH =49;
    char gAudioSD_AnnouncementInfo_StationName[ANNOUNCEMENT_STATIONNAME_TEXTLENGTH];

    /***AnnouncementEscape***/
    byte gAudioSD_AnnouncementEscape_Reserve       =0;
    byte gAudioSD_AnnouncementEscape_Result        =0;

    const ANNOUNCEMENTESCAPE_SUCCESSFUL			    =0x00;
    const ANNOUNCEMENTESCAPE_NOTSUCCESSFUL			=0x01;
    const ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL		=0x02;
    const ANNOUNCEMENTESCAPE_ABORTNOTSUCCESSFUL	    =0x03;
    const ANNOUNCEMENTESCAPE_ANNOUNCEMENTNOTACTIVE	=0x04;

    char gAudioSD_DAC_AnnouncementEscape_Result_string [5][30] = {  "successful",
								                                    "not successful",
								                                    "abort successful ",
								                                    "abort not successful",
                                                                    "Announcement not active"};

    /***InfoStates***/
    byte gAudioSD_InfoStates_States =0;

    char gAudioSD_InfoStates_States_string [82] [70] = {"no error",
                								                        "error (unspecified)",
                								                        "no CD",
                								                        "no DVD",
                								                        "no SD",
                								                        "check media",
                                                        "no media",
                                                        "no media inserted",
                                                        "media not readable",
                                                        "media is being loaded",
                                                        "media is being ejected",
                                                        "temperature to high",
                								                        "SD card full",
                								                        "Sirius not subscribed",
                								                        "XM not subscribed",
                								                        "GCI update in progress",
                								                        "Aux-In: Audio",
                								                        "Aux-In Video",
                								                        "enter code",
                								                        "please wait",
                								                        "insert disk",
                								                        "select disk",
                								                        "select CD position",
                								                        "remove disk",
                								                        "saving data",
                								                        "retrieving data",
                								                        "shutting down",
                                                        "creating auto store list",
                                                        "creating initial auto store list",
                                                        "no SAT radio available / no SAT Tuner connected",
                                                        "diagnosis sessions active",
                                                        "software update in progress",
                                                        "TA message is being recorded",
                                                        "SDS initialising (SDS is being initialised)",
                                                        "no playable files",
                                                        "wrong region code - some changes left",
                                                        "wrong region code - no changes left",
                                                        "connection error (wired connection)",
                                                        "connection error (wireless connection)",
                                                        "no device conected",
                                                        "bluetooth error - unspecified",
                                                        "bluetooth deactivated",
                                                        "bluetooth off - due to clamp S off",
                                                        "bluetooth pairing failed",
                                                        "file corrupted",
                                                        "file is DRM protected",
                                                        "import running",
                                                        "childlock error",
                                                        "WLAN connect in progress",
                                                        "no WLAN Player in system",
                                                        "WLAN - S contact missing",
                                                        "WLAN deactivated",
                                                        "unspecific WLAN error",
                                                        "overcurrent",
                                                        "cable error",
                                                        "Subscription Update (PSV-Update) (SDARS)",
                                                        "Antenna Error (SDARS)",
                                                        "no TP/TIM message(s) recorded", 
                                                        "medium write protected",
                                                        "Jukebox is beeing deleted",
                                                        "Jokebox is (still) empty",
                                                        "BT audio player deactivated",
                                                        "BT: automatic reconnect",
                                                        "WLAN player deactiavted",
                                                        "temperature too low",
                                                        "external device not supported",
                                                        "external device: firmware error",
                                                        "handbook video active",
                                                        "media device is being connected",
                                                        "SDARS tuner is being initalised",
                                                        "files being used as ringtone",
                                                        "no App",
                                                        "message read aloud",
                                                        "A2SL transmission active",
                                                        "Fileplayer active",
                                                        "OnlineMedia: no device",
                                                        "MobileDevice (Apple) active",
                                                        "MobileDevice (Google) active",
                                                        "MobileDevice (Baidu) active",
                                                        "Radio initialising",
                                                        "Media initialising",
                                                        "Device in charge only"};


    /***ReceptionListType***/
    byte gAudioSD_ReceptionListType_Type =0;

    char gAudioSD_ReceptionListType_Type_string [12] [30]=  {"unknown type/unspecific",
                								                            "FM reception list",
                								                            "AM reception list",
                								                            "DAB reception list",
                								                            "SDARS reception list",
                								                            "DVB reception list",
                                                            "TV reception list",
                                                            "AM-SW reception list",
                                                            "AM-LW reception list",
                                                            "Online radio reception list",
                                                            "Common List (DF4.2)",
                                                            "Online Podcast"};
    
    const NORECEPTIONLISTAVAILABLE =0xff;
    char gAudioSD_ReceptionListType_Type_string_0xff [30] ="no reception list available";

    /***MediaBrowser_FolderLevel***/
    byte gAudioSD_MediaBrowser_FL_FolderLevel               =0;
    word gAudioSD_MediaBrowser_FL_RefMediaBrowser           =0;    
    word gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos    =0;

    /***MediaPath***/
    byte gAudioSD_MediaPath_FolderType =0;
    char gAudioSD_MediaPath_FolderType_string[85][50] ={    "any type / unknown",
                                                            "folder",
                                                            "reserved",
                                                            "reserved",
                                                            "playlist folder",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "audio folder",
                                                            "video folder",
                                                            "image folder",
                                                            "voicememo folder",
                                                            "category - genre",
                                                            "category - genres",
                                                            "category - unknown genre",
                                                            "category - unknown genres",
                                                            "category - artist",
                                                            "category - artists",
                                                            "category - unknown artist",
                                                            "category - unknown artists",
                                                            "category - composer",
                                                            "category - composers",
                                                            "category - unknown composer",
                                                            "category - unknown composers",
                                                            "category - year",
                                                            "category - unknown year",
                                                            "category - comment",
                                                            "category - unknown comment",
                                                            "category - album",
                                                            "category - albums",
                                                            "category - unknown album",
                                                            "category - unknown albums",
                                                            "category - song",
                                                            "category - songs",
                                                            "category - unknown song",
                                                            "category - unknown songs",
                                                            "category - audiobook",
                                                            "category - audiobooks",
                                                            "category - all",
                                                            "category - podcast",
                                                            "category - podcasts",
                                                            "category - dynamic playlist not rated",
                                                            "category - dynamic playlist 1 star",
                                                            "category - dynamic playlist 2 stars",
                                                            "category - dynamic playlist 3 stars",
                                                            "category - dynamic playlist 4 stars",
                                                            "category - dynamic playlist 5 stars",
                                                            "category - dynamic playlist most played",
                                                            "category - dynamic playlist last played",
                                                            "category - dynamic playlist on-the-go",
                                                            "category - dynamic playlists",
                                                            "category - movies (DF4.1)",
                                                            "category - music videos (DF4.1)",
                                                            "category - video podcasts (DF4.1)",
                                                            "category - borrowed videos (DF4.1)",
                                                            "category - last copied files (DF4.1)",
                                                            "category - favorites (DF4.1)",
                                                            "category - unknown podcast (DF4.1)",
                                                            "category - unknown podcasts (DF4.1)",
                                                            "category - various artists (DF4.1)",
                                                            "DVD main menue",
                                                            "DVD chapter",
                                                            "iTunes Radio",
                                                            "iTunes U",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "reserved",
                                                            "category - unknown audiobook (DF4.1)",
                                                            "category - unknown audiobooks (DF4.1)",
                                                            "category - mood (DF4.1)",
                                                            "category - unknown mood (DF4.1)"};
    
    const MEDIAPATH_PATH_TEXTLENGTH =152;
    char gAudioSD_MediaPath_Path[MEDIAPATH_PATH_TEXTLENGTH];
    
    /***PreferredList***/
    byte gAudioSD_PreferredList_List        =0;
    char gAudioSD_PreferredList_List_string[6][50] ={   "no list preferred",
                                                        "reception list / media browser preferred",
                                                        "preset list preferred",
                                                        "sirius alert list preferred",
                                                        "last station list preferred",
                                                        "favorite list preferred"};

    /***SDS_State***/
    byte gAudioSD_SDSState_State =0;
    char gAudioSD_SDSState_State_string[19][50] ={  "SDS not built-in",
                                                    "SDS initialising (SDS is being initialised)",
                                                    "SDS initialising (active)",
                                                    "SDS active, recognizer open",
                                                    "SDS active, recognizer closed",
                                                    "SDS not ready",
                                                    "SDS deactivated",
                                                    "SDS pause",
                                                    "SDS not buit-in (active)",
                                                    "SDS (desired) language not available",
                                                    "SDS language is beeing loaded",
                                                    "SDS download unsuccessful",
                                                    "SDS not available due to active RVC/APS/OPS",
                                                    "SDS temporary not available",
                                                    "SDS external active (DF4.1)",
                                                    "SDS loading",
                                                    "SDS cloud loading",
                                                    "SDS presentation in FSG",
                                                    "SDS online search active"};

    /***FunctionSynchronisation***/
    byte gAudioSD_FunctionSynchronisation_FctList[8];
    
    char gAudioSD_FunctionSynchronisation_FctList_string[2][20] = { "not synchronised",
                                                                    "synchronised"};

    byte gAudioSD_FunctionSynchronisation_FctList_Bit16;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit17;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit18;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit19;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit20;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit21;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit22;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit23;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit24;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit25;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit26;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit27;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit28;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit29;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit30;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit31;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit32;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit33;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit34;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit35;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit36;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit37;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit38;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit39;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit40;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit41;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit42;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit43;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit44;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit45;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit46;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit47;

    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit00;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit01;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit02;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit03;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit04;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit05;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit06;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit07;
    
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit00;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit01;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit02;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit03;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit04;


    /***ASG_Capabilities***/
    byte gAudioSD_ASGCapabilities_PresentationCapabilities      =0;

    byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 =0;
    char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string [2][20]= {   "DAB short",
                                                                                    "DAB long"};
    
    byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 =0;
    char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string [2][20]= {   "SDARS short",
                                                                                    "SDARS long"};


    /***MediaImportState***/
    byte gMIS_STact =0;
    byte temp3      =0;



    /***CurrentVolumeExtended***/
    byte gCVE_CVTact =0;
    byte temp1      =0;



    /***CurrentDownloadState***/
    byte gCDS_CDSact =0;
    byte temp2      =0;




    /***OnlineMusic_State***/
    byte gOMS_Sact =0;
    byte temp4      =0;








    //Methods
    /***DedicatedAudioControl***/
    const AUDIO_DAC_SLE         =0x00;
    byte gAudioSD_DAC_CT        =AUDIO_DAC_SLE;

    word gAudioSD_DAC_FSGhandle =0x00;

    const AUDIO_DAC_NOLIST      =0x00;
    byte gAudioSD_DAC_LT        =AUDIO_DAC_NOLIST;

    byte gAudioSD_DAC_Result            =0;
    char gAudioSD_DAC_Result_s[4][30]   ={  "successful",
								            "not successful",
								            "abort successful ",
								            "abort not successful"};

    /***AnnouncementEscape***/
    byte gAudioSD_AnnoucementEsc_Result             =0;
    char gAudioSD_AnnoucementEsc_Result_s[5][30]    ={  "successful",
								                        "not successful",
								                        "abort successful ",
								                        "abort not successful",
                                                        "announcement not active"};
 
    /***SwitchSource***/
    word gAudioSD_SwitchSource_Ref   =0;

    byte gAudioSD_SwitchSource_Result =0;
    char gAudioSD_SwitchSource_Result_s[4][25] ={    "successful",
								                     "not successful",
								                     "abort successful ",
								                     "abort not successful"};
                                                     
    /***MediaBrowserControl***/
    byte gAudioSD_MBrC_Control  =0;
    word gAudioSD_MBrC_Ref      =0;

    byte gAudioSD_MBrC_Result =0;
    char gAudioSD_MBrC_Result_s[4][25] ={   "successful",
								            "not successful",
								            "abort successful ",
								            "abort not successful"};   

    /***MediaFileInfo***/
    word gAudioSD_MediaFileInfo_Ref      =0;

    const AUDIO_MEDIAFILINFO_ARTIST_LENGTH  =76; 
    char gAudioSD_MediaFileInfo_Artist_s[AUDIO_MEDIAFILINFO_ARTIST_LENGTH];
    
    const AUDIO_MEDIAFILINFO_TITLE_LENGTH  =76; 
    char gAudioSD_MediaFileInfo_Title_s[AUDIO_MEDIAFILINFO_TITLE_LENGTH];

    const AUDIO_MEDIAFILINFO_ALBUM_LENGTH  =76; 
    char gAudioSD_MediaFileInfo_Album_s[AUDIO_MEDIAFILINFO_ALBUM_LENGTH];

    byte gAudioSD_MediaFileInfo_Result =0;
    char gAudioSD_MediaFileInfo_Result_s[4][25] ={  "successful",
								                    "not successful",
								                    "abort successful ",
								                    "abort not successful"};  

    /***GetNextListPos***/
    word gAudioSD_GetNextListPos_CurrentPos =0;
    int gAudioSD_GetNextListPos_Offset     =0;
    byte gAudioSD_GetNextListPos_ListType   =0;
    
    char gAudioSD_GetNextListPos_ListType_string[8][20] ={  "ReceptionList",
                                                            "TPMemoList",
                                                            "SourceList",
                                                            "RadioTV_PresetList",
                                                            "MediaBrowser",
                                                            "SiriusAlertList",
                                                            "LastStationList",
                                                            "FavoriteList"};
    
    word gAudioSD_GetNextListPos_nextPos            =0;
    word gAudioSD_GetNextListPos_absoluteListPos    =0;

    byte gAudioSD_GetNextListPos_Result =0;
    char gAudioSD_GetNextListPos_Result_string[4][25] ={    "successful",
								                            "not successful",
								                            "abort successful ",
								                            "abort not successful"};
    
    byte gAudioSD_GetNextListPos_Reserve =0;




    /***SwitchRadioMedia***/
    byte gSwRaMe_SourceAct      = 0;
    byte gSwRaMe_SwRaMeReAct    = 0;
    int tempSwRaMe1             = 0;
    int tempSwRaMe2             = 0;


    /***SDS_State***/
    int gSDS_State_state        = 0;

    
    
    //Array's
    /***ReceptionList***/
    byte gReceptionList_ASGID    =0;
    byte gReceptionList_TAID     =0;
    word gReceptionList_TotalNumListElements =0;

    byte gReceptionList_ElementType =0;
    char gReceptionList_ElementType_s[6][70] ={ "ensembles",
                                                "primary service only",
                                                "secondary and primary services",
                                                "flat list (ensembles, primary services and secondary services)",
                                                "flat list (primary and secondary services)",
                                                "flat list (primary services only)"};

    word gReceptionList_ParentID                =0;
    const AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE =9;

    word gReceptionList_Pos [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];

    byte gReceptionList_Type [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Type_s[16][60] ={    "any string / unknown",
                                            "station name",
                                            "DAB ensemble name",
                                            "DAB primary service name",
                                            "DAB secondary service name",
                                            "IBOC primary service name (IBOC channel can be decoded)",
                                            "IBOC secondary service name",
                                            "DVB service name",
                                            "SDARS station name",
                                            "OnlineRadioPrimary (DF4.1)",
                                            "OnlineRadioSecondary (DF4.1)",
                                            "OnlineRadio - podcast",
                                            "OnlineRadio - live station",
                                            "FM radio station",
                                            "AM radio station",
                                            "DMB"};  
    
    byte gReceptionList_Attributes_available_Bit0[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_available_Bit0_s[2][15]    ={   "available",
                                                                   "not available"};
    byte gReceptionList_Attributes_DVB_Bit1[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_DVB_Bit1_s[2][30]   ={   "service OK",
                                                            "DVB service corrupted"};

    byte gReceptionList_Attributes_DAB_Bit2[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_DAB_Bit2_s[2][70]={  "DAB primary service contains no secondary service(s)",
                                                        "DAB primary service contains secondary service(s)"};

    byte gReceptionList_Attributes_DAB_Bit3[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_DAB_Bit3_s[2][30]={   "service OK",
                                                        "DAB primary service corrupted"};

    byte gReceptionList_Attributes_DAB_Bit4[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_DAB_Bit4_s[2][30]={   "DAB service not linked to FM",
                                                        "DAB service FM linked"};

    byte gReceptionList_Attributes_TP_Bit5[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_TP_Bit5_s[2][60]={   "TP not available/not supported by station",
                                                        "TP available/supported by station"};

    byte gReceptionList_Attributes_TMC_Bit6[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_TMC_Bit6_s[2][60]={   "TMC not supported/not available by station",
                                                        "TMC available/supported by station"};

    byte gReceptionList_Attributes_SDARS_Bit7[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_SDARS_Bit7_s[2][70]={ "SDARS station not subscribed",
                                                        "SDARS station subscribed or not an SDARS station"};


    byte gReceptionList_Attributes_DABserv_Bit8[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_DABserv_Bit8_s[2][70]={  "DAB service not linked to online",
                                                            "DAB service is linked to online"};

    byte gReceptionList_Attributes_FMOnline_Bit9[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_FMOnline_Bit9_s[2][70]={ "FM not linked to online",
                                                            "FM is linked to online"};
    
    byte gReceptionList_Attributes_StationSelect_BitA[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_StationSelect_BitA_s[2][70]={ "Station not selectable",
                                                            "Station selectable"};
    
    byte gReceptionList_Attributes_OnlineRadioMute_BitB[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_OnlineRadioMute_BitB_s[2][70]={ "Online Radio not muted / signal ok",
                                                            "Online Radio muting / low signal"};
    
    byte gReceptionList_Attributes_StationLinked_BitC[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Attributes_StationLinked_BitC_s[2][70]={ "Station not linked to online radio",
                                                            "Station linked to online radio"};


    word gReceptionList_Attributes [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    byte gReceptionList_PresetID [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    byte gReceptionList_FmRegCode [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];

    byte gReceptionList_Category [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE];
    char gReceptionList_Category_s[56][60]  ={  "unknown / none category",
                                                "news",
                                                "current affairs",
                                                "information",
                                                "sports",
                                                "education",
                                                "drama",
                                                "culture",
                                                "science",
                                                "varied",
                                                "pop music",
                                                "rock music",
                                                "easy listening music",
                                                "light classical",
                                                "serious classical",
                                                "other music",
                                                "weather",
                                                "finance",
                                                "childrens's programmes",
                                                "social affairs",
                                                "religion",
                                                "phone in",
                                                "travel",
                                                "leisure",
                                                "jazz music",
                                                "country music",
                                                "national music",
                                                "oldies music",
                                                "folk music",
                                                "documentary",
                                                "alarm test",
                                                "alarm",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "talk",
                                                "reserved",
                                                "classic rock",
                                                "adult hits",
                                                "soft rock",
                                                "top 40",
                                                "reserved",
                                                "oldies",
                                                "soft",
                                                "nostalgia",
                                                "reserved",
                                                "classical",
                                                "rhythm and blues",
                                                "soft rhythm and blues",
                                                "foreign language",
                                                "religious music",
                                                "relegious talk",
                                                "personality",
                                                "public",
                                                "college"};
    
    const AUDIO_RECEPTIONLIST_NAME_LENGTH =49;
    char gReceptionList_Name [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE][AUDIO_RECEPTIONLIST_NAME_LENGTH];

    const AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH =31;
    char gReceptionList_Frequency [AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE][AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH];
    
    byte gReceptionList_ListEntryReceptionInformation[AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //ReceptionList ->'sliding window' specific   
    const AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE      =1;
    byte gReceptionList_SlidingWindow_State             =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_RECEPTIONLIST_NOCACHE              =0;
    const AUDIO_RECEPTIONLIST_BUILDUPCACHE         =1;
    const AUDIO_RECEPTIONLIST_DOWN_CACHE           =2;
    const AUDIO_RECEPTIONLIST_UP_CACHE             =3;
    const AUDIO_RECEPTIONLIST_UP                   =4;
    const AUDIO_RECEPTIONLIST_DOWN                 =5;
    byte gReceptionList_ListHandlingType           =AUDIO_RECEPTIONLIST_NOCACHE; 
    
    const AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE              =0;
    const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_DOWN           =3; 
    byte gReceptionList_cacheBuildUp                           =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;

    const AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST       =3;
    byte gReceptionList_CallBackReason                         =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;

    byte gReceptionList_cacheDown                            =FALSE;
    byte gReceptionList_cacheUp                              =FALSE;
    byte gReceptionList_LastFirstElement                     =0;
    const AUDIO_RECEPTIONLIST_NO_NEXT_POSITION               =99;

    //display array
    byte gReceptionList_recordaddress            =0; 
    byte gReceptionList_transmitpos              =0;

    const AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING             =0;  
    const AUDIO_RECEPTIONLIST_CURSORACTION_DOWN                =1;
    const AUDIO_RECEPTIONLIST_CURSORACTION_UP                  =2;
    byte gReceptionList_CursorAction                            =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;

    const AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH              =0;
    const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_RECEPTIONLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gReceptionList_DisplayStatus                           =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;


    /***SourceList***/
    byte gSourceList_ASGID    =0;
    byte gSourceList_TAID     =0;
    
    word gSourceList_TotalNumListElements =0;

    const AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE =9;

    word gSourceList_Pos [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    
    const AUDIO_SOURCELIST_ST_NOSOURCE      =0x00;
    const AUDIO_SOURCELIST_ST_FM            =0x01;
    const AUDIO_SOURCELIST_ST_AM            =0x02;
    const AUDIO_SOURCELIST_ST_DAB           =0x03;
    const AUDIO_SOURCELIST_ST_SDARSXM       =0x04;
    const AUDIO_SOURCELIST_ST_SDARSSIRIUS   =0x05;
    const AUDIO_SOURCELIST_ST_CD            =0x06;
    const AUDIO_SOURCELIST_ST_CDC           =0x07;
    const AUDIO_SOURCELIST_ST_DVD           =0x08;
    const AUDIO_SOURCELIST_ST_TV            =0x09;
    const AUDIO_SOURCELIST_ST_HDD           =0x0A;
    const AUDIO_SOURCELIST_ST_SD            =0x0B;
    const AUDIO_SOURCELIST_ST_TPMEMO        =0x0C;
    const AUDIO_SOURCELIST_ST_AUXINAUDIO    =0x0D;
    const AUDIO_SOURCELIST_ST_AUXINVIDEO    =0x0E;
    const AUDIO_SOURCELIST_ST_MDI           =0x0F;
    const AUDIO_SOURCELIST_ST_GENERICPLAYER =0x10;
    const AUDIO_SOURCELIST_ST_AMTI          =0x11;
    const AUDIO_SOURCELIST_ST_DVDC          =0x12;
    const AUDIO_SOURCELIST_ST_USB           =0x13;
    const AUDIO_SOURCELIST_ST_JUKEBOX       =0x14;
    const AUDIO_SOURCELIST_ST_BTSTREAM      =0x15;
    const AUDIO_SOURCELIST_ST_BTRCP         =0x16;
    const AUDIO_SOURCELIST_ST_DVBVIDEO      =0x17;
    const AUDIO_SOURCELIST_ST_DVBAUDIO      =0x18;
    const AUDIO_SOURCELIST_ST_AMSW          =0x19;
    const AUDIO_SOURCELIST_ST_AMLW          =0x1A;
    const AUDIO_SOURCELIST_ST_WLANMASSSTOR  =0x1B;
    const AUDIO_SOURCELIST_ST_WLANRCP       =0x1C;
    const AUDIO_SOURCELIST_ST_BLUERAY       =0x1D;
    const AUDIO_SOURCELIST_ST_BLUERAYC      =0x1E;
    const AUDIO_SOURCELIST_ST_FLASH         =0x1F;
    const AUDIO_SOURCELIST_ST_AUXINVIDEOTV  =0x20;
    const AUDIO_SOURCELIST_ST_HDMI          =0x21;
    const AUDIO_SOURCELIST_ST_ONLINEMASSSTORAGE=0x22;
    const AUDIO_SOURCELIST_ST_ONLINERADIO   =0x23;
    const AUDIO_SOURCELIST_ST_COMMONLIST    =0x24;
    const AUDIO_SOURCELIST_ST_MOBDEVICEAPPLE=0x25;
    const AUDIO_SOURCELIST_ST_MOBDEVICEMIRRORLINK=0x26;
    const AUDIO_SOURCELIST_ST_MOBDEVICEGOOGLE=0x27;
    const AUDIO_SOURCELIST_ST_MOBDEVICEBAIDU=0x28;
    const AUDIO_SOURCELIST_ST_RSE           =0x29;
    const AUDIO_SOURCELIST_ST_DMB           =0x2A;
    const AUDIO_SOURCELIST_ST_ONLINEMUSICSTREAMING=0x2B;
    const AUDIO_SOURCELIST_ST_ONLINETV      =0x2C;
    const AUDIO_SOURCELIST_ST_ONLINEVIDEO   =0x2D;
    const AUDIO_SOURCELIST_ST_UNKNOWN       =0xFF;
    byte gSourceList_SourceType [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_SourceType_s [46][61]  ={  "no source",
                                                "FM",
                                                "AM",
                                                "DAB",
                                                "SDARS-XM",
                                                "SDARS-SIRIUS",
                                                "CD",
                                                "CD changer",
                                                "DVD",
                                                "TV",
                                                "HDD",
                                                "SD",
                                                "TP-Memo / TIM",
                                                "Aux-In Audio",
                                                "Aux-In Video",
                                                "portable device (MDI, AMI)",
                                                "generic player",
                                                "AM-TI (Japan)",
                                                "DVD changer",
                                                "USB",
                                                "Jukebox",
                                                "BT connection - BT stream",
                                                "BT connection - remote control protocol",
                                                "DVB - video service",
                                                "DVB - audio service",
                                                "AM-SW ('Kurzwelle' / short wave)",
                                                "AM-LW ('Langwelle' / long wave)",
                                                "WLAN connection - mass storage",
                                                "WLAN connection - RCP (Remote Control Player)",
                                                "BlueRay",
                                                "BlueRay changer",
                                                "Flash (flash memory)",
                                                "Aux-in Video (TV)",
                                                "HDMI (DF4.1)",
                                                "Online mass storage (DF4.1)",
                                                "Online radio (DF4.1)"
                                                "commonList(DF4.2)",
                                                "mobileDevice (apple)(DF4.2)",
                                                "mobileDevice (mirror)(DF4.2)",
                                                "mobileDevice (google)(DF4.2)",
                                                "mobileDevice (Baidu)(DF4.4)",
                                                "RSE",
                                                "DMB",
                                                "online music streaming",
                                                "online TV",
                                                "online video",
                                                "unknown source"};
    
    byte gSourceList_InstanceID [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];

    const AUDIO_SOURCELIST_MT_NOTAVAILABLE      =0x00;
    const AUDIO_SOURCELIST_MT_CDAUDIO           =0x01;
    const AUDIO_SOURCELIST_MT_DVDAUDIO          =0x02;
    const AUDIO_SOURCELIST_MT_DVDVIDEO          =0x03;
    const AUDIO_SOURCELIST_MT_CDVIDEO           =0x04;
    const AUDIO_SOURCELIST_MT_CDROM             =0x05;
    const AUDIO_SOURCELIST_MT_DVDROM            =0x06;
    const AUDIO_SOURCELIST_MT_FILESYSTEM        =0x07;
    const AUDIO_SOURCELIST_MT_RAW               =0x08;
    const AUDIO_SOURCELIST_MT_RCP               =0x09;
    const AUDIO_SOURCELIST_MT_SOUNDBROADCAST    =0x0A;
    const AUDIO_SOURCELIST_MT_VIDEOBROADCAST    =0x0B;
    const AUDIO_SOURCELIST_MT_IPOD              =0x0C;
    const AUDIO_SOURCELIST_MT_BLUERAY           =0x0D;
    const AUDIO_SOURCELIST_MT_UNKNOWN           =0xFF;
    byte gSourceList_MediaType [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_MediaType_s[14][50]  ={    "not avaialble / not applicable",
                                                "CD Audio",
                                                "DVD Audio",
                                                "DVD Video",
                                                "CD Video",
                                                "CD ROM",
                                                "DVD ROM",
                                                "file system",
                                                "raw",
                                                "RCP (Remote Control Protocol)",
                                                "audio broadcasting (radio)",
                                                "video broadcasting (TV, DVB)",
                                                "iPOD",
                                                "BlueRay"};  

    byte gSourceList_Attributes_BuiltIn_Bit0[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_BuiltIn_Bit0_s[2][30]={ "built-in but not ready",
                                                        "bulit-in and ready"};

    byte gSourceList_Attributes_MediaError_Bit1[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_MediaError_Bit1_s[2][30]={  "media/audio source error",
                                                            "media/audio no error"};

    byte gSourceList_Attributes_MediaPlay_Bit2[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_MediaPlay_Bit2_s[2][50]={   "media is not playable (no playable files)",
                                                            "media is playable"};

    byte gSourceList_Attributes_MediaRead_Bit3[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_MediaRead_Bit3_s[2][30]={   "media is not readable",
                                                            "media is readable"};

    byte gSourceList_Attributes_MediaLoad_Bit4[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_MediaLoad_Bit4_s[2][30]={   "media is being loaded",
                                                            "media is not being loaded"};

    byte gSourceList_Attributes_ImportRun_Bit5[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_ImportRun_Bit5_s[2][30]={   "import running",
                                                            "no import running"};

    byte gSourceList_Attributes_MediaSupp_Bit6[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];
    char gSourceList_Attributes_MediaSupp_Bit6_s[2][30]={    "media not support browser",
                                                             "media not support browser"};

    byte gSourceList_Attributes [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE];

    const AUDIO_SOURCELIST_NAME_LENGTH =61;
    char gSourceList_Name [AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE][AUDIO_SOURCELIST_NAME_LENGTH];
    
    byte gSourceList_ListEntryReceptionInformation[AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //SourceList ->'sliding window' specific   
    const AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE      =1;
    byte gSourceList_SlidingWindow_State             =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_SOURCELIST_NOCACHE              =0;
    const AUDIO_SOURCELIST_BUILDUPCACHE         =1;
    const AUDIO_SOURCELIST_DOWN_CACHE           =2;
    const AUDIO_SOURCELIST_UP_CACHE             =3;
    const AUDIO_SOURCELIST_UP                   =4;
    const AUDIO_SOURCELIST_DOWN                 =5;
    byte gSourceList_ListHandlingType           =AUDIO_SOURCELIST_NOCACHE; 
    
    const AUDIO_SOURCELIST_BUILDUPCACHENOCACHE              =0;
    const AUDIO_SOURCELIST_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_SOURCELIST_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_SOURCELIST_BUILDUPCACHECACHE_DOWN           =3; 
    byte gSourceList_cacheBuildUp                           =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;

    const AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST       =3;
    byte gSourceList_CallBackReason                         =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;

    byte gSourceList_cacheDown                            =FALSE;
    byte gSourceList_cacheUp                              =FALSE;
    byte gSourceList_LastFirstElement                     =0;
    const AUDIO_SOURCELIST_NO_NEXT_POSITION               =99;

    //display array
    byte gSourceList_recordaddress            =0; 
    byte gSourceList_transmitpos              =0;

    const AUDIO_SOURCELIST_CURSORACTION_NOTHING             =0;  
    const AUDIO_SOURCELIST_CURSORACTION_DOWN                =1;
    const AUDIO_SOURCELIST_CURSORACTION_UP                  =2;
    byte gSourceList_CursorAction                           =AUDIO_SOURCELIST_CURSORACTION_NOTHING;

    const AUDIO_SOURCELIST_DISPLAYLIST_REFRESH              =0;
    const AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_SOURCELIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gSourceList_DisplayStatus                          =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_SOURCELIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;

    /***RadioTV_PresetList***/
    byte gRadioTVPresetList_ASGID    =0;
    byte gRadioTVPresetList_TAID     =0;
    
    word gRadioTVPresetList_TotalNumListElements =0;

    const AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE =9;

    word gRadioTVPresetList_Pos [AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    
    byte gRadioTVPresetList_PresetIndex [AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];

    const AUDIO_RADIOTVPRESETLIST_WB_UNKNOWN     =0x00;
    const AUDIO_RADIOTVPRESETLIST_WB_FM          =0x01;
    const AUDIO_RADIOTVPRESETLIST_WB_AMMW        =0x02;
    const AUDIO_RADIOTVPRESETLIST_WB_AMSW        =0x03;
    const AUDIO_RADIOTVPRESETLIST_WB_AMLW        =0x04;
    const AUDIO_RADIOTVPRESETLIST_WB_SDARSXM     =0x05;
    const AUDIO_RADIOTVPRESETLIST_WB_SDARSSIRIUS =0x06;
    const AUDIO_RADIOTVPRESETLIST_WB_DAB         =0x07;
    const AUDIO_RADIOTVPRESETLIST_WB_DVB         =0x08;
    const AUDIO_RADIOTVPRESETLIST_WB_TV          =0x09;
    const AUDIO_RADIOTVPRESETLIST_WB_ONLINERADIO =0x0A;
    const AUDIO_RADIOTVPRESETLIST_WB_COMMONLIST  =0x0B;
    const AUDIO_RADIOTVPRESETLIST_WB_DMB         =0x0C;
    const AUDIO_RADIOTVPRESETLIST_WB_ONLINETV    =0x0D;
    byte gRadioTVPresetList_Waveband [AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Waveband_s [14][60]  ={  "unknown / invalid",
                                                    "FM",
                                                    "AM (MW)",
                                                    "AM (SW)",
                                                    "AM (LW)",
                                                    "SDARS - XM",
                                                    "SDARS - Sirius",
                                                    "DAB",
                                                    "DVB",
                                                    "TV",
                                                    "Online radio (DF4.1)",
                                                    "Common List",
                                                    "DMB",
                                                    "online TV"};
   

    byte gRadioTVPresetList_Attributes_IBOC_Bit0[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_IBOC_Bit0_s[2][30]={ "not an IBOC service",
                                                            "IBOC service"};

    byte gRadioTVPresetList_Attributes_DABSecServ_Bit1[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[2][30]={   "not a DAB secondary service",
                                                                    "DAB secondary service"};

    byte gRadioTVPresetList_Attributes_DABPrimServ_Bit2[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[2][80]={  "DAB primary service contains no secondary service(s) / no DAB primary service",
                                                                    "DAB primary service contains secondary service(s)"};
    
    byte gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[2][80]={  "not an online radio secondary service",
                                                                    "Online radio secondary service"};
    
    byte gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[2][80]={  "Online radio - no primary service / prim. serv. contains no second. serv.",
                                                                    "Online radio primary service contains secondary service"};

    byte gRadioTVPresetList_Attributes_TP_Bit5[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_TP_Bit5_s[2][50]={   "TP not available/not supported by station",
                                                            "TP available/supported by station"};

    byte gRadioTVPresetList_Attributes_TMC_Bit6[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_TMC_Bit6_s[2][50]={  "TMC not supported/not available by station",
                                                            "TMC available/supported by station"};

    byte gRadioTVPresetList_Attributes_SDRAS_Bit7[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_SDARS_Bit7_s[2][50]={ "SDARS station not subscribed",
                                                             "SDARS station subscribed or not an SDARS station"};
    
    byte gRadioTVPresetList_Attributes_StationSelect_Bit8[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_StationSelect_Bit8_s[2][50]={ "Station not selectable",
                                                             "Station selectable"};
    
    byte gRadioTVPresetList_Attributes_OnRadMute_Bit9[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[2][50]={ "Online radio not muted / signal OK",
                                                             "Online radio muting / low signal"};
    
    byte gRadioTVPresetList_Attributes_StationLinked_BitA[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];
    char gRadioTVPresetList_Attributes_StationLinked_BitA_s[2][50]={ "Station not linked to online radio",
                                                             "Station linked to online radio"};

    word gRadioTVPresetList_Attributes [AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE];

    const AUDIO_RADIOTVPRESETLIST_NAME_LENGTH =49;
    char gRadioTVPresetList_Name [AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE][AUDIO_RADIOTVPRESETLIST_NAME_LENGTH];
    
    byte gRadioTVPresetList_ListEntryReceptionInformation[AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //RadioTVPresetList ->'sliding window' specific   
    const AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE      =1;
    byte gRadioTVPresetList_SlidingWindow_State             =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_RADIOTVPRESETLIST_NOCACHE              =0;
    const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHE         =1;
    const AUDIO_RADIOTVPRESETLIST_DOWN_CACHE           =2;
    const AUDIO_RADIOTVPRESETLIST_UP_CACHE             =3;
    const AUDIO_RADIOTVPRESETLIST_UP                   =4;
    const AUDIO_RADIOTVPRESETLIST_DOWN                 =5;
    byte gRadioTVPresetList_ListHandlingType           =AUDIO_RADIOTVPRESETLIST_NOCACHE; 
    
    const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE              =0;
    const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_DOWN           =3; 
    byte gRadioTVPresetList_cacheBuildUp                           =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;

    const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST       =3;
    byte gRadioTVPresetList_CallBackReason                         =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;

    byte gRadioTVPresetList_cacheDown                            =FALSE;
    byte gRadioTVPresetList_cacheUp                              =FALSE;
    byte gRadioTVPresetList_LastFirstElement                     =0;
    const AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION               =99;

    //display array
    byte gRadioTVPresetList_recordaddress            =0; 
    byte gRadioTVPresetList_transmitpos              =0;

    const AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING             =0;  
    const AUDIO_RADIOTVPRESETLIST_CURSORACTION_DOWN                =1;
    const AUDIO_RADIOTVPRESETLIST_CURSORACTION_UP                  =2;
    byte gRadioTVPresetList_CursorAction                           =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;

    const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH              =0;
    const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gRadioTVPresetList_DisplayStatus                          =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;

    /***TpMemoList***/
    byte gTpMemoList_ASGID    =0;
    byte gTpMemoList_TAID     =0;
    
    word gTpMemoList_TotalNumListElements =0;

    const AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE =9;

    byte gTpMemoList_Pos [AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE];
    
    byte gTpMemoList_Attributes_NewMessage_Bit0[AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE];
    char gTpMemoList_Attributes_NewMessage_Bit0_s[2][30]={ "message is not new",
                                                           "new message"};

    byte gTpMemoList_Attributes [AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE];

    byte gTpMemoList_Hour [AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE];

    byte gTpMemoList_Minute [AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE];

    const AUDIO_TPMEMOLIST_STATIONNAME_LENGTH =49;
    char gTpMemoList_StationName [AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE][AUDIO_TPMEMOLIST_STATIONNAME_LENGTH];
    
    byte gTpMemoList_ListEntryReceptionInformation[AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //TpMemoList ->'sliding window' specific   
    const AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_TPMEMOLIST_SLIDINGWINDOW_ACTIVE      =1;
    byte gTpMemoList_SlidingWindow_State             =AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_TPMEMOLIST_NOCACHE              =0;
    const AUDIO_TPMEMOLIST_BUILDUPCACHE         =1;
    const AUDIO_TPMEMOLIST_DOWN_CACHE           =2;
    const AUDIO_TPMEMOLIST_UP_CACHE             =3;
    const AUDIO_TPMEMOLIST_UP                   =4;
    const AUDIO_TPMEMOLIST_DOWN                 =5;
    byte gTpMemoList_ListHandlingType           =AUDIO_TPMEMOLIST_NOCACHE; 
    
    const AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE              =0;
    const AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_DOWN           =3; 
    byte gTpMemoList_cacheBuildUp                           =AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE;

    const AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST       =3;
    byte gTpMemoList_CallBackReason                         =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;

    byte gTpMemoList_cacheDown                            =FALSE;
    byte gTpMemoList_cacheUp                              =FALSE;
    byte gTpMemoList_LastFirstElement                     =0;
    const AUDIO_TPMEMOLIST_NO_NEXT_POSITION               =99;

    //display array
    byte gTpMemoList_recordaddress            =0; 
    byte gTpMemoList_transmitpos              =0;

    const AUDIO_TPMEMOLIST_CURSORACTION_NOTHING             =0;  
    const AUDIO_TPMEMOLIST_CURSORACTION_DOWN                =1;
    const AUDIO_TPMEMOLIST_CURSORACTION_UP                  =2;
    byte gTpMemoList_CursorAction                           =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;

    const AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH              =0;
    const AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_TPMEMOLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gTpMemoList_DisplayStatus                          =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;

    
    /***MediaBrowser***/
    byte gMediaBrowser_ASGID    =0;
    byte gMediaBrowser_TAID     =0;
    word gMediaBrowser_TotalNumListElements =0;

    word gMediaBrowser_ActiveListPos           =0;
    const AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE =9;

    word gMediaBrowser_Pos [AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];

    byte gMediaBrowser_FileType [AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileType_s[103][50]   ={  "any string / unknown",
                                                "folder",
                                                "track",
                                                "playlist",
                                                "playlist folder",
                                                "any category / unknown category",
                                                "audio file",
                                                "video file",
                                                "legacy audio track (CD)",
                                                "CD audio track - CD text",
                                                "voicememo file",
                                                "image file",
                                                "audio folder",
                                                "video folder",
                                                "image folder",
                                                "voicememo folder",
                                                "category - genre",
                                                "category - genres",
                                                "category - unknown genre",
                                                "category - unknown genres",
                                                "category - artist",
                                                "category - artists",
                                                "category - unknown artist",
                                                "category - unknown artists",
                                                "category - composer",
                                                "category - composers",
                                                "category - unknown composer",
                                                "category - unknown composers",
                                                "category - year",
                                                "category - unknown year",
                                                "category - comment",
                                                "category - unknown comment",
                                                "category - album",
                                                "category - albums",
                                                "category - unknown album",
                                                "category - unknown albums",
                                                "category - song",
                                                "category - songs",
                                                "category - unknown song",
                                                "category - unknown songs",
                                                "category - audiobook",
                                                "category - audiobooks",
                                                "category - all",
                                                "category - podcast",
                                                "category - podcasts",
                                                "category - dynamic playlist not rated",
                                                "category - dynamic playlist 1 star",
                                                "category - dynamic playlist 2 stars",
                                                "category - dynamic playlist 3 stars",
                                                "category - dynamic playlist 4 stars",
                                                "category - dynamic playlist 5 stars",
                                                "category - dynamic playlist most played",
                                                "category - dynamic playlist last played",
                                                "category - dynamic playlist on-the-go",
                                                "category - dynamic playlists",
                                                "category - movies (DF4.1)",
                                                "category - music videos (DF4.1)",
                                                "category - video podcasts (DF4.1)",
                                                "category - borrowed videos (DF4.1)",
                                                "category - last copied files (DF4.1)",
                                                "category - favorites (DF4.1)",
                                                "category - unknown podcast (DF4.1)",
                                                "category - unknown podcasts (DF4.1)",
                                                "category - various artists (DF4.1)",
                                                "DVD main menue",
                                                "DVD chapter",
                                                "DVD title",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "reserved",
                                                "category - unknown audiobook (DF4.1)",
                                                "category - unknown audiobooks (DF4.1)",
                                                "category - mood (DF4.1)",
                                                "category - unknown mood (DF4.1)",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved for other categories",
                                                "reserved (to stay identical to FctID 0x15)",
                                                "online radio - live station",
                                                "FM radio station",
                                                "AM radio station",
                                                "DAB radio station",
                                                "SDARS - Sirius",
                                                "DMB"};
                                               
    
    byte gMediaBrowser_FileState_emptyFolder_Bit0[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_emptyFolder_Bit0_s[2][30] ={  "not an empty folder",
                                                               "empty folder"};

    byte gMediaBrowser_FileState_DRM_Bit1[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_DRM_Bit1_s[2][30]  ={  "not DRM proteced",
                                                        "DRM proteced"};
    
    byte gMediaBrowser_FileState_FileCorrupted_Bit2[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_FileCorrupted_Bit2_s[2][30]    ={  "file/folder is not corrupted",
                                                                    "corrupted file/folder"};

    byte gMediaBrowser_FileState_DeadLink_Bit3[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_DeadLink_Bit3_s[2][30] ={  "not a dead link",
                                                            "dead link"};
    
    byte gMediaBrowser_FileState_ImportFinished_Bit4[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_ImportFinished_Bit4_s[2][40]   ={  "import finished / unknown import state",
                                                                    "import running"};
    
    byte gMediaBrowser_FileState_ImportPending_Bit5[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_ImportPending_Bit5_s[2][30]    ={  "import not pending",
                                                                    "import pending"};
    
    byte gMediaBrowser_FileState_ImportPlayable_Bit6[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    char gMediaBrowser_FileState_ImportPlayable_Bit6_s[2][40]  ={   "import playable / not an import",
                                                                    "import not playable"};

    word gMediaBrowser_FileState [AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE];
    
    const AUDIO_MEDIABROWSER_FILENAME_LENGTH =97;
    char gMediaBrowser_FileName [AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE][AUDIO_MEDIABROWSER_FILENAME_LENGTH];
    
    byte gMediaBrowser_ListEntryReceptionInformation[AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //MediaBrowser ->'sliding window' specific   
    const AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE      =1;
    byte gMediaBrowser_SlidingWindow_State             =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_MEDIABROWSER_NOCACHE              =0;
    const AUDIO_MEDIABROWSER_BUILDUPCACHE         =1;
    const AUDIO_MEDIABROWSER_DOWN_CACHE           =2;
    const AUDIO_MEDIABROWSER_UP_CACHE             =3;
    const AUDIO_MEDIABROWSER_UP                   =4;
    const AUDIO_MEDIABROWSER_DOWN                 =5;
    byte gMediaBrowser_ListHandlingType           =AUDIO_MEDIABROWSER_NOCACHE; 
    
    const AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE              =0;
    const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_DOWN           =3; 
    byte gMediaBrowser_cacheBuildUp                           =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;

    const AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST       =3;
    byte gMediaBrowser_CallBackReason                         =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;

    byte gMediaBrowser_cacheDown                            =FALSE;
    byte gMediaBrowser_cacheUp                              =FALSE;
    byte gMediaBrowser_LastFirstElement                     =0;
    const AUDIO_MEDIABROWSER_NO_NEXT_POSITION               =99;

    //display array
    byte gMediaBrowser_recordaddress            =0; 
    byte gMediaBrowser_transmitpos              =0;

    const AUDIO_MEDIABROWSER_CURSORACTION_NOTHING             =0;  
    const AUDIO_MEDIABROWSER_CURSORACTION_DOWN                =1;
    const AUDIO_MEDIABROWSER_CURSORACTION_UP                  =2;
    byte gMediaBrowser_CursorAction                            =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;

    const AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH              =0;
    const AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_MEDIABROWSER_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gMediaBrowser_DisplayStatus                           =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
    
    
    // ****** others.... *****
    
    byte gErrorCode;

    byte gASG_PowerOnOff =FALSE;
    const POWER_OFF = 0x00;
    const POWER_ON	= 0x01;

    byte gBAP_Init = FALSE;

    char gstring_ASG_PowerOnOff [2][4] ={"Off",
       							        "On"};

    byte gBAP_AudioSD_available =FALSE;
       
    dword gRGB_red;
    dword gRGB_yellow;
    dword gRGB_green;
    dword gRGB_grey;
    dword gRGB_white;



    /* 0x32 CommonList */


    byte gCommonList_ASGID                                      =0;
    byte gCommonList_TAID                                       =0;
    word gCommonList_TotalNumListElements                       =0;

    const AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE                    =9;
    const AUDIO_ASG_COMMONLIST_ENTRIES                          =254;
    const AUDIO_COMMONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;   
    const AUDIO_COMMONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;     
    const AUDIO_COMMONLIST_NO_NEXT_POSITION                     =99;

    byte gCommonList_ListEntryReceptionInformation [AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE];
    byte gCommonList_Pos [AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE];

    byte gCommonList_cacheDown                            =FALSE;
    byte gCommonList_cacheUp                              =FALSE;
    byte gCommonList_LastFirstElement                     =0;

    const AUDIO_COMMONLIST_NOCACHE              =0;
    const AUDIO_COMMONLIST_BUILDUPCACHE         =1;
    const AUDIO_COMMONLIST_DOWN_CACHE           =2;
    const AUDIO_COMMONLIST_UP_CACHE             =3;
    const AUDIO_COMMONLIST_UP                   =4;
    const AUDIO_COMMONLIST_DOWN                 =5;
    byte gCommonList_ListHandlingType           =AUDIO_COMMONLIST_NOCACHE; 

    word gCommonList_Attributes[AUDIO_ASG_COMMONLIST_ENTRIES];
    byte gCommonList_Category[AUDIO_ASG_COMMONLIST_ENTRIES];
    byte gCommonList_PresetID[AUDIO_ASG_COMMONLIST_ENTRIES];
    byte gCommonList_SourceType[AUDIO_ASG_COMMONLIST_ENTRIES];

    const AUDIO_ASG_COMMONLIST_FREQUENCY_LENGTH =31;
    char gCommonList_ASG_Frequency [AUDIO_ASG_COMMONLIST_ENTRIES][AUDIO_ASG_COMMONLIST_FREQUENCY_LENGTH];

    const AUDIO_ASG_COMMONLIST_NAME_LENGTH =49;
    char gCommonList_ASG_Name [AUDIO_ASG_COMMONLIST_ENTRIES][AUDIO_ASG_COMMONLIST_NAME_LENGTH];

    
    /***SiriusAlertList***/
    byte gSiriusAlertList_ASGID    =0;
    byte gSiriusAlertList_TAID     =0;
    word gSiriusAlertList_TotalNumListElements =0;

    const AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE =9;

    word gSiriusAlertList_Pos [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];

    byte gSiriusAlertList_Attributes_Bit0[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit0_s[2][15]    ={   "not available",
                                                                   "available"};
    byte gSiriusAlertList_Attributes_Bit1[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit1_s[2][30]   ={   "TP not available",
                                                            "TP available"};

    byte gSiriusAlertList_Attributes_Bit2[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit2_s[2][70]={  "TMC not available",
                                                        "TMC available"};

    byte gSiriusAlertList_Attributes_Bit3[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit3_s[2][30]={   "SDARS station not subscribed",
                                                        "SDARS station subscribed"};

    byte gSiriusAlertList_Attributes_Bit4[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit4_s[2][30]={   "Station selectable",
                                                        "Station not selectable"};

    byte gSiriusAlertList_Attributes_Bit5[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit5_s[2][60]={   "OnlineRadion not muted / signal OK",
                                                        "OnlineRadion muting / low signal"};

    byte gSiriusAlertList_Attributes_Bit6[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_Attributes_Bit6_s[2][60]={   "Station not linked to online radio",
                                                        "Station linked to online radio"};

    word gSiriusAlertList_Attributes [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    
    byte gSiriusAlertList_PresetID [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    
    const AUDIO_SIRIUSALERTLIST_NAME_LENGTH =49;
    char gSiriusAlertList_Name [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE][AUDIO_SIRIUSALERTLIST_NAME_LENGTH];

    const AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH =31;
    char gSiriusAlertList_Frequency [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE][AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH];
        
    byte gSiriusAlertList_AlertType [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE];
    char gSiriusAlertList_AlertType_s[8][60] ={    "any alert / unknown",
                                            "traffic alert",
                                            "weather alert",
                                            "artist alert",
                                            "song alert",
                                            "sports alert",
                                            "game alert",
                                            "score alert"};  
    
    const AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH =49;
    char gSiriusAlertList_AlertName [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE][AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH];

    const AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH =31;
    char gSiriusAlertList_Extension [AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE][AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH];
        
    byte gSiriusAlertList_ListEntryReceptionInformation[AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 

    //SiriusAlertList ->'sliding window' specific   
    const AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_ACTIVE      =1;
    byte gSiriusAlertList_SlidingWindow_State             =AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_SIRIUSALERTLIST_NOCACHE              =0;
    const AUDIO_SIRIUSALERTLIST_BUILDUPCACHE         =1;
    const AUDIO_SIRIUSALERTLIST_DOWN_CACHE           =2;
    const AUDIO_SIRIUSALERTLIST_UP_CACHE             =3;
    const AUDIO_SIRIUSALERTLIST_UP                   =4;
    const AUDIO_SIRIUSALERTLIST_DOWN                 =5;
    byte gSiriusAlertList_ListHandlingType           =AUDIO_SIRIUSALERTLIST_NOCACHE; 
    
    const AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE              =0;
    const AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_DOWN           =3; 
    byte gSiriusAlertList_cacheBuildUp                           =AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE;

    const AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST       =3;
    byte gSiriusAlertList_CallBackReason                         =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;

    byte gSiriusAlertList_cacheDown                            =FALSE;
    byte gSiriusAlertList_cacheUp                              =FALSE;
    byte gSiriusAlertList_LastFirstElement                     =0;
    const AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION               =99;

    //display array
    byte gSiriusAlertList_recordaddress            =0; 
    byte gSiriusAlertList_transmitpos              =0;

    const AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING             =0;  
    const AUDIO_SIRIUSALERTLIST_CURSORACTION_DOWN                =1;
    const AUDIO_SIRIUSALERTLIST_CURSORACTION_UP                  =2;
    byte gSiriusAlertList_CursorAction                            =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;

    const AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH              =0;
    const AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_SIRIUSALERTLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gSiriusAlertList_DisplayStatus                           =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;

    /***PlayPosition***/
    word gAudioSD_PlayPosition_TimePosition = 0;
    word gAudioSD_PlayPosition_TotalPlayTime = 0;
    byte gAudioSD_PlayPosition_Attributes_Bit0 = 0;
    byte gAudioSD_PlayPosition_Attributes = 0;
    byte gAudioSD_PlayPosition_BufferLevel = 0;
    
    /***SDS_RecognizerState***/
    word gAudioSD_SDS_RecognizerState_InputLevel = 0;
    word gAudioSD_SDS_RecognizerState_InputQuality = 0;
    byte gAudioSD_SDS_RecognizerState_Extension1 = 0;
    byte gAudioSD_SDS_RecognizerState_Extension2 = 0;
    byte gAudioSD_SDS_RecognizerState_Extension3 = 0;
    byte gAudioSD_SDS_RecognizerState_Extension4 = 0;
    
    /***CurrentStationInfo2***/
    const CSI2_INFORMATION_TEXTLENGTH = 72;
    char gAudioSD_CSI2_Information1 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information2 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information3 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information4 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information5 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information6 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information7 [CSI2_INFORMATION_TEXTLENGTH];
    char gAudioSD_CSI2_Information8 [CSI2_INFORMATION_TEXTLENGTH];
    byte gAudioSD_CSI2_InfoType1 = 0;
    byte gAudioSD_CSI2_InfoType2 = 0;
    byte gAudioSD_CSI2_InfoType3 = 0;
    byte gAudioSD_CSI2_InfoType4 = 0;
    byte gAudioSD_CSI2_InfoType5 = 0;
    byte gAudioSD_CSI2_InfoType6 = 0;
    byte gAudioSD_CSI2_InfoType7 = 0;
    byte gAudioSD_CSI2_InfoType8 = 0;
    word gAudioSD_CSI2_InfoID1 = 0;
    word gAudioSD_CSI2_ChannelID = 0;
    word gAudioSD_CSI2_StationInfoSwitches = 0;
    word gAudioSD_CSI2_StationInfoSwitches_Bit0 = 0;
    word gAudioSD_CSI2_StationInfoSwitches_Bit1 = 0;
    word gAudioSD_CSI2_StationInfoSwitches_Bit2 = 0;
    word gAudioSD_CSI2_StationInfoSwitches_Bit3 = 0;
    word gAudioSD_CSI2_StationInfoSwitches_Bit4 = 0;
    word gAudioSD_CSI2_StationProperties = 0;
    word gAudioSD_CSI2_StationProperties_Bit0 = 0;
    word gAudioSD_CSI2_StationProperties_Bit1 = 0;
    word gAudioSD_CSI2_StationProperties_Bit2 = 0;
    word gAudioSD_CSI2_StationProperties_Bit3 = 0;
    word gAudioSD_CSI2_StationProperties_Bit4 = 0;
    word gAudioSD_CSI2_StationProperties_Bit5 = 0;
    word gAudioSD_CSI2_StationProperties_Bit6 = 0;
    
    /***CurrentStation_Handle3***/
    word gAudioSD_CurrentStation_Handle3_FavList = 0;
    word gAudioSD_CurrentStation_Handle3_FavListaP = 0;
    byte gAudioSD_CurrentStation_Handle3_Extension1 = 0;
    byte gAudioSD_CurrentStation_Handle3_Extension2 = 0;
    byte gAudioSD_CurrentStation_Handle3_Extension3 = 0;
    byte gAudioSD_CurrentStation_Handle3_Extension4 = 0;
    
    /***SiriusAlertInfo***/
    const SAI_ALERTNAME_TEXTLENGTH = 60;
    const SAI_STATIONNAME_TEXTLENGTH = 48;
    char gAudioSD_SAI_AlertName [SAI_ALERTNAME_TEXTLENGTH];
    char gAudioSD_SAI_StationName [SAI_STATIONNAME_TEXTLENGTH];
    byte gAudioSD_SAI_AlertType = 0;
    word gAudioSD_SAI_SALref = 0;
    byte gAudioSD_SAI_Extension1 = 0;
    byte gAudioSD_SAI_Extension2 = 0;
    byte gAudioSD_SAI_Extension3 = 0;
    
    /***Station_Track_Switch***/
    byte gAudioSD_Station_Track_Switch_Event = 0;
    byte gAudioSD_Station_Track_Switch_Direction = 0;
    byte gAudioSD_Station_Track_Switch_PlayState = 0;
    byte gAudioSD_Station_Track_Switch_Extension1 = 0;
    byte gAudioSD_Station_Track_Switch_Extension2 = 0;
    byte gAudioSD_Station_Track_Switch_Extension3 = 0;
    byte gAudioSD_Station_Track_Switch_Extension4 = 0;
    byte gAudioSD_Station_Track_Switch_Extension5 = 0;
    
    //------------------------------------------------
    /***Picture***/
    byte gPicture_ASGID                =0;
    byte gPicture_TAID                 =0;
    byte gPicture_TotalNumListElements =0;
    byte gPicture_ViewedElement        =0;      //First Element in view 
                                                //(from 0 to (TotalNumberListElements-NumberOfViewedElements)
                                                //  -> Last element at end of view)
    
    const AUDIOSD_PICTURE_ENTRIES =254;
    byte gPicture_Pos [AUDIOSD_PICTURE_ENTRIES];
    
    int gPicture_Type[AUDIOSD_PICTURE_ENTRIES];
    const AUDIOSD_PICTURE_TYPE_NOPICTURE          =0x00;
    const AUDIOSD_PICTURE_TYPE_SIGN               =0x01;
    const AUDIOSD_PICTURE_TYPE_GREENKANBAN        =0x02;
    const AUDIOSD_PICTURE_TYPE_BLUEKANBAN         =0x03;
    const AUDIOSD_PICTURE_TYPE_JUNCTIONVIEW       =0x04;
    const AUDIOSD_PICTURE_TYPE_INTERSECTIONVIEW   =0x05;
    const AUDIOSD_PICTURE_TYPE_EXITVIEW           =0x06;
    const AUDIOSD_PICTURE_TYPE_TOLLGATEVIEW       =0x07;
    const AUDIOSD_PICTURE_TYPE_MOTORWAYINFO       =0x08;
    const AUDIOSD_PICTURE_TYPE_SERVICEPARKINGAREA =0x09;
    const AUDIOSD_PICTURE_TYPE_TRAFFICDETAILS     =0x0A;
    const AUDIOSD_PICTURE_TYPE_LOCALHAZARDINFO    =0x0B;
    const AUDIOSD_PICTURE_TYPE_GHOSTDRIVER        =0x0C;
    const AUDIOSD_PICTURE_TYPE_VICSLEVEL1         =0x0D;
    const AUDIOSD_PICTURE_TYPE_HOTSPOTMAP         =0x0E;
    const AUDIOSD_PICTURE_TYPE_UNKNOWN            =0xFF;
    
    char gPicture_Type_s[6][50]    ={           "no picture",
                                                "StationArt - normal picture",
                                                "CoverArt - normal picture",
                                                "StationArt - default picture",
                                                "CoverArt - default picture",
                                                "Dynamic icon"};
    
    const AUDIOSD_PICTURE_IPADDRESS_LENGTH =17;
    char gPicture_IpAddress [AUDIOSD_PICTURE_ENTRIES][AUDIOSD_PICTURE_IPADDRESS_LENGTH];
    
    word gPicture_TcpPort[AUDIOSD_PICTURE_ENTRIES];
    
    word gPicture_Handle[AUDIOSD_PICTURE_ENTRIES];
    
    const AUDIOSD_PICTURE_URI_LENGTH =602;
    char gPicture_Uri [AUDIOSD_PICTURE_ENTRIES][AUDIOSD_PICTURE_URI_LENGTH];
    
    byte gPicture_ListEntryReceptionInformation [AUDIOSD_PICTURE_ENTRIES]; //indicates the reception of an "array element" 
    
    //Picture ->'sliding window' specific   
    const AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE      =1;
    byte gPicture_SlidingWindow_State             =AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_PICTURE_NOCACHE              =0;
    const AUDIO_PICTURE_BUILDUPCACHE         =1;
    const AUDIO_PICTURE_DOWN_CACHE           =2;
    const AUDIO_PICTURE_UP_CACHE             =3;
    const AUDIO_PICTURE_UP                   =4;
    const AUDIO_PICTURE_DOWN                 =5;
    byte gPicture_ListHandlingType           =AUDIO_PICTURE_NOCACHE; 
    
    const AUDIO_PICTURE_BUILDUPCACHENOCACHE              =0;
    const AUDIO_PICTURE_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_PICTURE_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_PICTURE_BUILDUPCACHECACHE_DOWN           =3; 
    byte gPicture_cacheBuildUp                           =AUDIO_PICTURE_BUILDUPCACHENOCACHE;

    const AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_PICTURE_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST       =3;
    byte gPicture_CallBackReason                         =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;

    byte gPicture_cacheDown                            =FALSE;
    byte gPicture_cacheUp                              =FALSE;
    byte gPicture_LastFirstElement                     =0;
    const AUDIO_PICTURE_NO_NEXT_POSITION               =99;

    //display array
    byte gPicture_recordaddress            =0; 
    byte gPicture_transmitpos              =0;

    const AUDIO_PICTURE_CURSORACTION_NOTHING             =0;  
    const AUDIO_PICTURE_CURSORACTION_DOWN                =1;
    const AUDIO_PICTURE_CURSORACTION_UP                  =2;
    byte gPicture_CursorAction                            =AUDIO_PICTURE_CURSORACTION_NOTHING;

    const AUDIO_PICTURE_DISPLAYLIST_REFRESH              =0;
    const AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_PICTURE_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gPicture_DisplayStatus                           =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_PICTURE_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
    
    //------------------------------------------------
    /***LastStationList***/
    byte gLSL_ASGID                =0;
    byte gLSL_TAID                 =0;
    byte gLSL_TotalNumListElements =0;
    byte gLSL_ViewedElement        =0;      //First Element in view 
                                                //(from 0 to (TotalNumberListElements-NumberOfViewedElements)
                                                //  -> Last element at end of view)
    
    const AUDIO_LSL_ASGCACHE_MAX_SIZE =254;
    //const AUDIOSD_LSL_ENTRIES =9;
    byte gLSL_Pos [AUDIO_LSL_ASGCACHE_MAX_SIZE];
    
    byte gLSL_PresetIndex [AUDIO_LSL_ASGCACHE_MAX_SIZE];
    
    byte gLSL_Waveband[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    const AUDIO_LSL_WB_UNKNOWN          =0x00;
    const AUDIO_LSL_WB_FM               =0x01;
    const AUDIO_LSL_WB_AM_MW            =0x02;
    const AUDIO_LSL_WB_AM_SW            =0x03;
    const AUDIO_LSL_WB_AM_LW            =0x04;
    const AUDIO_LSL_WB_SDARS            =0x05;
    const AUDIO_LSL_WB_DAB              =0x06;
    const AUDIO_LSL_WB_DVB              =0x07;
    const AUDIO_LSL_WB_TV               =0x08;
    const AUDIO_LSL_WB_ONLINERADIO      =0x09;
    const AUDIO_LSL_WB_COMMONLIST       =0x0A;
    const AUDIO_LSL_WB_DMB              =0x0B;
    const AUDIO_LSL_WB_ONLINETV         =0x0C;
    
    word gLSL_Attributes[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    byte gLSL_Attributes_Bit0[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit0_s[2][50]    ={   "not an IBOC service",
                                               "IBOC service"};
    byte gLSL_Attributes_Bit1[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit1_s[2][50]    ={   "not a DAB secondary service",
                                               "DAB secondary service"};
    byte gLSL_Attributes_Bit2[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit2_s[2][50]    ={   "no DAB primary service",
                                               "DAB prim. serv. contains sec. serv."};
    byte gLSL_Attributes_Bit3[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit3_s[2][50]    ={   "not an OnlineRadio sec. service",
                                               "OnlineRadio sec. service"};
    byte gLSL_Attributes_Bit4[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit4_s[2][50]    ={   "no OnlineRadio primary service",
                                               "OnlineRadio prim. serv. contains sec. serv."};
    byte gLSL_Attributes_Bit5[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit5_s[2][50]    ={   "TP not available",
                                               "TP available"};
    byte gLSL_Attributes_Bit6[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit6_s[2][50]    ={   "TMC not available",
                                               "TMC available"};
    byte gLSL_Attributes_Bit7[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit7_s[2][50]    ={   "SDARS station not subscribed",
                                               "SDARS station subscribed"};
    byte gLSL_Attributes_Bit8[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit8_s[2][50]    ={   "Station selectable",
                                               "Station not selectable"};
    byte gLSL_Attributes_Bit9[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit9_s[2][50]    ={   "not muted / signal OK",
                                               "muting / low signal"};
    byte gLSL_Attributes_Bit10[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit10_s[2][50]    ={  "Station not linked to OnlineRadio",
                                               "Station linked to OnlineRadio"};
    byte gLSL_Attributes_Bit11[AUDIO_LSL_ASGCACHE_MAX_SIZE];
    char gLSL_Attributes_Bit11_s[2][50]    ={  "Station not linked to FM",
                                               "Station linked to FM"};
    
    const AUDIO_LSL_NAME_LENGTH =49;
    char gLSL_Name [AUDIO_LSL_ASGCACHE_MAX_SIZE][AUDIO_LSL_NAME_LENGTH];

    const AUDIO_LSL_FREQUENCY_LENGTH =31;
    char gLSL_Frequency [AUDIO_LSL_ASGCACHE_MAX_SIZE][AUDIO_LSL_FREQUENCY_LENGTH];
    
    byte gLSL_ListEntryReceptionInformation [AUDIO_LSL_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 
    
    //LSL ->'sliding window' specific   
    const AUDIO_LSL_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_LSL_SLIDINGWINDOW_ACTIVE      =1;
    byte gLSL_SlidingWindow_State             =AUDIO_LSL_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_LSL_NOCACHE              =0;
    const AUDIO_LSL_BUILDUPCACHE         =1;
    const AUDIO_LSL_DOWN_CACHE           =2;
    const AUDIO_LSL_UP_CACHE             =3;
    const AUDIO_LSL_UP                   =4;
    const AUDIO_LSL_DOWN                 =5;
    byte gLSL_ListHandlingType           =AUDIO_LSL_NOCACHE; 
    
    const AUDIO_LSL_BUILDUPCACHENOCACHE              =0;
    const AUDIO_LSL_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_LSL_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_LSL_BUILDUPCACHECACHE_DOWN           =3; 
    byte gLSL_cacheBuildUp                           =AUDIO_LSL_BUILDUPCACHENOCACHE;

    const AUDIO_LSL_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_LSL_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_LSL_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_LSL_CALLBACKREASON_DISPLAYLIST       =3;
    byte gLSL_CallBackReason                         =AUDIO_LSL_CALLBACKREASON_NOCALLBACK;

    byte gLSL_cacheDown                            =FALSE;
    byte gLSL_cacheUp                              =FALSE;
    byte gLSL_LastFirstElement                     =0;
    const AUDIO_LSL_NO_NEXT_POSITION               =99;

    //display array
    byte gLSL_recordaddress            =0; 
    byte gLSL_transmitpos              =0;

    const AUDIO_LSL_CURSORACTION_NOTHING             =0;  
    const AUDIO_LSL_CURSORACTION_DOWN                =1;
    const AUDIO_LSL_CURSORACTION_UP                  =2;
    byte gLSL_CursorAction                            =AUDIO_LSL_CURSORACTION_NOTHING;

    const AUDIO_LSL_DISPLAYLIST_REFRESH              =0;
    const AUDIO_LSL_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_LSL_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gLSL_DisplayStatus                           =AUDIO_LSL_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_LSL_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_LSL_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
    
    //------------------------------------------------
    /***FavoriteList***/
    byte gFL_ASGID                =0;
    byte gFL_TAID                 =0;
    byte gFL_TotalNumListElements =0;
    byte gFL_ViewedElement        =0;      //First Element in view 
                                                //(from 0 to (TotalNumberListElements-NumberOfViewedElements)
                                                //  -> Last element at end of view)
    
    const AUDIO_FL_ASGCACHE_MAX_SIZE =254;
    //const AUDIOSD_FL_ENTRIES =9;
    byte gFL_Pos [AUDIO_FL_ASGCACHE_MAX_SIZE];
    
    byte gFL_PresetIndex [AUDIO_FL_ASGCACHE_MAX_SIZE];
    
    byte gFL_Waveband[AUDIO_FL_ASGCACHE_MAX_SIZE];
    const AUDIO_FL_WB_UNKNOWN          =0x00;
    const AUDIO_FL_WB_FM               =0x01;
    const AUDIO_FL_WB_AM_MW            =0x02;
    const AUDIO_FL_WB_AM_SW            =0x03;
    const AUDIO_FL_WB_AM_LW            =0x04;
    const AUDIO_FL_WB_SDARS            =0x05;
    const AUDIO_FL_WB_DAB              =0x06;
    const AUDIO_FL_WB_DVB              =0x07;
    const AUDIO_FL_WB_TV               =0x08;
    const AUDIO_FL_WB_ONLINERADIO      =0x09;
    const AUDIO_FL_WB_COMMONLIST       =0x0A;
    const AUDIO_FL_WB_DMB              =0x0B;
    const AUDIO_FL_WB_ONLINETV         =0x0C;
    
    word gFL_Attributes[AUDIO_FL_ASGCACHE_MAX_SIZE];
    byte gFL_Attributes_Bit0[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit0_s[2][50]    ={   "not an IBOC service",
                                               "IBOC service"};
    byte gFL_Attributes_Bit1[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit1_s[2][50]    ={   "not a DAB secondary service",
                                               "DAB secondary service"};
    byte gFL_Attributes_Bit2[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit2_s[2][50]    ={   "no DAB primary service",
                                               "DAB prim. serv. contains sec. serv."};
    byte gFL_Attributes_Bit3[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit3_s[2][50]    ={   "not an OnlineRadio sec. service",
                                               "OnlineRadio sec. service"};
    byte gFL_Attributes_Bit4[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit4_s[2][50]    ={   "no OnlineRadio primary service",
                                               "OnlineRadio prim. serv. contains sec. serv."};
    byte gFL_Attributes_Bit5[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit5_s[2][50]    ={   "TP not available",
                                               "TP available"};
    byte gFL_Attributes_Bit6[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit6_s[2][50]    ={   "TMC not available",
                                               "TMC available"};
    byte gFL_Attributes_Bit7[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit7_s[2][50]    ={   "SDARS station not subscribed",
                                               "SDARS station subscribed"};
    byte gFL_Attributes_Bit8[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit8_s[2][50]    ={   "Station selectable",
                                               "Station not selectable"};
    byte gFL_Attributes_Bit9[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit9_s[2][50]    ={   "not muted / signal OK",
                                               "muting / low signal"};
    byte gFL_Attributes_Bit10[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit10_s[2][50]    ={  "Station not linked to OnlineRadio",
                                               "Station linked to OnlineRadio"};
    byte gFL_Attributes_Bit11[AUDIO_FL_ASGCACHE_MAX_SIZE];
    char gFL_Attributes_Bit11_s[2][50]    ={  "Station not linked to FM",
                                               "Station linked to FM"};
    
    const AUDIO_FL_NAME_LENGTH =49;
    char gFL_Name [AUDIO_FL_ASGCACHE_MAX_SIZE][AUDIO_FL_NAME_LENGTH];

    const AUDIO_FL_FREQUENCY_LENGTH =31;
    char gFL_Frequency [AUDIO_FL_ASGCACHE_MAX_SIZE][AUDIO_FL_FREQUENCY_LENGTH];
    
    byte gFL_ListEntryReceptionInformation [AUDIO_FL_ASGCACHE_MAX_SIZE]; //indicates the reception of an "array element" 
    
    //FL ->'sliding window' specific   
    const AUDIO_FL_SLIDINGWINDOW_NOTACTIVE   =0;
    const AUDIO_FL_SLIDINGWINDOW_ACTIVE      =1;
    byte gFL_SlidingWindow_State             =AUDIO_FL_SLIDINGWINDOW_NOTACTIVE;
      
    const AUDIO_FL_NOCACHE              =0;
    const AUDIO_FL_BUILDUPCACHE         =1;
    const AUDIO_FL_DOWN_CACHE           =2;
    const AUDIO_FL_UP_CACHE             =3;
    const AUDIO_FL_UP                   =4;
    const AUDIO_FL_DOWN                 =5;
    byte gFL_ListHandlingType           =AUDIO_FL_NOCACHE; 
    
    const AUDIO_FL_BUILDUPCACHENOCACHE              =0;
    const AUDIO_FL_BUILDUPCACHECACHE_UP             =1;
    const AUDIO_FL_BUILDUPCACHECACHE_WINDOW         =2;
    const AUDIO_FL_BUILDUPCACHECACHE_DOWN           =3; 
    byte gFL_cacheBuildUp                           =AUDIO_FL_BUILDUPCACHENOCACHE;

    const AUDIO_FL_CALLBACKREASON_NOCALLBACK        =0;
    const AUDIO_FL_CALLBACKREASON_CACHENEXT         =1;
    const AUDIO_FL_CALLBACKREASON_CHECKCACHE        =2;
    const AUDIO_FL_CALLBACKREASON_DISPLAYLIST       =3;
    byte gFL_CallBackReason                         =AUDIO_FL_CALLBACKREASON_NOCALLBACK;

    byte gFL_cacheDown                            =FALSE;
    byte gFL_cacheUp                              =FALSE;
    byte gFL_LastFirstElement                     =0;
    const AUDIO_FL_NO_NEXT_POSITION               =99;

    //display array
    byte gFL_recordaddress            =0; 
    byte gFL_transmitpos              =0;

    const AUDIO_FL_CURSORACTION_NOTHING             =0;  
    const AUDIO_FL_CURSORACTION_DOWN                =1;
    const AUDIO_FL_CURSORACTION_UP                  =2;
    byte gFL_CursorAction                            =AUDIO_FL_CURSORACTION_NOTHING;

    const AUDIO_FL_DISPLAYLIST_REFRESH              =0;
    const AUDIO_FL_DISPLAYLIST_FIRST_ELEMENTS       =1;
    const AUDIO_FL_DISPLAYLIST_SEARCH_ELEMENTS      =2;
    byte gFL_DisplayStatus                           =AUDIO_FL_DISPLAYLIST_FIRST_ELEMENTS;                                      

    const AUDIO_FL_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
    const AUDIO_FL_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
}

on preStart
{
    char Path[255];
    char BAPVersion [200];
    
	// create write window for BAP communication
    gBAP_Trace  =writecreate("BAP-Trace ASG-AudioSD");								
	
    // clear BAP trace window
    writeclear(gBAP_Trace);													
	
    // error window for BAP communication
	gError_Trace=writecreate("ASG-AudioSD Error");									
	writeclear(gError_Trace);												

	//clear CAPL-window in write-window
    writeclear(1);															

	//get version from Stack
	Bap180_GetVersions(BAPVersion, 200);
	write(" ");
	write("***************************************************");
	write(BAPVersion);
	write("***************************************************");
	write(" ");
	
    
    write("***************************************************");
	write("ASG-AudioSD function catalog: 'BAP-FC_Audio_P30DF48_v2.80_F2.pdf'");
	write("ASG-AudioSD MSCs: 'BAP-MSCs_Audio-SD_P30DF40_v2.02.pdf'");
	write("***************************************************");
	

	// Create Node
	NODE_INDEX=Bap180_CreateNode();

    // Debug info
	// write("NODE_INDEX = 0x%x", NODE_INDEX); 

    // Load DBC and XML files. 
	write("*********************************************************************************");

    //load dbc-file
    getAbsFilePath(dbc_path, Path, 255);
	write("ASG-AudioSD: Loading BAP_DBC-File: '%s'", Path);
   
	if(Bap180_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)						
		writelineEx(gError_Trace, 0, "ASG-AudioSD Fehler beim Laden: '%s', Path");

	//load xml-file 
	getAbsFilePath(xml_path, Path, 255);
    write("ASG-AudioSD: Load BAP-XML-File: '%s'", Path);
    if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
	    writelineEx(gError_Trace, 0, "ASG-AudioSD: Fehler beim Laden: '%s' !", Path);	   
    write("*********************************************************************************");
    write("");

    // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	Bap180_AddCanMap(NODE_INDEX, 1, 1);
    
} /* end of method */

on start
{
	//Power on/off
	gBAP_Init=0;
	gASG_PowerOnOff=0;
	putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff[gASG_PowerOnOff]);

    //Panel
    closePanel("ASG_AudioSD_Properties_1");
    closePanel("ASG_AudioSD_Properties_2");
    closePanel("ASG_AudioSD_Properties_3");
    closePanel("ASG_AudioSD_Properties_4");
    closePanel("ASG_AudioSD_Methods");
    closePanel("ASG_AudioSD_0x17 - ReceptionList_(array)");
    closePanel("ASG_AudioSD_0x1B - TpMemoList_(array)");
    closePanel("ASG_AudioSD_0x20 - SourceList_(array)");
    closePanel("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)");
    closePanel("ASG_AudioSD_0x24 - MediaBrowser_(array)");
    closePanel("ASG_AudioSD_MainPanel");
    closePanel("ASG_Property_DF41");
    closePanel("Method_2_AudioSD_ASG");
    closePanel("CommonList_ASG"); 
    closePanel("ASG_Property_DF48");
    closePanel("ASG_AudioSD_0x32 - SiriusAlertList_(array)");
    closePanel("0x3B_FavoriteList_ASG2");
    closePanel("0x38_LastStationList_ASG2");
    closePanel("0x3E_Picture_ASG2");

    openPanel("AudioSD_MainPanel");
}

on stopMeasurement
{
	Bap180_Shutdown(NODE_INDEX,LSG_AudioSD);
}

BAP_CAN_TX_Request()
{
   int i;
   byte TX_Data[8];				//CAN-data
   dword TX_Header[3];			//CAN-header
   message 0x100 TX_Message;	//dummy-message
   
   TX_Header[2] = 8; // max-Length of TX_Data

   while (Bap180_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) 	//get BAP-data in CAN-format from DLL
   {
      TX_Message.CAN = TX_Header[0]; 		//CAN channel
      TX_Message.ID =TX_Header[1]; 			//Can ID
      TX_Message.DLC = TX_Header[2]; 		//received length
      for (i=0; i<TX_Message.DLC; i++)		//CAN data-bytes
	  {
	    TX_Message.byte(i) = TX_Data[i];
      }
      output(TX_Message);					//send CAN message

	  TX_Header[2] = 8; 					// max-Length of TX_Data
   } 
}

BAP_DLL_Indication()
{
int i, length, datalength, temp;
byte Indication_data[BAP_BUFFER_SIZE];												//indication data from DLL
dword Indication_header[6];															//indication header from DLL
byte BAP_data_type;

//init lokal variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i=0;i<6;i++)
		Indication_header[i]=0;

	for(i=0;i<BAP_BUFFER_SIZE;i++)
		Indication_data[i]=0;
//********************

	Indication_header[4]=BAP_BUFFER_SIZE;											//BAP-Stack needs this information for successful BAP_GetIndication 

	temp=Bap180_GetInd(NODE_INDEX, Indication_header, Indication_data);				//get BAP-Indication data from DLL
	//write("BAP_GetIndication: %d", temp);											//debug
	
	if(temp==0)
	{
		//read header
		gBAP_Indication[0]=Indication_header[0];									//LSG-ID
		gBAP_Indication[1]=Indication_header[1];									//Function-ID
		gBAP_Indication[2]=Indication_header[2];									//indication

		BAP_data_type=Indication_header[3];											//BAP data type
		//writelineEx(gBAP_Trace, 0, "Data-Type: %d", BAP_data_type);					//debug
		
		switch(BAP_data_type)
		{
			case Bap_Void:
				datalength=3;
				//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
				for (i=0;i<datalength;i++)											//BAL-Trace
					//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
			case Bap_UInt8:
				gBAP_Indication[3]=Indication_header[5];							//unit8-value
				
				datalength=4;
				
	/*			writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
		*/		
				//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
				for (i=0;i<datalength;i++)											//BAL-Trace
					//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
			case Bap_UInt16:
				gBAP_Indication[3]=Indication_header[5];							//unit16-value
				
				datalength=4;
				
/*				writelineEx(1, 0, "Indication_header:");							//debug
				for (i=0;i<6;i++)													//debug
					writeEX(1, 0, " %x",Indication_header [i]);						//debug
		*/
				//writelineEx(gBAP_Trace, 0, "ASG Indication: ");						//BAL-Trace
				for (i=0;i<datalength;i++)											//BAL-Trace
					//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
			case Bap_UInt32:
				gBAP_Indication[3]=Indication_header[5];							//unit32-value
				
				datalength=4;
				
/*				writelineEx(1, 0, "Indication_header:");							//debug
				for (i=0;i<6;i++)													//debug
					writeEX(1, 0, " %x",Indication_header [i]);						//debug
		*/
				//writelineEx(gBAP_Trace, 0, "ASG Indication: ");						//BAL-Trace
				for (i=0;i<datalength;i++)											//BAL-Trace
					//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
			case Bap_ByteSequence:													//BAP-data-type is byte sequence
				//read datalength
				length=Indication_header[4];										//length of date-array
				datalength=length+3;												//length of indication-array

				//read data-array
				for(i=0;i<length;i++)
					gBAP_Indication[i+3]=Indication_data[i];

/*				writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
		
				writelineEx(gBAP_Trace, 0, "Indication_data:");						//debug
				for (i=0;i<length;i++)												//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_data [i]);				//debug
*/				
				//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
				for (i=0;i<datalength;i++)											//BAL-Trace
				{
					writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
					if(i>20)
					{
						i=datalength;
						writeEX(gBAP_Trace, 0, "...");
					}
				}

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
            case Bap_Acknowledge: //not used, only at BAP 3.1
            break;
			case Bap_Error:
				gBAP_Indication[2]=Error_IND;										//internal indication-value for error
				gBAP_Indication[3]=Indication_header[5];							//error-code
				datalength=4;														//length of indication-array
				writelineEx(gBAP_Trace, 0, "ASG-Error-Indication: ");				//BAL-Trace
				writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ",gBAP_Indication[0]);		//BAL-Trace
				writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ",gBAP_Indication[1]);		//BAL-Trace
			//	writeEX(gBAP_Trace, 0, "Opcode: 0x%x   ",gBAP_Indication[2]);		//BAL-Trace
				writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ",gBAP_Indication[3]);	//BAL-Trace

				BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
			default:
				writelineEx(gError_Trace, 0, "ASG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
			break;
		}
	}
}

BAP_DLL_Request ()
{
int i, datalength;
byte temp;
byte Request_data[BAP_BUFFER_SIZE];	//Request data for DLL
dword Request_header[6];	//Request header for DLL
byte Wammw;					//data-error-flag (Geräusch)

//init lokal variables
	datalength=0;
	temp=0;
	Wammw=1;

	for(i=0;i<6;i++)
		Request_header[i]=0;

	for(i=0;i<BAP_BUFFER_SIZE;i++)
		Request_data[i]=0;
//********************

   
	if(gBAP_Requestbuffer_status [gstatus_requestbuffer]>0)							//if ready to send
	{
	//	writelineEx(gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
		switch(gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer])
		{
			case Bap_Void:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=0;														//not used
			break;
			case Bap_UInt8:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit8-value
			break;
			case Bap_UInt16:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit16-value
			break;
			case Bap_UInt32:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit32-value
			break;
			case Bap_ByteSequence:					//BAP-data-type is byte sequence
				datalength=gBAP_Requestbuffer_status [gstatus_requestbuffer]-3;

				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=Bap_ByteSequence;											//BAP data type
				Request_header[4]=datalength;												//length of date-array

				//data-array for BAP-DLL funcion 'BAP_Request'
				for(i=0;i<datalength;i++)
					Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];


/*				writelineEx(1, 0, "Request_header:");							//debug
				for (i=0;i<6;i++)												//debug
					writeEX(1, 0, " %x",Request_header [i]);					//debug
				
				writelineEx(1, 0, "Request_data:");								//debug
				for (i=0;i<datalength;i++)										//debug
					writeEX(1, 0, " %x",Request_data [i]);						//debug
*/
			break;
            case Bap_Acknowledge:// not used only BAP 3.1
            break;
			default:
				writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
				Wammw=0;
			break;			
		}
		
		if(Wammw)																			//no data-error
		{
			temp=Bap180_Request(NODE_INDEX, Request_header, Request_data);					//send data to BAP-DLL
		
			if(temp==0)																		//BAP-Request successful 											
			{
				writelineEx(gBAP_Trace, 0, "ASG-Request:    ");								//BAL-Trace		
				for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)			//BAL-Trace	
					writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);	//BAL-Trace	
			//	write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer); 			//debug
			}
			else																			//BAP-Request error
			{
				writelineEx(gBAP_Trace, 0, "ASG Error BAP_Request, errorcode: %x. ASG-Request:",temp);				//debug
				for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)									//debug
					writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);							//debug
			}
		}

		gBAP_Requestbuffer_status [gstatus_requestbuffer]=0;		//reset position status -> free position 
		gBAP_Requestbuffer_BAPDataTyp [gstatus_requestbuffer]=0;	//reset BAP-datatyp of sendet buffer element

		//delete sendet request buffer elements
		for(i=0;i<BAP_BUFFER_SIZE;i++)
			gBAP_Request [gstatus_requestbuffer] [i]=0;				//delete sended array
		
		if (gstatus_requestbuffer<(REQUESTBUFFER_LINES-1))			//last element of buffer is not reached	
			gstatus_requestbuffer++;
		else														//last element of buffer is reached
			gstatus_requestbuffer=0;
	}
}

init_variables()	//initialize/reset all global variables
{
    dword i, j;

	//BAP communication
	for (i=0;i<BAP_BUFFER_SIZE;i++)
		gBAP_Indication[i]=0;
	
    //RGB-Values for background colors
	gRGB_red    =MakeRGB(255,0,0);
	gRGB_yellow =MakeRGB(255,255,0);
	gRGB_green  =MakeRGB(0,255,0);
	gRGB_grey   =MakeRGB(192,192,192);
	gRGB_white  =MakeRGB(255,255,255);

	for (j=0;j<REQUESTBUFFER_LINES;j++)
	{
		gBAP_Requestbuffer_status[j] =0;
		gBAP_Requestbuffer_BAPDataTyp[j] =0;
	
		for (i=0;i<BAP_BUFFER_SIZE;i++)
			gBAP_Request[j][i] =0;
	}

	gwrite_requestbuffer_line   =0; 
	gstatus_requestbuffer       =0;

    putvalue(env_ASG_AudioSD_Config_SWConfig,xml_path);
    putvalue(env_ASG_AudioSD_Config_DBC,dbc_path);
    
    FunctionList_flag  =FALSE;

    //FctList
    for(i=0; i<8; i++)
        gFunctionList_FctList[i] =0;

    putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit41,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit42,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit43,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit44,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit45,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit46,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit47,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit48,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit49,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit50,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit51,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit52,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit53,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit54,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit55,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit56,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit57,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit58,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit59,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit60,FALSE);
	
    //FSG-Setup
	  gAudioSD_FSGSetup_maxVolume                 =0;

    gAudioSD_FSGSetup_supportedVolumeTypes      =0;
    gAudioSD_FSGSetup_entertainmentVolume       =FALSE;
    gAudioSD_FSGSetup_navigationVolume          =FALSE;
    gAudioSD_FSGSetup_announcementVolume        =FALSE;
    gAudioSD_FSGSetup_phoneVolume               =FALSE;
    gAudioSD_FSGSetup_SDSVolume                 =FALSE;
    gAudioSD_FSGSetup_phoneRingingVolume        =FALSE;
    gAudioSD_FSGSetup_carParkingFader           =FALSE;
    gAudioSD_FSGSetup_readMessageVolume         =FALSE;

    gAudioSD_FSGSetup_ReceptionList_AutoUpdate  =0;
    gAudioSD_FSGSetup_FMReceptionList           =FALSE;
    gAudioSD_FSGSetup_AMReceptionList           =FALSE;
    gAudioSD_FSGSetup_DABReceptionList          =FALSE;
    gAudioSD_FSGSetup_SDARSReceptionList        =FALSE;
    gAudioSD_FSGSetup_AMLWReceptionList         =FALSE;
    gAudioSD_FSGSetup_AMSWReceptionList         =FALSE;
    gAudioSD_FSGSetup_TVDVBReceptionList        =FALSE;
    gAudioSD_FSGSetup_ORReceptionList           =FALSE;    

    gAudioSD_FSGSetup_Setup_Extensions          =0;
    gAudioSD_FSGSetup_Setup_Extensions_DAB      =FALSE;
    gAudioSD_FSGSetup_Setup_Extensions_CL       =FALSE;
    gAudioSD_FSGSetup_Setup_Extensions_CA       =FALSE;
    gAudioSD_FSGSetup_Setup_Extensions_SA       =FALSE;
    gAudioSD_FSGSetup_Setup_Extensions_Su       =FALSE;

    putvalue(env_ASG_AudioSD_FSGSetup_MaxVol, gAudioSD_FSGSetup_maxVolume);

    putvalue(env_ASG_AudioSD_FSGSetup_Ent, gAudioSD_FSGSetup_entertainmentVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_Nav, gAudioSD_FSGSetup_navigationVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_Ano, gAudioSD_FSGSetup_announcementVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_Pho, gAudioSD_FSGSetup_phoneVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_SDS, gAudioSD_FSGSetup_SDSVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_PRVol, gAudioSD_FSGSetup_phoneRingingVolume);
    putvalue(env_ASG_AudioSD_FSGSetup_CarPF, gAudioSD_FSGSetup_carParkingFader);
    putvalue(env_ASG_AudioSD_FSGSetup_RMVol, gAudioSD_FSGSetup_readMessageVolume);

    putvalue(env_ASG_AudioSD_FSGSetup_FM, gAudioSD_FSGSetup_FMReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_AM, gAudioSD_FSGSetup_AMReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_DAB, gAudioSD_FSGSetup_DABReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_SDARS, gAudioSD_FSGSetup_SDARSReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_AMLW, gAudioSD_FSGSetup_AMLWReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_AMSW, gAudioSD_FSGSetup_AMSWReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_TVDVB, gAudioSD_FSGSetup_TVDVBReceptionList);
    putvalue(env_ASG_AudioSD_FSGSetup_OR, gAudioSD_FSGSetup_ORReceptionList);

    putvalue(env_ASG_AudioSD_FSGSetup_Ent_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Nav_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ano_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Pho_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_SDS_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_FM_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AM_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_DAB_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_SDARS_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AMLW_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AMSW_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_TVDVB_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_OR_s, empty_string);
    	
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA, gAudioSD_FSGSetup_Setup_Extensions_DAB);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL, gAudioSD_FSGSetup_Setup_Extensions_CL);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA, gAudioSD_FSGSetup_Setup_Extensions_CA);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA, gAudioSD_FSGSetup_Setup_Extensions_SA);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su, gAudioSD_FSGSetup_Setup_Extensions_Su);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su_s, empty_string);


    //FSG-OperationState
	gAudioSD_FSG_OperationState_OpState     =FSGOPERATIONSTATE_OFF;
    gAudioSD_FSG_OperationState_HMI_State   =NO_ANIMATION_RUNNING_ON_FSG;

    putvalue(env_ASG_AudioSD_FSGOpState_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGOpState_HMI_s, empty_string);

	//activeSource
	gAudioSD_activeSource_SourceType            =0;
    gAudioSD_audioSource_SourceList_Reference   =0;
	gAudioSD_audioSource_TypeOfNumber           =0;
    gAudioSD_audioSource_ListAvailable          =0;
    gAudioSD_audioSource_ReceptionList          =0;
    gAudioSD_audioSource_PresetList             =0;
    gAudioSD_audioSource_MediaBrowserList       =0;
    gAudioSD_audioSource_SiriusAlertList        =0;
    gAudioSD_audioSource_ListAvailable2         =0;
    gAudioSD_audioSource_LastStationList        =0;
    gAudioSD_audioSource_FavoriteList           =0;
    gAudioSD_audioSource_ListState              =0;
    gAudioSD_audioSource_Number                 =0;

    putvalue(env_ASG_AudioSD_AS_SourceType_s,empty_string);
    putvalue(env_ASG_AudioSD_AS_SL_Ref, 0);
    putvalue(env_ASG_AudioSD_AS_TypeOfNum_s,empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_RL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_RL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_PL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_PL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_ML, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_ML_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_SAL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_SAL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv2_LSL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv2_LSL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv2_FL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv2_FL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_ListState_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_ListState_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_Number, 0);  
	
    //activeSourceName
	for(i=0;i<ACTIVE_SOURCE_NAME_LENGTH;i++)
		gAudioSD_activeSourceName[i] =0;

	putvalue(env_ASG_AudioSD_ASName_Name_s, empty_string);

	//currentVolume
	gAudioSD_currentVolume_EntertainmentVolume =0;
    gAudioSD_currentVolume_NavigationVolume    =0;
    gAudioSD_currentVolume_TaVolume            =0;
    gAudioSD_currentVolume_PhoneVolume         =0;
    gAudioSD_currentVolume_SDSVolume           =0;
    gAudioSD_currentVolume_ChangingVolumeType  =0;

    putvalue(env_ASG_AudioSD_CurrVol_EntVol,gAudioSD_currentVolume_EntertainmentVolume);
    putvalue(env_ASG_AudioSD_CurrVol_NavVol,gAudioSD_currentVolume_NavigationVolume);
    putvalue(env_ASG_AudioSD_CurrVol_TaVol,gAudioSD_currentVolume_TaVolume);
    putvalue(env_ASG_AudioSD_CurrVol_PhoVol,gAudioSD_currentVolume_PhoneVolume);
    putvalue(env_ASG_AudioSD_CurrVol_SDSVol,gAudioSD_currentVolume_SDSVolume);            
    putvalue(env_ASG_AudioSD_CurrVol_chType_s, empty_string);

	//Mute
	gAudioSD_Mute_MuteState        =0;
    gAudioSD_Mute_Entertainment    =0;
    gAudioSD_Mute_DAB              =0;
    gAudioSD_Mute_DVB              =0;
    gAudioSD_Mute_SDARS            =0;
    gAudioSD_Mute_IBOC             =0;
    gAudioSD_Mute_sync_IBOC        =0;
    gAudioSD_Mute_Phone            =0;
	
    putvalue(env_ASG_AudioSD_Mute_Enter, gAudioSD_Mute_Entertainment);
    putvalue(env_ASG_AudioSD_Mute_DAB, gAudioSD_Mute_DAB);
    putvalue(env_ASG_AudioSD_Mute_DVB, gAudioSD_Mute_DVB);
    putvalue(env_ASG_AudioSD_Mute_SDARS, gAudioSD_Mute_SDARS);
    putvalue(env_ASG_AudioSD_Mute_IBOC, gAudioSD_Mute_IBOC);
    putvalue(env_ASG_AudioSD_Mute_sync_IBOC, gAudioSD_Mute_sync_IBOC);
    putvalue(env_ASG_AudioSD_Mute_Call, gAudioSD_Mute_Phone);

	//SourceState
	gAudioSD_SourceState_StateInfo  =0;
    gAudioSD_SourceState_Scope      =0;

	putvalue(env_ASG_AudioSD_SrcSt_SateInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_SrcSt_Scope_s, empty_string);
    putvalue(env_ASG_AudioSD_SrcSt_Scope, gAudioSD_SourceState_Scope);
    putvalue(env_ASG_AudioSD_SrcSt_SateInfo, gAudioSD_SourceState_Scope);

	//CurrentStationInfo
	gAudioSD_CSI_PI_Type                =0;
    gAudioSD_CSI_PIID                   =0;
    gAudioSD_CSI_SI_Type                =0; 
    gAudioSD_CSI_TI_Type                =0;
    gAudioSD_CSI_QI_Type                =0;
    gAudioSD_CSI_StationInfoSwitches    =0;

    gAudioSD_CSI_TATP                   =0;
    gAudioSD_CSI_TMC                    =0;
    gAudioSD_CSI_VICS                   =0;
    gAudioSD_CSI_IBOC                   =0;

    gAudioSD_CSI_StationProperties_DABlinked    =0;
    gAudioSD_CSI_StationProperties_IBOC         =0;
    gAudioSD_CSI_StationProperties              =0;

    gAudioSD_CSI_ChannelID                      =0;

    for (i=0; i<PRIMARYINFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_PrimaryInformation[i] =0;

    for (i=0; i<SECONDARYINFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_SecondaryInformation[i] =0;
    
    for (i=0; i<TERTIARYINFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_TertiaryInformation[i] =0;

    for (i=0; i<QUATERNARYINFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_QuarternaryInformation[i] =0;

    putvalue(env_ASG_AudioSD_CSI_PInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_TInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_QInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_PType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_TType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_QType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_PID, gAudioSD_CSI_PIID);
    putvalue(env_ASG_AudioSD_CSI_SIS_TA, gAudioSD_CSI_TATP);
    putvalue(env_ASG_AudioSD_CSI_SIS_TA_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_TMC, gAudioSD_CSI_TMC);
    putvalue(env_ASG_AudioSD_CSI_SIS_TMC_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_VICS, gAudioSD_CSI_VICS);
    putvalue(env_ASG_AudioSD_CSI_SIS_VICS_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_IBOC, gAudioSD_CSI_IBOC);
    putvalue(env_ASG_AudioSD_CSI_SIS_IBOC_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit0,gAudioSD_CSI_StationProperties_DABlinked);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit0_s,empty_string);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit1,gAudioSD_CSI_StationProperties_IBOC);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit1_s,empty_string);
    putvalue(env_ASG_AudioSD_CSI_ChannelID,gAudioSD_CSI_ChannelID);
    
    //CurrentStationInfo_Handle
    gAudioSD_CSIhandle_FSGhandle               =0;
    gAudioSD_CSIhandle_FSGhandle_absolutePOS   =0;
    gAudioSD_CSIhandle_PresetListRef           =0;
    gAudioSD_CSIhandle_PresetListabsolutePos   =0;
    gAudioSD_CSIhandle_DABEnsembleHandle       =0;
    gAudioSD_CSIhandle_DABEnsembleAbsPos       =0;

    putvalue(env_ASG_AudioSD_CSH_FSGh,gAudioSD_CSIhandle_FSGhandle);
    putvalue(env_ASG_AudioSD_CSH_FSGh_abs,gAudioSD_CSIhandle_FSGhandle_absolutePOS);
    putvalue(env_ASG_AudioSD_CSH_PL_Ref,gAudioSD_CSIhandle_PresetListRef);
    putvalue(env_ASG_AudioSD_CSH_PL_abs,gAudioSD_CSIhandle_PresetListabsolutePos);
    putvalue(env_ASG_AudioSD_CSH_DAB_E_han,gAudioSD_CSIhandle_DABEnsembleHandle);
    putvalue(env_ASG_AudioSD_CSH_DAB_E_abs,gAudioSD_CSIhandle_DABEnsembleAbsPos);

	//GeneralInfoSwitches
    gAudioSD_GeneralInfoSwitches_OnOffSwitches =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA           =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS            =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic      =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC            =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS           =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online         =0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB            =0;

    gAudioSD_GeneralInfoSwitches_Modification  =0;
    gAudioSD_GeneralInfoSwitches_Modification_TPTA          =0;
    gAudioSD_GeneralInfoSwitches_Modification_RDS           =0;
    gAudioSD_GeneralInfoSwitches_Modification_JPtraffic     =0;
    gAudioSD_GeneralInfoSwitches_Modification_TMC           =0;
    gAudioSD_GeneralInfoSwitches_Modification_VICS          =0;
    gAudioSD_GeneralInfoSwitches_Modification_Online        =0;
    gAudioSD_GeneralInfoSwitches_Modification_DAB           =0;

	putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
	putvalue(env_ASG_AudioSD_GIS_OnOffSw_RD, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_TM, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_VI, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_ON, gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_DAB, gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB);

    putvalue(env_ASG_AudioSD_GIS_Mod_TP, gAudioSD_GeneralInfoSwitches_Modification_TPTA);
    putvalue(env_ASG_AudioSD_GIS_Mod_TP_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_RD, gAudioSD_GeneralInfoSwitches_Modification_RDS);
    putvalue(env_ASG_AudioSD_GIS_Mod_RD_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_JP, gAudioSD_GeneralInfoSwitches_Modification_JPtraffic);
    putvalue(env_ASG_AudioSD_GIS_Mod_JP_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_TM, gAudioSD_GeneralInfoSwitches_Modification_TMC);
    putvalue(env_ASG_AudioSD_GIS_Mod_TM_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_VI, gAudioSD_GeneralInfoSwitches_Modification_VICS);
    putvalue(env_ASG_AudioSD_GIS_Mod_VI_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_ON, gAudioSD_GeneralInfoSwitches_Modification_Online);
    putvalue(env_ASG_AudioSD_GIS_Mod_ON_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_DAB, gAudioSD_GeneralInfoSwitches_Modification_DAB);
    putvalue(env_ASG_AudioSD_GIS_Mod_DAB_s, empty_string);
       
	//TPMemoInfo
    gAudioSD_TPMemoInfo_CurrentMsgNumber   =0;
    gAudioSD_TPMemoInfo_TotalMsgNumber     =0;
    gAudioSD_TPMemoInfo_hour               =0;
    gAudioSD_TPMemoInfo_minute             =0;

    for(i=0; i<STATIONNAME_TEXTLENGTH;i++)
        gAudioSD_TPMemoInfo_StationName[i] =0;

	putvalue(env_ASG_AudioSD_TPMemInfo_CMN, gAudioSD_TPMemoInfo_CurrentMsgNumber);
    putvalue(env_ASG_AudioSD_TPMemInfo_TMN,gAudioSD_TPMemoInfo_TotalMsgNumber);
    putvalue(env_ASG_AudioSD_TPMemInfo_MT_ho,gAudioSD_TPMemoInfo_hour);
    putvalue(env_ASG_AudioSD_TPMemInfo_MT_min,gAudioSD_TPMemoInfo_minute);
    putvalue(env_ASG_AudioSD_TPMemInfo_Name_s, empty_string);

    //AnnouncementInfo
    gAudioSD_AnnouncementInfo_Type         =0;
    
    for (i=0; i<ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
        gAudioSD_AnnouncementInfo_StationName[i] =0;

    putvalue(env_ASG_AudioSD_AnInf_Type_s,empty_string);
    putvalue(env_ASG_AudioSD_AnInf_Name_s,empty_string);
    
	//InfoStates
	gAudioSD_InfoStates_States      =0;

	putvalue(env_ASG_AudioSD_InfoSt_States_s, empty_string);

    //ReceptionListType
    gAudioSD_ReceptionListType_Type =0;

    putvalue(env_ASG_AudioSD_RecListTy_Type_s, empty_string);
    
    //MediaBrowser_FolderLevel
    gAudioSD_MediaBrowser_FL_FolderLevel            =0;
    gAudioSD_MediaBrowser_FL_RefMediaBrowser        =0;    
    gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos =0;

    putvalue(env_ASG_AudioSD_MeBrLevel_FL, gAudioSD_MediaBrowser_FL_FolderLevel);
    putvalue(env_ASG_AudioSD_MeBrLevel_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
    putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);

    //MediaPath
    gAudioSD_MediaPath_FolderType =0;

    for (i=0; i<MEDIAPATH_PATH_TEXTLENGTH; i++)
        gAudioSD_MediaPath_Path[i] =0;

    putvalue(env_ASG_AudioSD_MePath_Type_s, empty_string);
    putvalue(env_ASG_AudioSD_MePath_Path_s, empty_string);

    //PreferredList
    gAudioSD_PreferredList_List =0;

    putvalue(env_ASG_AudioSD_PrefList_List_s, empty_string);

    //SDS_State
    gAudioSD_SDSState_State =0;
    
    putvalue(env_ASG_AudioSD_SDSState_State_s, empty_string);

    //FunctionSynchronisation
    for (i=0; i<8; i++)
        gAudioSD_FunctionSynchronisation_FctList[i] =0;
    
    putvalue(env_ASG_AudioSD_FctSyn_Bit16, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit16_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit17, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit17_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit18, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit18_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit19, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit19_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit20, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit20_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit21, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit21_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit22, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit22_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit23, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit23_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit24, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit24_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit25, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit25_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit26, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit26_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit27, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit27_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit28, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit28_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit29, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit29_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit30, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit30_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit31, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit31_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit32, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit32_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit33, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit33_s, empty_string);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit34, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit34_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit35, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit35_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit36, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit36_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit37, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit37_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit38, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit38_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit39, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit39_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit40, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit40_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit41, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit41_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit42, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit42_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit43, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit43_s, empty_string);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit44, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit44_s, empty_string);

    //ASG_Capabilities
    gAudioSD_ASGCapabilities_PresentationCapabilities       =0;
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0  =0;

    putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
    putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB_s, empty_string);
    
    //Methods
    //DedicatedAudioControl
	gAudioSD_DAC_Result     =0;
	gAudioSD_DAC_CT         =0;
	gAudioSD_DAC_FSGhandle  =0;
    gAudioSD_DAC_LT         =0;
    
    putvalue(env_ASG_AudioSD_DAC_CT,gAudioSD_DAC_CT);
    putvalue(env_ASG_AudioSD_DAC_LT,gAudioSD_DAC_LT);
    putvalue(env_ASG_AudioSD_DAC_FSGHandle,gAudioSD_DAC_FSGhandle);
	putvalue(env_ASG_AudioSD_DAC_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_DAC_Err,0);
    putvalue(env_ASG_AudioSD_DAC_Err_s, empty_string);
    
    //AnnouncementEscape
    gAudioSD_AnnouncementEscape_Result =0;

    putvalue(env_ASG_AudioSD_AnE_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_AnE_Err,0);
    putvalue(env_ASG_AudioSD_AnE_Err_s, empty_string);

    //SwitchSource
    gAudioSD_SwitchSource_Ref       =0;
    gAudioSD_SwitchSource_Result    =0;

    putvalue(env_ASG_AudioSD_SwSource_Ref,gAudioSD_SwitchSource_Ref);
    putvalue(env_ASG_AudioSD_SwSource_Res_s, empty_string);

    putvalue(env_ASG_AudioSD_SwSource_Err,0);
    putvalue(env_ASG_AudioSD_SwSource_Err_s, empty_string);
    
    //MediaBrowserControl
    gAudioSD_MBrC_Control  =0;
    gAudioSD_MBrC_Ref      =0;
    gAudioSD_MBrC_Result   =0;

    putvalue(env_ASG_AudioSD_MBrC_Control, gAudioSD_MBrC_Control);
    putvalue(env_ASG_AudioSD_MBrC_Ref, gAudioSD_MBrC_Ref);
    putvalue(env_ASG_AudioSD_MBrC_Res_s, empty_string);

    putvalue(env_ASG_AudioSD_MBrC_Err,0);
    putvalue(env_ASG_AudioSD_MBrC_Err_s, empty_string);

    //MediaFileInfo
    gAudioSD_MediaFileInfo_Ref      =0;
    gAudioSD_MediaFileInfo_Result   =0;
    
    for (i=0; i<AUDIO_MEDIAFILINFO_ARTIST_LENGTH; i++)
        gAudioSD_MediaFileInfo_Artist_s[i] =0;

    for (i=0; i<AUDIO_MEDIAFILINFO_TITLE_LENGTH; i++)
        gAudioSD_MediaFileInfo_Title_s[i] =0;

    for (i=0; i<AUDIO_MEDIAFILINFO_ALBUM_LENGTH; i++)
        gAudioSD_MediaFileInfo_Album_s[i] =0;

    putvalue(env_ASG_AudioSD_MFI_Ref, gAudioSD_MediaFileInfo_Ref);
    putvalue(env_ASG_AudioSD_MFI_Artist_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Title_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Album_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Res_s, empty_string);

    putvalue(env_ASG_AudioSD_MFI_Err,0);
    putvalue(env_ASG_AudioSD_MFI_Err_s, empty_string);

    //GetNextListPos
    gAudioSD_GetNextListPos_CurrentPos      =0;
    gAudioSD_GetNextListPos_Offset          =0;
    gAudioSD_GetNextListPos_ListType        =0;
    gAudioSD_GetNextListPos_nextPos         =0;
    gAudioSD_GetNextListPos_absoluteListPos =0;

    gAudioSD_GetNextListPos_Result =0;

    putvalue(env_ASG_AudioSD_GNLP_CurrPos,gAudioSD_GetNextListPos_CurrentPos);
    putvalue(env_ASG_AudioSD_GNLP_Offset,gAudioSD_GetNextListPos_Offset);
    putvalue(env_ASG_AudioSD_GNLP_LT,gAudioSD_GetNextListPos_ListType);
    putvalue(env_ASG_AudioSD_GNLP_nextPos,gAudioSD_GetNextListPos_nextPos);
    putvalue(env_ASG_AudioSD_GNLP_AbsPos,gAudioSD_GetNextListPos_absoluteListPos);
    putvalue(env_ASG_AudioSD_GNLP_Res_s,empty_string);
    putvalue(env_ASG_AudioSD_GNLP_Offset, 0);

    putvalue(env_ASG_AudioSD_GNLP_Err,0);
    putvalue(env_ASG_AudioSD_GNLP_Err_s, empty_string);

    //Array's
    //ReceptionList
    gReceptionList_ASGID                =0;
    gReceptionList_TAID                 =0;
    gReceptionList_TotalNumListElements =0;

    gReceptionList_ElementType          =0;
    gReceptionList_ParentID             =0;
    
    for(j=0; j<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; j++)
    {     
        gReceptionList_Pos[j]                               =0;
        gReceptionList_ListEntryReceptionInformation[j]     =0;
        gReceptionList_Type[j]                              =0;
        gReceptionList_Attributes_available_Bit0[j]         =0;
        gReceptionList_Attributes_DVB_Bit1[j]               =0;
        gReceptionList_Attributes_DAB_Bit2[j]               =0;
        gReceptionList_Attributes_DAB_Bit3[j]               =0;
        gReceptionList_Attributes_DAB_Bit4[j]               =0;
        gReceptionList_Attributes_TP_Bit5[j]                =0;
        gReceptionList_Attributes_TMC_Bit6[j]               =0;
        gReceptionList_Attributes_SDARS_Bit7[j]             =0;
        gReceptionList_Attributes_DABserv_Bit8[j]           =0;
        gReceptionList_Attributes_FMOnline_Bit9[j]          =0;
        gReceptionList_Attributes_StationSelect_BitA[j]     =0;
        gReceptionList_Attributes_OnlineRadioMute_BitB[j]   =0;
        gReceptionList_Attributes_StationLinked_BitC[j]     =0;
        gReceptionList_Attributes[j]                        =0;
        gReceptionList_PresetID[j]                          =0;
        gReceptionList_FmRegCode[j]                         =0;
        gReceptionList_Category[j]                          =0;

        for(i=0;i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++)
			gReceptionList_Name[j][i] =0;

        for(i=0;i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++)
			gReceptionList_Frequency[j][i] =0;
    }
    gReceptionList_SlidingWindow_State   =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
    gReceptionList_ListHandlingType      =AUDIO_RECEPTIONLIST_NOCACHE;
    gReceptionList_cacheBuildUp          =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;
    gReceptionList_CallBackReason        =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;

    gReceptionList_cacheDown             =FALSE;
    gReceptionList_cacheUp               =FALSE;
    gReceptionList_LastFirstElement      =0;

    gReceptionList_recordaddress         =0;
    gReceptionList_transmitpos           =FALSE;
    gReceptionList_CursorAction          =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
    gReceptionList_DisplayStatus         =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
    putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
    putvalue(env_ASG_AudioSD_RL_ParentID,gReceptionList_ParentID);
    putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);
    putvalue(env_ASG_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_RL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_RL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_RL_AH_IS, TRUE);
    putvalue(env_ASG_AudioSD_RL_AH_PosTrans, gReceptionList_transmitpos);
    putvalue(env_ASG_AudioSD_RL_AH_RA, gReceptionList_recordaddress);
    putvalue(env_ASG_AudioSD_RL_AH_start, 0);
    putvalue(env_ASG_AudioSD_RL_AH_elements, 3);
    putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_RL_pos_0, 0);
    putvalue(env_ASG_AudioSD_RL_pos_1, 0);
    putvalue(env_ASG_AudioSD_RL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_RL_Type_0, 0);
    putvalue(env_ASG_AudioSD_RL_Type_1, 0);
    putvalue(env_ASG_AudioSD_RL_Type_2, 0);

    putvalue(env_ASG_AudioSD_RL_Type_s_0,empty_string);
    putvalue(env_ASG_AudioSD_RL_Type_s_1,empty_string);
    putvalue(env_ASG_AudioSD_RL_Type_s_2,empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2, empty_string);
            
    putvalue(env_ASG_AudioSD_RL_PrID_0, 0);
    putvalue(env_ASG_AudioSD_RL_PrID_1, 0);
    putvalue(env_ASG_AudioSD_RL_PrID_2, 0);

    putvalue(env_ASG_AudioSD_RL_FmReg_0, 0);
    putvalue(env_ASG_AudioSD_RL_FmReg_1, 0);
    putvalue(env_ASG_AudioSD_RL_FmReg_2, 0);

    putvalue(env_ASG_AudioSD_RL_Cat_0, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_1, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_2, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Cat_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Cat_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Freq_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Freq_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Freq_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_OnOff, FALSE);

    //SourceList
    gSourceList_ASGID                =0;
    gSourceList_TAID                 =0;
    gSourceList_TotalNumListElements =0;
    
    for(j=0; j<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; j++)
    {     
        gSourceList_Pos[j]                               =0;
        gSourceList_ListEntryReceptionInformation[j]     =0;
        gSourceList_SourceType[j]                        =0;
        gSourceList_InstanceID[j]                        =0;
        gSourceList_MediaType[j]                         =0;
        gSourceList_Attributes_BuiltIn_Bit0[j]           =0;
        gSourceList_Attributes_MediaError_Bit1[j]        =0;
        gSourceList_Attributes_MediaPlay_Bit2[j]         =0;
        gSourceList_Attributes_MediaRead_Bit3[j]         =0;
        gSourceList_Attributes_MediaLoad_Bit4[j]         =0;
        gSourceList_Attributes_ImportRun_Bit5[j]         =0;
        gSourceList_Attributes_MediaSupp_Bit6[j]         =0;
        gSourceList_Attributes[j]                        =0;

        for(i=0;i<AUDIO_SOURCELIST_NAME_LENGTH;i++)
			gSourceList_Name[j][i] =0;
    }
    gSourceList_SlidingWindow_State   =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
    gSourceList_ListHandlingType      =AUDIO_SOURCELIST_NOCACHE;
    gSourceList_cacheBuildUp          =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;
    gSourceList_CallBackReason        =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;

    gSourceList_cacheDown             =FALSE;
    gSourceList_cacheUp               =FALSE;
    gSourceList_LastFirstElement      =0;

    gSourceList_recordaddress         =0;
    gSourceList_transmitpos           =FALSE;
    gSourceList_CursorAction          =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
    gSourceList_DisplayStatus         =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_SL_ASGID, gSourceList_ASGID);
    putvalue(env_ASG_AudioSD_SL_TAID, gSourceList_TAID);
    putvalue(env_ASG_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_SL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_SL_AH_IS, TRUE);
    putvalue(env_ASG_AudioSD_SL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_SL_AH_PosTrans, gSourceList_transmitpos);
    putvalue(env_ASG_AudioSD_SL_AH_RA, gSourceList_recordaddress);
    putvalue(env_ASG_AudioSD_SL_AH_start, 0);
    putvalue(env_ASG_AudioSD_SL_AH_elements, 3);
    putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_SL_pos_0, 0);
    putvalue(env_ASG_AudioSD_SL_pos_1, 0);
    putvalue(env_ASG_AudioSD_SL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_SL_SrcType_0, 0);
    putvalue(env_ASG_AudioSD_SL_SrcType_1, 0);
    putvalue(env_ASG_AudioSD_SL_SrcType_2, 0);

    putvalue(env_ASG_AudioSD_SL_SrcType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_SL_SrcType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_SL_SrcType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_SL_IID_0, 0);
    putvalue(env_ASG_AudioSD_SL_IID_1, 0);
    putvalue(env_ASG_AudioSD_SL_IID_2, 0);

    putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2, empty_string);
            
    putvalue(env_ASG_AudioSD_SL_MedType_0, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_1, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_2, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_MedType_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_MedType_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);

    //RadioTVPresetList
    gRadioTVPresetList_ASGID                =0;
    gRadioTVPresetList_TAID                 =0;
    gRadioTVPresetList_TotalNumListElements =0;
    
    for(j=0; j<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; j++)
    {     
        gRadioTVPresetList_Pos[j]                           =0;
        gRadioTVPresetList_ListEntryReceptionInformation[j] =0;
        gRadioTVPresetList_PresetIndex[j]                   =0;
        gRadioTVPresetList_Waveband[j]                      =0;
        gRadioTVPresetList_Attributes_IBOC_Bit0[j]          =0;
        gRadioTVPresetList_Attributes_DABSecServ_Bit1[j]    =0;
        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j]   =0;
        gRadioTVPresetList_Attributes_TP_Bit5[j]            =0;
        gRadioTVPresetList_Attributes_TMC_Bit6[j]           =0;
        gRadioTVPresetList_Attributes_SDRAS_Bit7[j]         =0;
        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j]         =0;
        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j]         =0;
        gRadioTVPresetList_Attributes_OnRadMute_Bit9[j]         =0;
        gRadioTVPresetList_Attributes_StationSelect_Bit8[j]         =0;
        gRadioTVPresetList_Attributes_StationLinked_BitA[j]         =0;
        gRadioTVPresetList_Attributes[j]                    =0;

        for(i=0;i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++)
			gRadioTVPresetList_Name[j][i] =0;
    }
    gRadioTVPresetList_SlidingWindow_State   =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
    gRadioTVPresetList_ListHandlingType      =AUDIO_RADIOTVPRESETLIST_NOCACHE;
    gRadioTVPresetList_cacheBuildUp          =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;
    gRadioTVPresetList_CallBackReason        =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;

    gRadioTVPresetList_cacheDown             =FALSE;
    gRadioTVPresetList_cacheUp               =FALSE;
    gRadioTVPresetList_LastFirstElement      =0;

    gRadioTVPresetList_recordaddress         =0;
    gRadioTVPresetList_transmitpos           =FALSE;
    gRadioTVPresetList_CursorAction          =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
    gRadioTVPresetList_DisplayStatus         =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
    putvalue(env_ASG_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
    putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_RTPL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_IS, FALSE);
    putvalue(env_ASG_AudioSD_RTPL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_RTPL_AH_PosTrans, gRadioTVPresetList_transmitpos);
    putvalue(env_ASG_AudioSD_RTPL_AH_RA, gRadioTVPresetList_recordaddress);
    putvalue(env_ASG_AudioSD_RTPL_AH_start, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_elements, 3);
    putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_pos_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_pos_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_RTPL_PI_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_PI_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_PI_2, 0);

    putvalue(env_ASG_AudioSD_RTPL_WB_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_WB_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_WB_2, 0);

    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,empty_string);
    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,empty_string);
    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_OnOff, FALSE);

    //TpMemoList
    gTpMemoList_ASGID                =0;
    gTpMemoList_TAID                 =0;
    gTpMemoList_TotalNumListElements =0;
    
    for(j=0; j<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; j++)
    {     
        gTpMemoList_Pos[j]                           =0;
        gTpMemoList_ListEntryReceptionInformation[j] =0;
   
        gTpMemoList_Attributes_NewMessage_Bit0[j]    =0;
        gTpMemoList_Attributes[j]                    =0;

        gTpMemoList_Hour[j]                          =0;
        gTpMemoList_Minute[j]                        =0;

        for(i=0;i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++)
			gTpMemoList_StationName[j][i] =0;
    }
    gTpMemoList_SlidingWindow_State   =AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE;
    gTpMemoList_ListHandlingType      =AUDIO_TPMEMOLIST_NOCACHE;
    gTpMemoList_cacheBuildUp          =AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE;
    gTpMemoList_CallBackReason        =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;

    gTpMemoList_cacheDown             =FALSE;
    gTpMemoList_cacheUp               =FALSE;
    gTpMemoList_LastFirstElement      =0;

    gTpMemoList_recordaddress         =0;
    gTpMemoList_transmitpos           =FALSE;
    gTpMemoList_CursorAction          =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
    gTpMemoList_DisplayStatus         =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_TML_ASGID, gTpMemoList_ASGID);
    putvalue(env_ASG_AudioSD_TML_TAID, gTpMemoList_TAID);
    putvalue(env_ASG_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_TML_AH_shift, 0);
    putvalue(env_ASG_AudioSD_TML_AH_IS, FALSE);
    putvalue(env_ASG_AudioSD_TML_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_TML_AH_PosTrans, gTpMemoList_transmitpos);
    putvalue(env_ASG_AudioSD_TML_AH_RA, gTpMemoList_recordaddress);
    putvalue(env_ASG_AudioSD_TML_AH_start, 0);
    putvalue(env_ASG_AudioSD_TML_AH_elements, 3);
    putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_TML_pos_0, 0);
    putvalue(env_ASG_AudioSD_TML_pos_1, 0);
    putvalue(env_ASG_AudioSD_TML_pos_2, 0);

    putvalue(env_ASG_AudioSD_TML_At_bit0_0, 0);
    putvalue(env_ASG_AudioSD_TML_At_bit0_1, 0);
    putvalue(env_ASG_AudioSD_TML_At_bit0_2, 0);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_TML_Hour_0, 0);
    putvalue(env_ASG_AudioSD_TML_Hour_1, 0);
    putvalue(env_ASG_AudioSD_TML_Hour_2, 0);

    putvalue(env_ASG_AudioSD_TML_Minute_0, 0);
    putvalue(env_ASG_AudioSD_TML_Minute_1, 0);
    putvalue(env_ASG_AudioSD_TML_Minute_2, 0);

    putvalue(env_ASG_AudioSD_TML_StName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_TML_StName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_TML_StName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_TML_OnOff, FALSE);

    //MediaBrowser
    gMediaBrowser_ASGID                =0;
    gMediaBrowser_TAID                 =0;
    gMediaBrowser_TotalNumListElements =0;
    gMediaBrowser_ActiveListPos        =0;
    
    for(j=0; j<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; j++)
    {     
        gMediaBrowser_Pos[j]                                =0;
        gMediaBrowser_ListEntryReceptionInformation[j]      =0;
        gMediaBrowser_FileType[j]                           =0;
        gMediaBrowser_FileState_emptyFolder_Bit0[j]         =0;
        gMediaBrowser_FileState_DRM_Bit1[j]                 =0;
        gMediaBrowser_FileState_FileCorrupted_Bit2[j]       =0;
        gMediaBrowser_FileState_DeadLink_Bit3[j]            =0;
        gMediaBrowser_FileState_ImportFinished_Bit4[j]      =0;
        gMediaBrowser_FileState_ImportPending_Bit5[j]       =0;
        gMediaBrowser_FileState_ImportPlayable_Bit6[j]      =0;
        gMediaBrowser_FileState[j]                          =0;

        for(i=0;i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++)
			gMediaBrowser_FileName[j][i] =0;
    }

    gMediaBrowser_SlidingWindow_State   =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
    gMediaBrowser_ListHandlingType      =AUDIO_MEDIABROWSER_NOCACHE;
    gMediaBrowser_cacheBuildUp          =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;
    gMediaBrowser_CallBackReason        =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;

    gMediaBrowser_cacheDown             =FALSE;
    gMediaBrowser_cacheUp               =FALSE;
    gMediaBrowser_LastFirstElement      =0;

    gMediaBrowser_recordaddress         =0;
    gMediaBrowser_transmitpos           =FALSE;
    gMediaBrowser_CursorAction          =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
    gMediaBrowser_DisplayStatus         =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
    putvalue(env_ASG_AudioSD_MB_TAID, gMediaBrowser_TAID);
    putvalue(env_ASG_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);
    putvalue(env_ASG_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
    putvalue(env_ASG_AudioSD_MB_AH_shift, 0);
    putvalue(env_ASG_AudioSD_MB_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_MB_AH_IS, TRUE);
    putvalue(env_ASG_AudioSD_MB_AH_PosTrans, gMediaBrowser_transmitpos);
    putvalue(env_ASG_AudioSD_MB_AH_RA, gMediaBrowser_recordaddress);
    putvalue(env_ASG_AudioSD_MB_AH_start, 0);
    putvalue(env_ASG_AudioSD_MB_AH_elements, 3);
    putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_MB_pos_0, 0);
    putvalue(env_ASG_AudioSD_MB_pos_1, 0);
    putvalue(env_ASG_AudioSD_MB_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_MB_FileType_0, 0);
    putvalue(env_ASG_AudioSD_MB_FileType_1, 0);
    putvalue(env_ASG_AudioSD_MB_FileType_2, 0);

    putvalue(env_ASG_AudioSD_MB_FileType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_MB_FileType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_MB_FileType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit0_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit0_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit0_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit1_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit1_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit1_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit2_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit2_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit2_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit3_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit3_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit3_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit4_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit4_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit4_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit5_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit5_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit5_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit6_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit6_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit6_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FileName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FileName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FileName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_OnOff, FALSE);


    // ---- Propertys / Methode / Array from DF 4.1


    // 0x2D
    @sysvar::ASG_AudioSD::SwRaMe_Source             = 0;
    @sysvar::ASG_AudioSD::SwRaMe_Sourcehex          = 0;
    @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe           = 0;
    @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex        = 0;
    gSwRaMe_SourceAct                               = 0;
    gSwRaMe_SwRaMeReAct                             = 0;
    tempSwRaMe1                                     = 0;
    tempSwRaMe2                                     = 0;

    // 0x2E
    @sysvar::ASG_AudioSD::MeImSe_InID               = 0;
    @sysvar::ASG_AudioSD::MeImSe_ST                 = 0;
    @sysvar::ASG_AudioSD::MeImSe_State0             = 1;
    @sysvar::ASG_AudioSD::MeImSe_State1             = 0;
    @sysvar::ASG_AudioSD::MeImSe_SThex              = 0;

    // 0x31
    @sysvar::ASG_AudioSD::OnMuSt_BuLvl              = 0;
    @sysvar::ASG_AudioSD::OnMuSt_State              = 0;
    @sysvar::ASG_AudioSD::OnMuSt_Statehex           = 0;
    
    // 0x30
    @sysvar::ASG_AudioSD::CuDoSt_CuDoSt             = 0;
    @sysvar::ASG_AudioSD::CuDoSt_CuDoSthex          = 0;
    @sysvar::ASG_AudioSD::CuDoSt_PCD                = 0;
    
    // 0x33
    @sysvar::ASG_AudioSD::CuStHa2_CoList            = 0;
    @sysvar::ASG_AudioSD::CuStHa2_CoListAbPo        = 0;
    @sysvar::ASG_AudioSD::CuStHa2_CoListAbPohex     = 0;
    @sysvar::ASG_AudioSD::CuStHa2_CoListhex         = 0;
    
    // 0x2F
    @sysvar::ASG_AudioSD::CuVoEx_CVT                = 0;
    @sysvar::ASG_AudioSD::CuVoEx_CVThex             = 0;
    @sysvar::ASG_AudioSD::CuVoEx_GenVol             = 0;
    @sysvar::ASG_AudioSD::CuVoEx_MaxVol             = 0;
    @sysvar::ASG_AudioSD::CuVoEx_VolS0              = 1;
    @sysvar::ASG_AudioSD::CuVoEx_VolS1              = 0;

    // 0x32

    @sysvar::ASG_AudioSD::ComList_actListPos            = 0;
    @sysvar::ASG_AudioSD::ComList_ASG_ID                = 0;
    @sysvar::ASG_AudioSD::ComList_direction_b           = 0;
    @sysvar::ASG_AudioSD::ComList_direction_f           = 1;
    @sysvar::ASG_AudioSD::ComList_elements              = 5;
    @sysvar::ASG_AudioSD::ComList_indexSize_8bit        = 1;
    @sysvar::ASG_AudioSD::ComList_indexSize_16bit       = 0;
    @sysvar::ASG_AudioSD::ComList_recordaddress         = 1;
    @sysvar::ASG_AudioSD::ComList_shift_1               = 0;
    @sysvar::ASG_AudioSD::ComList_shift_0               = 1;
    @sysvar::ASG_AudioSD::ComList_start                 = 0;
    @sysvar::ASG_AudioSD::ComList_TAID                  = 1;
    @sysvar::ASG_AudioSD::ComList_TNLE                  = 0;
    @sysvar::ASG_AudioSD::ComList_transmitPos_0         = 0;
    @sysvar::ASG_AudioSD::ComList_transmitPos_1         = 1;
    sysSetVariableString(sysvar::ASG_AudioSD::ComList_FRUreseved," ");

    //SiriusAlertList
    gSiriusAlertList_ASGID                =0;
    gSiriusAlertList_TAID                 =0;
    gSiriusAlertList_TotalNumListElements =0;
    
    for(j=0; j<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; j++)
    {     
        gSiriusAlertList_Pos[j]                             =0;
        gSiriusAlertList_ListEntryReceptionInformation[j]   =0;
        gSiriusAlertList_AlertType[j]                       =0;
        gSiriusAlertList_Attributes_Bit0[j]                 =0;
        gSiriusAlertList_Attributes_Bit1[j]                 =0;
        gSiriusAlertList_Attributes_Bit2[j]                 =0;
        gSiriusAlertList_Attributes_Bit3[j]                 =0;
        gSiriusAlertList_Attributes_Bit4[j]                 =0;
        gSiriusAlertList_Attributes_Bit5[j]                 =0;
        gSiriusAlertList_Attributes_Bit6[j]                 =0;
        gSiriusAlertList_Attributes[j]                      =0;
        gSiriusAlertList_PresetID[j]                        =0;

        for(i=0;i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++)
			    gSiriusAlertList_Name[j][i] =0;

        for(i=0;i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++)
			    gSiriusAlertList_Frequency[j][i] =0;
        
        for(i=0;i<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;i++)
			    gSiriusAlertList_AlertName[j][i] =0;

        for(i=0;i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++)
			    gSiriusAlertList_Extension[j][i] =0;
    }
    gSiriusAlertList_SlidingWindow_State   =AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE;
    gSiriusAlertList_ListHandlingType      =AUDIO_SIRIUSALERTLIST_NOCACHE;
    gSiriusAlertList_cacheBuildUp          =AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE;
    gSiriusAlertList_CallBackReason        =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;

    gSiriusAlertList_cacheDown             =FALSE;
    gSiriusAlertList_cacheUp               =FALSE;
    gSiriusAlertList_LastFirstElement      =0;

    gSiriusAlertList_recordaddress         =0;
    gSiriusAlertList_transmitpos           =FALSE;
    gSiriusAlertList_CursorAction          =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
    gSiriusAlertList_DisplayStatus         =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;

    putvalue(env_ASG_AudioSD_SAL_ASGID, gSiriusAlertList_ASGID);
    putvalue(env_ASG_AudioSD_SAL_TAID, gSiriusAlertList_TAID);
    putvalue(env_ASG_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_SAL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_SAL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_SAL_AH_IS, TRUE);
    putvalue(env_ASG_AudioSD_SAL_AH_PosTrans, gSiriusAlertList_transmitpos);
    putvalue(env_ASG_AudioSD_SAL_AH_RA, gSiriusAlertList_recordaddress);
    putvalue(env_ASG_AudioSD_SAL_AH_start, 0);
    putvalue(env_ASG_AudioSD_SAL_AH_elements, 3);
    //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_SAL_pos_0, 0);
    putvalue(env_ASG_AudioSD_SAL_pos_1, 0);
    putvalue(env_ASG_AudioSD_SAL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_SAL_AType_0, 0);
    putvalue(env_ASG_AudioSD_SAL_AType_1, 0);
    putvalue(env_ASG_AudioSD_SAL_AType_2, 0);

    putvalue(env_ASG_AudioSD_SAL_AType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_SAL_AType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_SAL_AType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_PrID_0, 0);
    putvalue(env_ASG_AudioSD_SAL_PrID_1, 0);
    putvalue(env_ASG_AudioSD_SAL_PrID_2, 0);

    putvalue(env_ASG_AudioSD_SAL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Freq_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Freq_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Freq_s_2, empty_string);
    
    putvalue(env_ASG_AudioSD_SAL_AName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_AName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_AName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Ext_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Ext_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Ext_s_2, empty_string);
    
    putvalue(env_ASG_AudioSD_SAL_OnOff, FALSE);
    
    //PlayPosition
    gAudioSD_PlayPosition_TimePosition = 0;
    gAudioSD_PlayPosition_TotalPlayTime = 0;
    gAudioSD_PlayPosition_Attributes = 0;
    gAudioSD_PlayPosition_Attributes_Bit0 = 0;
    gAudioSD_PlayPosition_BufferLevel = 0;

    putvalue(env_ASG_AudioSD_PP_TimePos, gAudioSD_PlayPosition_TimePosition);
    putvalue(env_ASG_AudioSD_PP_TotalPlayTime, gAudioSD_PlayPosition_TotalPlayTime);
    putvalue(env_ASG_AudioSD_PP_Attr_Bit0, gAudioSD_PlayPosition_Attributes_Bit0);
    putvalue(env_ASG_AudioSD_PP_BufferLevel, gAudioSD_PlayPosition_BufferLevel);
    
    //SDS_RecognizerState
    gAudioSD_SDS_RecognizerState_InputLevel = 0;
    gAudioSD_SDS_RecognizerState_InputQuality = 0;
    gAudioSD_SDS_RecognizerState_Extension1 = 0;
    gAudioSD_SDS_RecognizerState_Extension2 = 0;
    gAudioSD_SDS_RecognizerState_Extension3 = 0;
    gAudioSD_SDS_RecognizerState_Extension4 = 0;

    putvalue(env_ASG_AudioSD_SRS_InputLevel, gAudioSD_SDS_RecognizerState_InputLevel);
    putvalue(env_ASG_AudioSD_SRS_InputQuality, gAudioSD_SDS_RecognizerState_InputQuality);
    
    //CurrentStationInfo2
    for(i=0;i<CSI2_INFORMATION_TEXTLENGTH;i++)
    {
		  gAudioSD_CSI2_Information1[i] =0;
      gAudioSD_CSI2_Information2[i] =0;
      gAudioSD_CSI2_Information3[i] =0;
      gAudioSD_CSI2_Information4[i] =0;
      gAudioSD_CSI2_Information5[i] =0;
      gAudioSD_CSI2_Information6[i] =0;
      gAudioSD_CSI2_Information7[i] =0;
      gAudioSD_CSI2_Information8[i] =0;
    }
    gAudioSD_CSI2_InfoType1 = 0;
    gAudioSD_CSI2_InfoType2 = 0;
    gAudioSD_CSI2_InfoType3 = 0;
    gAudioSD_CSI2_InfoType4 = 0;
    gAudioSD_CSI2_InfoType5 = 0;
    gAudioSD_CSI2_InfoType6 = 0;
    gAudioSD_CSI2_InfoType7 = 0;
    gAudioSD_CSI2_InfoType8 = 0;
    gAudioSD_CSI2_InfoID1 = 0;
    gAudioSD_CSI2_ChannelID = 0;
    gAudioSD_CSI2_StationInfoSwitches = 0;
    gAudioSD_CSI2_StationInfoSwitches_Bit0 = 0;
    gAudioSD_CSI2_StationInfoSwitches_Bit1 = 0;
    gAudioSD_CSI2_StationInfoSwitches_Bit2 = 0;
    gAudioSD_CSI2_StationInfoSwitches_Bit3 = 0;
    gAudioSD_CSI2_StationInfoSwitches_Bit4 = 0;
    gAudioSD_CSI2_StationProperties = 0;
    gAudioSD_CSI2_StationProperties_Bit0 = 0;
    gAudioSD_CSI2_StationProperties_Bit1 = 0;
    gAudioSD_CSI2_StationProperties_Bit2 = 0;
    gAudioSD_CSI2_StationProperties_Bit3 = 0;
    gAudioSD_CSI2_StationProperties_Bit4 = 0;
    gAudioSD_CSI2_StationProperties_Bit5 = 0;
    gAudioSD_CSI2_StationProperties_Bit6 = 0;

    putvalue(env_ASG_AudioSD_CSI2_Info1, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info2, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info3, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info4, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info5, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info6, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info7, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info8, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_InfoID1, gAudioSD_CSI2_InfoID1);
    putvalue(env_ASG_AudioSD_CSI2_ChanID, gAudioSD_CSI2_ChannelID);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy1, gAudioSD_CSI2_InfoType1);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy2, gAudioSD_CSI2_InfoType2);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy3, gAudioSD_CSI2_InfoType3);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy4, gAudioSD_CSI2_InfoType4);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy5, gAudioSD_CSI2_InfoType5);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy6, gAudioSD_CSI2_InfoType6);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy7, gAudioSD_CSI2_InfoType7);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy8, gAudioSD_CSI2_InfoType8);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0, gAudioSD_CSI2_StationInfoSwitches_Bit0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1, gAudioSD_CSI2_StationInfoSwitches_Bit1);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2, gAudioSD_CSI2_StationInfoSwitches_Bit2);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3, gAudioSD_CSI2_StationInfoSwitches_Bit3);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4, gAudioSD_CSI2_StationInfoSwitches_Bit4);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit0, gAudioSD_CSI2_StationProperties_Bit0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit1, gAudioSD_CSI2_StationProperties_Bit1);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit2, gAudioSD_CSI2_StationProperties_Bit2);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit3, gAudioSD_CSI2_StationProperties_Bit3);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit4, gAudioSD_CSI2_StationProperties_Bit4);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit5, gAudioSD_CSI2_StationProperties_Bit5);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit6, gAudioSD_CSI2_StationProperties_Bit6);
    
    //CurrentStation_Handle3
    gAudioSD_CurrentStation_Handle3_FavList     = 0;
    gAudioSD_CurrentStation_Handle3_FavListaP   = 0;
    gAudioSD_CurrentStation_Handle3_Extension1  = 0;
    gAudioSD_CurrentStation_Handle3_Extension2  = 0;
    gAudioSD_CurrentStation_Handle3_Extension3  = 0;
    gAudioSD_CurrentStation_Handle3_Extension4  = 0;

    putvalue(env_ASG_AudioSD_CSH3_FavList, gAudioSD_CurrentStation_Handle3_FavList);
    putvalue(env_ASG_AudioSD_CSH3_FLaP, gAudioSD_CurrentStation_Handle3_FavListaP);
    putvalue(env_ASG_AudioSD_CSH3_Extension1, gAudioSD_CurrentStation_Handle3_Extension1);
    putvalue(env_ASG_AudioSD_CSH3_Extension2, gAudioSD_CurrentStation_Handle3_Extension2);
    putvalue(env_ASG_AudioSD_CSH3_Extension3, gAudioSD_CurrentStation_Handle3_Extension3);
    putvalue(env_ASG_AudioSD_CSH3_Extension4, gAudioSD_CurrentStation_Handle3_Extension4);
    
    
    //SiriusAlertInfo
    for(i=0;i<SAI_ALERTNAME_TEXTLENGTH;i++)
      gAudioSD_SAI_AlertName[i] =0;
    for(i=0;i<SAI_STATIONNAME_TEXTLENGTH;i++)
      gAudioSD_SAI_StationName[i] =0; 
    gAudioSD_SAI_AlertType = 0;
    gAudioSD_SAI_SALref = 0;
    gAudioSD_SAI_Extension1 = 0;
    gAudioSD_SAI_Extension2 = 0;
    gAudioSD_SAI_Extension3 = 0;

    putvalue(env_ASG_AudioSD_SAI_AlertName, empty_string);
    putvalue(env_ASG_AudioSD_SAI_StatName, empty_string);
    putvalue(env_ASG_AudioSD_SAI_AlertType, 0);
    putvalue(env_ASG_AudioSD_SAI_SALref, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension1, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension2, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension3, 0);
    
    //Station_Track_Switch
    gAudioSD_Station_Track_Switch_Event = 0;
    gAudioSD_Station_Track_Switch_Direction = 0;
    gAudioSD_Station_Track_Switch_PlayState = 0;
    gAudioSD_Station_Track_Switch_Extension1 = 0;
    gAudioSD_Station_Track_Switch_Extension2 = 0;
    gAudioSD_Station_Track_Switch_Extension3  = 0;
    gAudioSD_Station_Track_Switch_Extension4  = 0;
    gAudioSD_Station_Track_Switch_Extension5  = 0;

    putvalue(env_ASG_AudioSD_STS_Event, 0);
    putvalue(env_ASG_AudioSD_STS_Direction, 0);
    putvalue(env_ASG_AudioSD_STS_PlayState, 0);
    putvalue(env_ASG_AudioSD_STS_Extension1, 0);
    putvalue(env_ASG_AudioSD_STS_Extension2, 0);
    putvalue(env_ASG_AudioSD_STS_Extension3, 0);
    putvalue(env_ASG_AudioSD_STS_Extension4, 0);
    putvalue(env_ASG_AudioSD_STS_Extension5, 0);
    
    //-----------------------------------------------------------------
    //--------------------0x3E Picture
    putvalue(env_ASG_AudioSD_Pic_AH_PosTrans,1);
    
    //--------------------0x38 LastStationList
    putvalue(env_ASG_AudioSD_LSL_AH_PosTrans,1);
    
    //--------------------0x3B FavoriteList
    putvalue(env_ASG_AudioSD_FL_AH_PosTrans,1);
}

BAP_Indication(int datalength)
{
    switch(gBAP_Indication[0])
	{
	    case LSG_AudioSD:
		        AudioSD_functions(datalength); 
	     break;

		default:
		    write("error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0]);
	}
}

AudioSD_functions (int datalength)	
{
int i=0;

	switch (gBAP_Indication[1]) // function-ID
    {
		case FctID_GetAll:		
            GetAll_Indication(gBAP_Indication, datalength);
		break;
		case FctID_BAP_Config:
			BAP_Config_Indication(gBAP_Indication, datalength);
		break;
		case FctID_FunctionList:
			FunctionList_Indication(gBAP_Indication, datalength);
		break;
		case FctID_HeartBeat:
			HeartBeat_Indication(gBAP_Indication, datalength);
		break;
		case FctID_FSG_Setup:
			FSG_Setup_Indication(gBAP_Indication, datalength);
		break;
		case FctID_FSG_OperationState:
			FSG_OperationState_Indication(gBAP_Indication, datalength);
		break;
		case FctID_ActiveSource:
			activeSource_Indication(gBAP_Indication, datalength);
		break;
		case FctID_ActiveSourceName:
			activeSourceName_Indication(gBAP_Indication, datalength);
		break;
		case FctID_CurrentVolume:
			currentVolume_Indication(gBAP_Indication, datalength);
		break;
		case FctID_Mute:
			Mute_Indication(gBAP_Indication, datalength);
		break;
		case FctID_SourceState:
			SourceState_Indication(gBAP_Indication, datalength);
		break;
		case FctID_CurrentStationInfo:
			CurrentStationInfo_Indication(gBAP_Indication, datalength);
		break;
        case FctID_CurrentStation_Handle:
			CurrentStationHandle_Indication(gBAP_Indication, datalength);
		break;        
        case FctID_ReceptionList:
			ReceptionList_Indication(gBAP_Indication, datalength);
		break;
		case FctID_DedicatedAudioControl:
			DedicatedAudioControl_Indication(gBAP_Indication, datalength);
		break;
		case FctID_GeneralInfoSwitches:
			GeneralInfoSwitches_Indication(gBAP_Indication, datalength);
		break;
		case FctID_TPMemoInfo:
			TPMemoInfo_Indication(gBAP_Indication, datalength);
		break;
        case FctID_TPMemoList:
			TPMemoList_Indication(gBAP_Indication, datalength);
		break;
		case FctID_AnnouncementInfo:
			AnnouncementInfo_Indication(gBAP_Indication, datalength);
		break;
		case FctID_AnnouncementEscape:
			AnnouncementEscape_Indication(gBAP_Indication, datalength);
		break;
		case FctID_InfoStates:
			InfoStates_Indication(gBAP_Indication, datalength);
		break;
        case FctID_ReceptionListType:
			ReceptionListType_Indication(gBAP_Indication, datalength);
		break;
        case FctID_RadioTV_PresetList:
			RadioTVPresetList_Indication(gBAP_Indication, datalength);
		break;
        case FctID_SourceList:
			SourceList_Indication(gBAP_Indication, datalength);
		break;
        case FctID_SwitchSource:
			SwitchSource_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaBrowser_FolderLevel:
			MediaBrowserFolderLevel_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaBrowser:
			MediaBrowser_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaPath:
			MediaPath_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaBrowserControl:
			MediaBrowserControl_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaFileInfo:
			MediaFileInfo_Indication(gBAP_Indication, datalength);
		break;
        case FctID_PreferredList:
			PreferredList_Indication(gBAP_Indication, datalength);
		break;
        case FctID_SDS_State:
			SDSState_Indication(gBAP_Indication, datalength);
		break;
        case FctID_FunctionSynchronisation:
			FunctionSynchronisation_Indication(gBAP_Indication, datalength);
		break;
        case FctID_ASG_Capabilities:
			ASGCapabilities_Indication(gBAP_Indication, datalength);
		break;
        case FctID_GetNextListPos:
			GetNextListPos_Indication(gBAP_Indication, datalength);
		break;
        case FctID_SwitchRadioMedia:
			SwitchRadioMedia_Indication(gBAP_Indication, datalength);
		break;
        case FctID_MediaImportState:
			MediaImportState_Indication(gBAP_Indication, datalength);
		break;
        case FctID_CurrentVolumeExtended:
			CurrentVolumeExtended_Indication(gBAP_Indication, datalength);
		break;
        case FctID_CustomerDownloadState:
			CustomerDownloadState_Indication(gBAP_Indication, datalength);
		break;
        case FctID_OnlineMusic_State:
			OnlineMusic_State_Indication(gBAP_Indication, datalength);
		break;
    /*    
    case FctID_CommonList:
			CommonList_Indication(gBAP_Indication, datalength);
		break;
      */
    case FctID_SiriusAlertList:
      SiriusAlertList_Indication(gBAP_Indication, datalength);
    break;
    case FctID_CurrentStation_Handle2:
			CurrentStation_Handle2_Indication(gBAP_Indication, datalength);
		break;
    case FctID_PlayPosition:
        PlayPosition_Indication(gBAP_Indication, datalength);
    break;
    case FctID_SDS_RecognizerState:
        SDS_RecognizerState_Indication(gBAP_Indication, datalength);
    break;
    case FctID_CurrentStationInfo2:
        SDS_RecognizerState_Indication(gBAP_Indication, datalength);
    break;
    case FctID_CurrentStation_Handle3:
        CurrentStation_Handle3_Indication(gBAP_Indication, datalength);
    break;
    case FctID_LastStationList:
        LastStationList_Indication(gBAP_Indication, datalength);
    break;
    case FctID_SiriusAlertInfo:
        SiriusAlertInfo_Indication(gBAP_Indication, datalength);
    break;
    case FctID_Picture:
        Picture_Indication(gBAP_Indication, datalength);
    break;
    case FctID_FavoriteList:
        FavoriteList_Indication(gBAP_Indication, datalength);
    break;
    case FctID_Station_Track_Switch:
        Station_Track_Switch_Indication(gBAP_Indication, datalength);
    break;
		default:
			write("ASG_functions: unknown funcion-ID %x", gBAP_Indication[1]);
		break;
	}	
}

set_status_requestbuffer (dword Request_array [], int length, byte BAPDataType)
{
	int bufferline = 0, i;

	bufferline = get_requestbuffer_line();

	for(i = 0; i < length; i++)
		gBAP_Request[bufferline][i] = Request_array[i];

	gBAP_Requestbuffer_status[bufferline] = length;
	gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}

byte get_requestbuffer_line()	//function to reserve memory in request-ring-buffer
{
	int line;

	//init lokal variables
	line=0;
	//********************	
	
	line=gwrite_requestbuffer_line;							//next free element in ring-buffer
	if(gwrite_requestbuffer_line<(REQUESTBUFFER_LINES-1))	//last element of ring-buffer is not reached
		gwrite_requestbuffer_line++;
	else													//last element of ring-buffer is reached
		gwrite_requestbuffer_line=0;
	
    return (line);											//return position of free ring-buffer element
}

on timer TaskTimer
{

	Bap180_Task(NODE_INDEX);	//DLL-Task

	BAP_DLL_Indication();
	
	BAP_DLL_Request();
	
	BAP_CAN_TX_Request();

	setTimer(TaskTimer, 10);    //restart real CAN-communication timer

}

BAP_Config_Indication(dword Indication_array [], int datalength)
{ 

    switch (gBAP_Indication[2]) // indication
	{
		case Reset_IND:         
			            init_variables();				//reset all variables and states				
                        gBAP_AudioSD_available =TRUE;   //FSG available
                        
                        if(getvalue(env_ASG_AudioSD_BAPstart_GetAll))
                        {
                            FunctionList_Request(DataGet_REQ);
                            FunctionList_flag =TRUE;
                        }                                               
		 break;
		
        case Data_IND:  
			            gBAP_AudioSD_available =TRUE;   //FSG available
                        
                        if(getvalue(env_ASG_AudioSD_BAPstart_GetAll))                       
                        {
                            FunctionList_Request(DataGet_REQ);
                            FunctionList_flag =TRUE;
                        }                
		 break;
		
        case Error_IND:			            	            			            
				        if(Indication_array[3]<0x20 && Indication_array[3] !=0)			//BCL-error
					        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				        else if(Indication_array[3]<0x30)			//BPL-error
					        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				        else if(Indication_array[3]<0x40)			//BAL-error
					        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				        else
					        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: Application-Error: 0x%x", Indication_array[3]);			            	
		 break;
		
        default:
			    writelineEx(gError_Trace, 0,"ASG-AudioSD BAP_Config_Indication: unknown indication 0x%x", gBAP_Indication[2]);
		break;
	}
}

GetAll_Indication(dword Indication_array [], int datalength)
{
    switch (gBAP_Indication[2])
	  {
		    case Data_IND: 
                FunctionList_Request(DataGet_REQ);
	              HeartBeat_Request(DataGet_REQ);
                FSG_Setup_Request(DataGet_REQ);
                FSG_OperationState_Request(DataGet_REQ);
	              activeSource_Request(DataGet_REQ);
                activeSourceName_Request(DataGet_REQ);
                currentVolume_Request(DataGet_REQ);
                Mute_Request(DataGet_REQ);
                SourceState_Request(DataGet_REQ);
                CurrentStationInfo_Request(DataGet_REQ);
                CurrentStationHandle_Request(DataGet_REQ);
                generalInfoSwitches_Request(DataGet_REQ);
                TPMemoInfo_Request(DataGet_REQ);
                AnnouncementInfo_Request(DataGet_REQ);  
                InfoStates_Request(DataGet_REQ);
                ReceptionListType_Request(DataGet_REQ);
                MediaBrowserFolderLevel_Request(DataGet_REQ);          
                MediaPath_Request(DataGet_REQ);
                PreferredList_Request(DataGet_REQ);
                SDSState_Request(DataGet_REQ);
                FunctionSynchronisation_Request(DataGet_REQ);
                ASGCapabilities_Request(DataGet_REQ);
                MediaImportState_Request(DataGet_REQ);
                CurrentVolumeExtended_Request(DataGet_REQ);
                CustomerDownloadState_Request(DataGet_REQ);
                OnlineMusic_State_Request(DataGet_REQ);
                CurrentStation_Handle2_Request(DataGet_REQ);
                PlayPosition_Request(DataGet_REQ);
                SDS_RecognizerState_Request(DataGet_REQ);
                CurrentStationInfo2_Request(DataGet_REQ);
                CurrentStation_Handle3_Request(DataGet_REQ);
                SiriusAlertInfo_Request(DataGet_REQ);
                Station_Track_Switch_Request(DataGet_REQ);
                
                settimer (ASGCapa_startTimer,30);
        break;
        case Error_IND:						
  				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  				else if(Indication_array[3]<0x30)			//BPL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  				else if(Indication_array[3]<0x40)			//BAL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  				else
  					writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: Application-Error: 0x%x", Indication_array[3]);
    		break;
    		default:
    			write("ASG-AudioSD GetAll_Indication: unknown indication 0x%d", gBAP_Indication[0]);
    		break;
	  }
}

GetAll_Request(byte request)
{
    int i;
	dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables.
	for(i=0;i<BAP_BUFFER_SIZE;i++)
		requestarray [i]=0;

    // Handle request
    requestarray[0]=LSG_AudioSD;	//LSG-ID
	requestarray[1]=FctID_GetAll;	//Fct.-ID
    requestarray[2]=request;        //request

	switch (request)
	{
		case DataGet_REQ:					
			set_status_requestbuffer (requestarray, 3, Bap_Void);	//send GetAll.Get
		
        break;
		
        default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD GetAll_Request: unknown request %d", request);
		break;
	}
}

on envVar env_ASG_PowerOnOff
{
    int length, temp;

	putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff [getvalue(this)]);	

	if(getvalue(this)==1)
	{
		if(gBAP_Init==0)
		{
			gBAP_Init=1;
			//BAP-Init ASG
			temp=Bap180_Init(NODE_INDEX,LSG_AudioSD);
		 	if(temp==0)
				write("ASG-AudioSD BAP_Init successful ");
			else
				write("ASG-AudioSD error BAP_Init: %d", temp);

		}

		init_variables();							//initialize variables

		//BAP-Start ASG
		temp =Bap180_Start(NODE_INDEX,LSG_AudioSD);
		if(temp==0)
			write("ASG-AudioSD BAP_Start successful ");
		else
			write("ASG-AudioSD error BAP_Start: %d", temp);

		settimer(Powerontimer, 20);

	}
	else
	{
		temp =Bap180_Shutdown(NODE_INDEX,LSG_AudioSD);

        if(temp==0)
			write("ASG-AudioSD BAP_Shutdown successful ");
		else
			write("ASG-AudioSD error BAP_Shutdown: %d", temp);

		gASG_PowerOnOff =getvalue(this);

		Shutdown_AudioSD();
	}
}

Shutdown_AudioSD ()
{   
    canceltimer(TaskTimer);
    
    putvalue(env_ASG_AudioSD_Config_SWConfig,empty_string);
    putvalue(env_ASG_AudioSD_Config_DBC,empty_string);

    //FctList
    putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit41,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit42,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit43,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit44,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit45,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit46,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit47,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit48,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit49,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit50,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit51,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit52,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit53,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit54,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit55,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit56,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit57,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit58,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit59,FALSE);
    putvalue(env_ASG_AudioSD_FctList_Bit60,FALSE);


    //FSG-Setup	    
    putvalue(env_ASG_AudioSD_FSGSetup_MaxVol, 0);

    putvalue(env_ASG_AudioSD_FSGSetup_Ent, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Nav, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ano, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Pho, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_SDS, 0);

    putvalue(env_ASG_AudioSD_FSGSetup_FM, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_AM, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_DAB, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_SDARS, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_AMLW, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_AMSW, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_TVDVB, 0);

    putvalue(env_ASG_AudioSD_FSGSetup_Ent_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Nav_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ano_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Pho_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_SDS_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_FM_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AM_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_DAB_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_SDARS_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AMLW_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_AMSW_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_TVDVB_s, empty_string);

    putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su, 0);
    putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su_s, empty_string);
	
    //FSG-OperationState
    putvalue(env_ASG_AudioSD_FSGOpState_s, empty_string);
    putvalue(env_ASG_AudioSD_FSGOpState_HMI_s, empty_string);

	//activeSource
    putvalue(env_ASG_AudioSD_AS_SourceType_s,empty_string);
    putvalue(env_ASG_AudioSD_AS_SL_Ref, 0);
    putvalue(env_ASG_AudioSD_AS_TypeOfNum_s,empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_RL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_RL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_PL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_PL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_ML, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_ML_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv_SAL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv_SAL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv2_LSL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv2_LSL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_LiAv2_FL, 0);
    putvalue(env_ASG_AudioSD_AS_LiAv2_FL_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_ListState_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_ListState_s, empty_string);
    putvalue(env_ASG_AudioSD_AS_Number, 0);   
	
    //activeSourceName
	putvalue(env_ASG_AudioSD_ASName_Name_s, empty_string);

	//currentVolume
    putvalue(env_ASG_AudioSD_CurrVol_EntVol,0);
    putvalue(env_ASG_AudioSD_CurrVol_NavVol,0);
    putvalue(env_ASG_AudioSD_CurrVol_TaVol,0);
    putvalue(env_ASG_AudioSD_CurrVol_PhoVol,0);
    putvalue(env_ASG_AudioSD_CurrVol_SDSVol,0);            
    putvalue(env_ASG_AudioSD_CurrVol_chType_s, empty_string);

	//Mute
    putvalue(env_ASG_AudioSD_Mute_Enter, 0);
    putvalue(env_ASG_AudioSD_Mute_DAB, 0);
    putvalue(env_ASG_AudioSD_Mute_DVB, 0);
    putvalue(env_ASG_AudioSD_Mute_SDARS, 0);
    putvalue(env_ASG_AudioSD_Mute_IBOC, 0);
    putvalue(env_ASG_AudioSD_Mute_sync_IBOC, 0);
    putvalue(env_ASG_AudioSD_Mute_Call, 0);

	//SourceState
	putvalue(env_ASG_AudioSD_SrcSt_SateInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_SrcSt_Scope_s, empty_string);
    putvalue(env_ASG_AudioSD_SrcSt_Scope, 0);
    putvalue(env_ASG_AudioSD_SrcSt_SateInfo, 0);

	//CurrentStationInfo
    putvalue(env_ASG_AudioSD_CSI_PInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_TInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_QInfo_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_PType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_TType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_QType_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_PID, 0);
    putvalue(env_ASG_AudioSD_CSI_SIS_TA, 0);
    putvalue(env_ASG_AudioSD_CSI_SIS_TA_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_TMC, 0);
    putvalue(env_ASG_AudioSD_CSI_SIS_TMC_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_VICS, 0);
    putvalue(env_ASG_AudioSD_CSI_SIS_VICS_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SIS_IBOC, 0);
    putvalue(env_ASG_AudioSD_CSI_SIS_IBOC_s, empty_string);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit0,0);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit0_s,empty_string);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit1,0);
    putvalue(env_ASG_AudioSD_CSI_SP_Bit1_s,empty_string);
    putvalue(env_ASG_AudioSD_CSI_ChannelID,0);
    
    //CurrentStationInfo_Handle
    putvalue(env_ASG_AudioSD_CSH_FSGh,0);
    putvalue(env_ASG_AudioSD_CSH_FSGh_abs,0);
    putvalue(env_ASG_AudioSD_CSH_PL_Ref,0);
    putvalue(env_ASG_AudioSD_CSH_PL_abs,0);
    putvalue(env_ASG_AudioSD_CSH_DAB_E_han,0);
    putvalue(env_ASG_AudioSD_CSH_DAB_E_abs,0);

	//GeneralInfoSwitches
  	putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, 0);
  	putvalue(env_ASG_AudioSD_GIS_OnOffSw_RD, 0);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, 0);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_TM, 0);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_VI, 0);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_ON, 0);
    putvalue(env_ASG_AudioSD_GIS_OnOffSw_DAB, 0);

    putvalue(env_ASG_AudioSD_GIS_Mod_TP, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_TP_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_RD, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_RD_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_JP, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_JP_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_TM, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_TM_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_VI, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_VI_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_ON, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_ON_s, empty_string);
    putvalue(env_ASG_AudioSD_GIS_Mod_DAB, 0);
    putvalue(env_ASG_AudioSD_GIS_Mod_DAB_s, empty_string);
       
	//TPMemoInfo
	putvalue(env_ASG_AudioSD_TPMemInfo_CMN, 0);
    putvalue(env_ASG_AudioSD_TPMemInfo_TMN,0);
    putvalue(env_ASG_AudioSD_TPMemInfo_MT_ho,0);
    putvalue(env_ASG_AudioSD_TPMemInfo_MT_min,0);
    putvalue(env_ASG_AudioSD_TPMemInfo_Name_s, empty_string);

    //AnnouncementInfo
    putvalue(env_ASG_AudioSD_AnInf_Type_s,empty_string);
    putvalue(env_ASG_AudioSD_AnInf_Name_s,empty_string);
    
	//InfoStates
	putvalue(env_ASG_AudioSD_InfoSt_States_s, empty_string);

    //ReceptionListType
    putvalue(env_ASG_AudioSD_RecListTy_Type_s, empty_string);

    //MediaBrowser_FolderLevel
    putvalue(env_ASG_AudioSD_MeBrLevel_FL, 0);
    putvalue(env_ASG_AudioSD_MeBrLevel_Ref, 0);
    putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, 0);

    //MediaPath
    putvalue(env_ASG_AudioSD_MePath_Type_s, empty_string);
    putvalue(env_ASG_AudioSD_MePath_Path_s, empty_string);

    //PreferredList
    putvalue(env_ASG_AudioSD_PrefList_List_s, empty_string);

    //SDS_State
    putvalue(env_ASG_AudioSD_SDSState_State_s, empty_string);

    //FunctionSynchronisation
    putvalue(env_ASG_AudioSD_FctSyn_Bit16, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit16_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit17, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit17_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit18, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit18_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit19, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit19_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit20, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit20_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit21, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit21_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit22, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit22_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit23, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit23_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit24, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit24_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit25, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit25_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit26, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit26_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit27, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit27_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit28, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit28_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit29, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit29_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit30, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit30_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit31, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit31_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit32, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit32_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit33, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit33_s, empty_string);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit34, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit34_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit35, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit35_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit36, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit36_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit37, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit37_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit38, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit38_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit39, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit39_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit40, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit40_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit41, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit41_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit42, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit42_s, empty_string);

    putvalue(env_ASG_AudioSD_FctSyn_Bit43, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit43_s, empty_string);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit44, 0);
    putvalue(env_ASG_AudioSD_FctSyn_Bit44_s, empty_string);

    //ASG_Capabilities
    putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, 0);
    putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB_s, empty_string);
    
    //Methods
    //DedicatedAudioControl
    putvalue(env_ASG_AudioSD_DAC_CT,AUDIO_DAC_SLE);
    putvalue(env_ASG_AudioSD_DAC_LT,AUDIO_DAC_NOLIST);
    putvalue(env_ASG_AudioSD_DAC_FSGHandle,0);
	putvalue(env_ASG_AudioSD_DAC_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_DAC_Err,0);
    putvalue(env_ASG_AudioSD_DAC_Err_s, empty_string);
    
    //AnnouncementEscape
    putvalue(env_ASG_AudioSD_AnE_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_AnE_Err,0);
    putvalue(env_ASG_AudioSD_AnE_Err_s, empty_string);

    //SwitchSource
    putvalue(env_ASG_AudioSD_SwSource_Ref,0);
    putvalue(env_ASG_AudioSD_SwSource_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_SwSource_Err,0);
    putvalue(env_ASG_AudioSD_SwSource_Err_s, empty_string);

    //MediaBrowserControl
    putvalue(env_ASG_AudioSD_MBrC_Control, 0);
    putvalue(env_ASG_AudioSD_MBrC_Ref, 0);
    putvalue(env_ASG_AudioSD_MBrC_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_MBrC_Err,0);
    putvalue(env_ASG_AudioSD_MBrC_Err_s, empty_string);

    //MediaFileInfo
    putvalue(env_ASG_AudioSD_MFI_Ref, 0);
    putvalue(env_ASG_AudioSD_MFI_Artist_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Title_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Album_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Res_s, empty_string);
    putvalue(env_ASG_AudioSD_MFI_Err,0);
    putvalue(env_ASG_AudioSD_MFI_Err_s, empty_string);    

    //GetNextListPos
    putvalue(env_ASG_AudioSD_GNLP_CurrPos,0);
    putvalue(env_ASG_AudioSD_GNLP_Offset,0);
    putvalue(env_ASG_AudioSD_GNLP_LT,0);
    putvalue(env_ASG_AudioSD_GNLP_nextPos,0);
    putvalue(env_ASG_AudioSD_GNLP_AbsPos,0);
    putvalue(env_ASG_AudioSD_GNLP_Res_s,empty_string);
    putvalue(env_ASG_AudioSD_GNLP_Err,0);
    putvalue(env_ASG_AudioSD_GNLP_Err_s, empty_string);
    putvalue(env_ASG_AudioSD_GNLP_Offset, 0); 

    //Array's
    //ReceptionList
    putvalue(env_ASG_AudioSD_RL_ASGID, 0);
    putvalue(env_ASG_AudioSD_RL_TAID, 0);
    putvalue(env_ASG_AudioSD_RL_ParentID,0);
    putvalue(env_ASG_AudioSD_RL_ElementType, 0);
    putvalue(env_ASG_AudioSD_RL_TotalNumLE, 0);
    putvalue(env_ASG_AudioSD_RL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_RL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_RL_AH_PosTrans, 0);
    putvalue(env_ASG_AudioSD_RL_AH_RA, 0);
    putvalue(env_ASG_AudioSD_RL_AH_IS, FALSE);
    putvalue(env_ASG_AudioSD_RL_AH_start, 0);
    putvalue(env_ASG_AudioSD_RL_AH_elements, 0);
    putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);
    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);

    putvalue(env_ASG_AudioSD_RL_pos_0, 0);
    putvalue(env_ASG_AudioSD_RL_pos_1, 0);
    putvalue(env_ASG_AudioSD_RL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_RL_Type_0, 0);
    putvalue(env_ASG_AudioSD_RL_Type_1, 0);
    putvalue(env_ASG_AudioSD_RL_Type_2, 0);

    putvalue(env_ASG_AudioSD_RL_Type_s_0,empty_string);
    putvalue(env_ASG_AudioSD_RL_Type_s_1,empty_string);
    putvalue(env_ASG_AudioSD_RL_Type_s_2,empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, 0);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2, empty_string);
            
    putvalue(env_ASG_AudioSD_RL_PrID_0, 0);
    putvalue(env_ASG_AudioSD_RL_PrID_1, 0);
    putvalue(env_ASG_AudioSD_RL_PrID_2, 0);

    putvalue(env_ASG_AudioSD_RL_FmReg_0, 0);
    putvalue(env_ASG_AudioSD_RL_FmReg_1, 0);
    putvalue(env_ASG_AudioSD_RL_FmReg_2, 0);

    putvalue(env_ASG_AudioSD_RL_Cat_0, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_1, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_2, 0);
    putvalue(env_ASG_AudioSD_RL_Cat_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Cat_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Cat_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_Freq_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RL_Freq_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RL_Freq_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RL_OnOff, FALSE);

    //SourceList
    putvalue(env_ASG_AudioSD_SL_ASGID, 0);
    putvalue(env_ASG_AudioSD_SL_TAID, 0);
    putvalue(env_ASG_AudioSD_SL_TotalNumLE, 0);
    putvalue(env_ASG_AudioSD_SL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_SL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_SL_AH_PosTrans, FALSE);
    putvalue(env_ASG_AudioSD_SL_AH_RA, 0);
    putvalue(env_ASG_AudioSD_SL_AH_start, 0);
    putvalue(env_ASG_AudioSD_SL_AH_IS, FALSE);
    putvalue(env_ASG_AudioSD_SL_AH_elements, 0);
    putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);
    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);

    putvalue(env_ASG_AudioSD_SL_pos_0, 0);
    putvalue(env_ASG_AudioSD_SL_pos_1, 0);
    putvalue(env_ASG_AudioSD_SL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_SL_SrcType_0, 0);
    putvalue(env_ASG_AudioSD_SL_SrcType_1, 0);
    putvalue(env_ASG_AudioSD_SL_SrcType_2, 0);

    putvalue(env_ASG_AudioSD_SL_SrcType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_SL_SrcType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_SL_SrcType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_SL_IID_0, 0);
    putvalue(env_ASG_AudioSD_SL_IID_1, 0);
    putvalue(env_ASG_AudioSD_SL_IID_2, 0);

    putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2, empty_string);
            
    putvalue(env_ASG_AudioSD_SL_MedType_0, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_1, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_2, 0);
    putvalue(env_ASG_AudioSD_SL_MedType_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_MedType_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_MedType_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);
    
    //RadioTVPresetList
    putvalue(env_ASG_AudioSD_RTPL_ASGID, 0);
    putvalue(env_ASG_AudioSD_RTPL_TAID, 0);
    putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_RTPL_AH_PosTrans, FALSE);
    putvalue(env_ASG_AudioSD_RTPL_AH_RA, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_start, 0);
    putvalue(env_ASG_AudioSD_RTPL_AH_elements, 0);
    putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_OnOff, FALSE);

    putvalue(env_ASG_AudioSD_RTPL_pos_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_pos_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_RTPL_PI_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_PI_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_PI_2, 0);

    putvalue(env_ASG_AudioSD_RTPL_WB_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_WB_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_WB_2, 0);

    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,empty_string);
    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,empty_string);
    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2, empty_string);
  
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2, empty_string);
    
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, 0);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_RTPL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_RTPL_OnOff, FALSE);
  
    //TpMemoList
    putvalue(env_ASG_AudioSD_TML_ASGID, 0);
    putvalue(env_ASG_AudioSD_TML_TAID, 0);
    putvalue(env_ASG_AudioSD_TML_TotalNumLE, 0);
    putvalue(env_ASG_AudioSD_TML_AH_shift, 0);
    putvalue(env_ASG_AudioSD_TML_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_TML_AH_PosTrans, FALSE);
    putvalue(env_ASG_AudioSD_TML_AH_RA, 0);
    putvalue(env_ASG_AudioSD_TML_AH_start, 0);
    putvalue(env_ASG_AudioSD_TML_AH_elements, 0);
    putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);
    putvalue(env_ASG_AudioSD_TML_OnOff, FALSE);

    putvalue(env_ASG_AudioSD_TML_pos_0, 0);
    putvalue(env_ASG_AudioSD_TML_pos_1, 0);
    putvalue(env_ASG_AudioSD_TML_pos_2, 0);

    putvalue(env_ASG_AudioSD_TML_At_bit0_0, 0);
    putvalue(env_ASG_AudioSD_TML_At_bit0_1, 0);
    putvalue(env_ASG_AudioSD_TML_At_bit0_2, 0);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_TML_At_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_TML_Hour_0, 0);
    putvalue(env_ASG_AudioSD_TML_Hour_1, 0);
    putvalue(env_ASG_AudioSD_TML_Hour_2, 0);

    putvalue(env_ASG_AudioSD_TML_Minute_0, 0);
    putvalue(env_ASG_AudioSD_TML_Minute_1, 0);
    putvalue(env_ASG_AudioSD_TML_Minute_2, 0);

    putvalue(env_ASG_AudioSD_TML_StName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_TML_StName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_TML_StName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_TML_OnOff, FALSE);

    //MediaBrowser
    putvalue(env_ASG_AudioSD_MB_ASGID, 0);
    putvalue(env_ASG_AudioSD_MB_TAID, 0);
    putvalue(env_ASG_AudioSD_MB_ActiveListPos, 0);
    putvalue(env_ASG_AudioSD_MB_TotalNumLE, 0);
    putvalue(env_ASG_AudioSD_MB_AH_shift, 0);
    putvalue(env_ASG_AudioSD_MB_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_MB_AH_IS, FALSE);
    putvalue(env_ASG_AudioSD_MB_AH_PosTrans, FALSE);
    putvalue(env_ASG_AudioSD_MB_AH_RA, 0);
    putvalue(env_ASG_AudioSD_MB_AH_start, 0);
    putvalue(env_ASG_AudioSD_MB_AH_elements, 0);
    putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_MB_pos_0, 0);
    putvalue(env_ASG_AudioSD_MB_pos_1, 0);
    putvalue(env_ASG_AudioSD_MB_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_MB_FileType_0, 0);
    putvalue(env_ASG_AudioSD_MB_FileType_1, 0);
    putvalue(env_ASG_AudioSD_MB_FileType_2, 0);

    putvalue(env_ASG_AudioSD_MB_FileType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_MB_FileType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_MB_FileType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit0_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit0_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit0_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit1_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit1_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit1_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit2_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit2_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit2_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit3_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit3_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit3_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit4_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit4_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit4_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit5_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit5_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit5_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FS_bit6_0, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit6_1, 0);
    putvalue(env_ASG_AudioSD_MB_FS_bit6_2, 0);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_FileName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_MB_FileName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_MB_FileName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_MB_OnOff, FALSE);
  
    //SiriusAlertList
    putvalue(env_ASG_AudioSD_SAL_ASGID, gSiriusAlertList_ASGID);
    putvalue(env_ASG_AudioSD_SAL_TAID, gSiriusAlertList_TAID);
    putvalue(env_ASG_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements);
    putvalue(env_ASG_AudioSD_SAL_AH_shift, 0);
    putvalue(env_ASG_AudioSD_SAL_AH_dir, FORWARD);
    putvalue(env_ASG_AudioSD_SAL_AH_IS, TRUE);
    putvalue(env_ASG_AudioSD_SAL_AH_PosTrans, gSiriusAlertList_transmitpos);
    putvalue(env_ASG_AudioSD_SAL_AH_RA, gSiriusAlertList_recordaddress);
    putvalue(env_ASG_AudioSD_SAL_AH_start, 0);
    putvalue(env_ASG_AudioSD_SAL_AH_elements, 3);
    //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);

    putvalue(env_ASG_AudioSD_SAL_pos_0, 0);
    putvalue(env_ASG_AudioSD_SAL_pos_1, 0);
    putvalue(env_ASG_AudioSD_SAL_pos_2, 0);
    
    putvalue(env_ASG_AudioSD_SAL_AType_0, 0);
    putvalue(env_ASG_AudioSD_SAL_AType_1, 0);
    putvalue(env_ASG_AudioSD_SAL_AType_2, 0);

    putvalue(env_ASG_AudioSD_SAL_AType_s_0,empty_string);
    putvalue(env_ASG_AudioSD_SAL_AType_s_1,empty_string);
    putvalue(env_ASG_AudioSD_SAL_AType_s_2,empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, 0);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_PrID_0, 0);
    putvalue(env_ASG_AudioSD_SAL_PrID_1, 0);
    putvalue(env_ASG_AudioSD_SAL_PrID_2, 0);

    putvalue(env_ASG_AudioSD_SAL_Name_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Name_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Name_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Freq_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Freq_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Freq_s_2, empty_string);
    
    putvalue(env_ASG_AudioSD_SAL_AName_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_AName_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_AName_s_2, empty_string);

    putvalue(env_ASG_AudioSD_SAL_Ext_s_0, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Ext_s_1, empty_string);
    putvalue(env_ASG_AudioSD_SAL_Ext_s_2, empty_string);
    
    putvalue(env_ASG_AudioSD_SAL_OnOff, FALSE);
  
    //PlayPosition
    putvalue(env_ASG_AudioSD_PP_TimePos, 0);
    putvalue(env_ASG_AudioSD_PP_TotalPlayTime, 0);
    putvalue(env_ASG_AudioSD_PP_Attr_Bit0, 0);
    putvalue(env_ASG_AudioSD_PP_BufferLevel, 0);
  
    //SDS_RecognizerState
    putvalue(env_ASG_AudioSD_SRS_InputLevel, 0);
    putvalue(env_ASG_AudioSD_SRS_InputQuality, 0);
    
    //CurrentStationInfo2
    putvalue(env_ASG_AudioSD_CSI2_Info1, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info2, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info3, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info4, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info5, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info6, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info7, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_Info8, empty_string);
    putvalue(env_ASG_AudioSD_CSI2_InfoID1, 0);
    putvalue(env_ASG_AudioSD_CSI2_ChanID, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy1, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy2, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy3, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy4, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy5, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy6, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy7, 0);
    putvalue(env_ASG_AudioSD_CSI2_InfoTy8, 0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0, 0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1, 0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2, 0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3, 0);
    putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit0, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit1, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit2, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit3, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit4, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit5, 0);
    putvalue(env_ASG_AudioSD_CSI2_SP_Bit6, 0);
  
    //CurrentStation_Handle3
    putvalue(env_ASG_AudioSD_CSH3_FavList, 0);
    putvalue(env_ASG_AudioSD_CSH3_FLaP, 0);
    putvalue(env_ASG_AudioSD_CSH3_Extension1, 0);
    putvalue(env_ASG_AudioSD_CSH3_Extension2, 0);
    putvalue(env_ASG_AudioSD_CSH3_Extension3, 0);
    putvalue(env_ASG_AudioSD_CSH3_Extension4, 0);
  
    //SiriusAlertInfo
    putvalue(env_ASG_AudioSD_SAI_AlertName, empty_string);
    putvalue(env_ASG_AudioSD_SAI_StatName, empty_string);
    putvalue(env_ASG_AudioSD_SAI_AlertType, 0);
    putvalue(env_ASG_AudioSD_SAI_SALref, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension1, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension2, 0);
    putvalue(env_ASG_AudioSD_SAI_Extension3, 0);
  
    //Station_Track_Switch
    putvalue(env_ASG_AudioSD_STS_Event, 0);
    putvalue(env_ASG_AudioSD_STS_Direction, 0);
    putvalue(env_ASG_AudioSD_STS_PlayState, 0);
    putvalue(env_ASG_AudioSD_STS_Extension1, 0);
    putvalue(env_ASG_AudioSD_STS_Extension2, 0);
    putvalue(env_ASG_AudioSD_STS_Extension3, 0);
    putvalue(env_ASG_AudioSD_STS_Extension4, 0);
    putvalue(env_ASG_AudioSD_STS_Extension5, 0);
}

HeartBeat_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_AudioSD;	        //LSG-ID
	requestarray[1]=FctID_HeartBeat;	//Fct.-ID
	requestarray[2]=request;            //request type
	
	switch(request)
	{
		case DataGet_REQ:
			
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Request: unknown request %d", request);
		break;
	}

}

HeartBeat_Indication(dword Indication_array [], int datalength)
{

    switch (gBAP_Indication[2]) // indication
	{
		case Data_IND: 
                        
		break;

		case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: unknown indication %d", gBAP_Indication[2]);
		break;
	}

}

FunctionList_Request(byte request)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
  	requestarray[1] =FctID_FunctionList;	//Fct.-ID
  	requestarray[2] =request;               //request type
  	   
    switch (request)
  	{
		  case DataGet_REQ: 										
	      set_status_requestbuffer (requestarray, 3, Bap_Void);   		 
      break;
      default:
			  writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Request: unknown request %d", request);
		  break;
	  }
}

FunctionList_Indication(dword Indication_array [], int datalength)
{
    int i =0, j =0;
    switch (gBAP_Indication[2]) // indication
	{
		case Data_IND: 

            j=0;
            for(i=3;i<11;i++)
            {   
                gFunctionList_FctList[j] =Indication_array [i];
                j++;
            }
            
            //Panel
            //Byte_0
            if(gFunctionList_FctList[0] &0x40)
                putvalue(env_ASG_AudioSD_FctList_Bit01,TRUE); 
            else
                putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);

            if(gFunctionList_FctList[0] &0x20)
                putvalue(env_ASG_AudioSD_FctList_Bit02,TRUE);
            else
                putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);

            if(gFunctionList_FctList[0] &0x10)
                putvalue(env_ASG_AudioSD_FctList_Bit03,TRUE);
            else
                putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);

            if(gFunctionList_FctList[0] &0x08)
                putvalue(env_ASG_AudioSD_FctList_Bit04,TRUE);
            else
                putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);


            //Byte_1
            if(gFunctionList_FctList[1] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit14,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup", gRGB_white);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup", gRGB_red);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[1] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit15,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_white);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_red);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", FALSE);
            }
            //Byte_2
            if(gFunctionList_FctList[2] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit16,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource", gRGB_white);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource", gRGB_red);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[2] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit17,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName", gRGB_white);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName", gRGB_red);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[2] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit18,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[2] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit19,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x13_Mute", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x13_Mute_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x13_Mute", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x13_Mute_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[2] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit20,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState", gRGB_white);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState", gRGB_red);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[2] &0x04)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit21,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo", gRGB_white);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo", gRGB_red);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[2] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit22,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle", gRGB_white);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle", gRGB_red);
                enableControl("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[2] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit23,TRUE);
                SetControlBackColor("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList", gRGB_white);
                enableControl("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
                SetControlBackColor("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList", gRGB_red);
                enableControl("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList_PanelElement", FALSE);
            }

            //Byte_3
            if(gFunctionList_FctList[3] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit24,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit25,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches_PanelElement", TRUE);    
            }

            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit26,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit27,TRUE);
                SetControlBackColor("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList", gRGB_white);
                enableControl("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
                SetControlBackColor("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList", gRGB_red);
                enableControl("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit28,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x04)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit29,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape_PanelElement", TRUE);
            }
            else
            {    
                putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit30,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates", gRGB_white);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates", gRGB_red);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[3] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit31,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType_PanelElement", FALSE);
            }

            //Byte_4
            if(gFunctionList_FctList[4] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit32,TRUE);
                SetControlBackColor("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList", gRGB_white);
                enableControl("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
                SetControlBackColor("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList", gRGB_red);
                enableControl("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit33,TRUE);
                SetControlBackColor("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList", gRGB_white);
                enableControl("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
                SetControlBackColor("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList", gRGB_red);
                enableControl("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit34,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource_PanelElement", TRUE);
            }

            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit35,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit36,TRUE);
                SetControlBackColor("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser", gRGB_white);
                enableControl("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser_PanelElement", TRUE);
            }

            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
                SetControlBackColor("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser", gRGB_red);
                enableControl("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[4] &0x04)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit37,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit38,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[4] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit39,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo_PanelElement", FALSE);
            }

            //Byte_5
            if(gFunctionList_FctList[5] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit40,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList", gRGB_white);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList", gRGB_red);
                enableControl("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[5] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit41,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x29_SDS_State", gRGB_white);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x29_SDS_State_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit41,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x29_SDS_State", gRGB_red);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x29_SDS_State_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[5] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit42,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_4", "ASG_0x2A_FunctionSynchronisation", gRGB_white);
                enableControl("ASG_AudioSD_Properties_4", "ASG_0x2A_FunctionSynchronisation_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit42,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_4", "ASG_0x2A_FunctionSynchronisation", gRGB_red);
                enableControl("ASG_AudioSD_Properties_4", "ASG_0x2A_FunctionSynchronisation_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[5] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit43,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x2B_ASG_Capabilities", gRGB_white);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x2B_ASG_Capabilities_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit43,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x2B_ASG_Capabilities", gRGB_red);
                enableControl("ASG_AudioSD_Properties_1", "ASG_0x2B_ASG_Capabilities_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[5] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit44,TRUE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x2C_GetNextListPos", gRGB_white);
                enableControl("ASG_AudioSD_Methods", "ASG_0x2C_GetNextListPos_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit44,FALSE);
                SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x2C_GetNextListPos", gRGB_red);
                enableControl("ASG_AudioSD_Methods", "ASG_0x2C_GetNextListPos_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[5] &0x04)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit45,TRUE);
                SetControlBackColor("Method_2_AudioSD_ASG", "ASG_0x2D_SwitchRadioMedia", gRGB_white);
                enableControl("Method_2_AudioSD_ASG", "ASG_0x2D_SwitchRadioMedia_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit45,FALSE);
                SetControlBackColor("Method_2_AudioSD_ASG", "ASG_0x2D_SwitchRadioMedia", gRGB_red);
                enableControl("Method_2_AudioSD_ASG", "ASG_0x2D_SwitchRadioMedia_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[5] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit46,TRUE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x2E_MediaImportState", gRGB_white);
                enableControl("ASG_Property_DF41", "ASG_0x2E_MediaImportState_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit46,FALSE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x2E_MediaImportState", gRGB_red);
                enableControl("ASG_Property_DF41", "ASG_0x2E_MediaImportState_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[5] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit47,TRUE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x2F_CurrentVolumeExtended", gRGB_white);
                enableControl("ASG_Property_DF41", "ASG_0x2F_CurrentVolumeExtended_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit47,FALSE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x2F_CurrentVolumeExtended", gRGB_red);
                enableControl("ASG_Property_DF41", "ASG_0x2F_CurrentVolumeExtended_PanelElement", FALSE);
            }
            
            //Byte_6
            if(gFunctionList_FctList[6] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit48,TRUE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x30_CustomerDownloadState", gRGB_white);
                enableControl("ASG_Property_DF41", "ASG_0x30_CustomerDownloadState_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit48,FALSE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x30_CustomerDownloadState", gRGB_red);
                enableControl("ASG_Property_DF41", "ASG_0x30_CustomerDownloadState_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[6] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit49,TRUE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x31_OnlineMusic_State", gRGB_white);
                enableControl("ASG_Property_DF41", "ASG_0x31_OnlineMusic_State_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit49,FALSE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x31_OnlineMusic_State", gRGB_red);
                enableControl("ASG_Property_DF41", "ASG_0x31_OnlineMusic_State_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[6] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit50,TRUE);
                SetControlBackColor("", "ASG_0x32_SiriusAlertList", gRGB_white);
                enableControl("", "ASG_0x32_SiriusAlertList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit50,FALSE);
                SetControlBackColor("", "ASG_0x32_SiriusAlertList", gRGB_red);
                enableControl("", "ASG_0x32_SiriusAlertList_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[6] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit51,TRUE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x33_CurrentStation_Handle2", gRGB_white);
                enableControl("ASG_Property_DF41", "ASG_0x33_CurrentStation_Handle2_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit51,FALSE);
                SetControlBackColor("ASG_Property_DF41", "ASG_0x33_CurrentStation_Handle2", gRGB_red);
                enableControl("ASG_Property_DF41", "ASG_0x33_CurrentStation_Handle2_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[6] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit52,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x34_PlayPosition", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x34_PlayPosition_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit52,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x34_PlayPosition", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x34_PlayPosition_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[6] &0x04)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit53,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x35_SDS_RecognizerState", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x35_SDS_RecognizerState_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit53,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x35_SDS_RecognizerState", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x35_SDS_RecognizerState_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[6] &0x02)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit54,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x36_CurrentStationInfo2", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x36_CurrentStationInfo2_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit54,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x36_CurrentStationInfo2", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x36_CurrentStationInfo2_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[6] &0x01)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit55,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x37_CurrentStation_Handle3", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x37_CurrentStation_Handle3_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit55,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x37_CurrentStation_Handle3", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x37_CurrentStation_Handle3_PanelElement", FALSE);
            }
            
            //Byte_7
            if(gFunctionList_FctList[7] &0x80)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit56,TRUE);
                SetControlBackColor("", "ASG_0x38_LastStationList", gRGB_white);
                enableControl("", "ASG_0x38_LastStationList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit56,FALSE);
                SetControlBackColor("", "ASG_0x38_LastStationList", gRGB_red);
                enableControl("", "ASG_0x38_LastStationList_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[7] &0x40)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit57,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x39_SiriusAlertInfo", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x39_SiriusAlertInfo_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit57,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x39_SiriusAlertInfo", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x39_SiriusAlertInfo_PanelElement", FALSE);
            }

            if(gFunctionList_FctList[7] &0x20)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit58,TRUE);
                SetControlBackColor("", "ASG_0x3A_Picture", gRGB_white);
                enableControl("", "ASG_0x3A_Picture_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit58,FALSE);
                SetControlBackColor("", "ASG_0x3A_Picture", gRGB_red);
                enableControl("", "ASG_0x3A_Picture_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[7] &0x10)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit59,TRUE);
                SetControlBackColor("", "ASG_0x3B_FavoriteList", gRGB_white);
                enableControl("", "ASG_0x3B_FavoriteList_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit59,FALSE);
                SetControlBackColor("", "ASG_0x3B_FavoriteList", gRGB_red);
                enableControl("", "ASG_0x3B_FavoriteList_PanelElement", FALSE);
            }
            
            if(gFunctionList_FctList[7] &0x08)
            {
                putvalue(env_ASG_AudioSD_FctList_Bit60,TRUE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x3C_Station_Track_Switch", gRGB_white);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x3C_Station_Track_Switch_PanelElement", TRUE);
            }
            else
            {
                putvalue(env_ASG_AudioSD_FctList_Bit60,FALSE);
                SetControlBackColor("ASG_AudioSD_Properties_6", "ASG_0x3C_Station_Track_Switch", gRGB_red);
                enableControl("ASG_AudioSD_Properties_6", "ASG_0x3C_Station_Track_Switch_PanelElement", FALSE);
            }


            /*
            putvalue(env_ASG_AudioSD_FctList_Bit45, gFunctionList_FctList[5] & 0x04 >>2);
            putvalue(env_ASG_AudioSD_FctList_Bit46, gFunctionList_FctList[5] & 0x02 >>1);
            putvalue(env_ASG_AudioSD_FctList_Bit47, gFunctionList_FctList[5] & 0x01);

            if(gFunctionList_FctList[6] & 0x80)
                                putvalue(env_ASG_AudioSD_FctList_Bit48,TRUE);

            if(gFunctionList_FctList[6] & 0x40)
                                putvalue(env_ASG_AudioSD_FctList_Bit49,TRUE);

            if(gFunctionList_FctList[6] & 0x20)
                                putvalue(env_ASG_AudioSD_FctList_Bit50,TRUE);            

            if(gFunctionList_FctList[6] & 0x10)
                                putvalue(env_ASG_AudioSD_FctList_Bit51,TRUE);            
            */
                                   
            if(FunctionList_flag)
            {
                GetAll_Request(DataGet_REQ);	//send GetAll.Get
                FunctionList_flag =FALSE;
            }                            
		break;
		
        case Error_IND:
				            if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					            writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				            else if(Indication_array[3]<0x30)			//BPL-error
					            writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				            else if(Indication_array[3]<0x40)			//BAL-error
					            writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				            else
					            writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: Application-Error: 0x%x", Indication_array[3]);
		 break;

		default:
			    writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: unknown indication 0x%d", gBAP_Indication[2]);
		break;
	}
}

on timer Powerontimer
{
	gASG_PowerOnOff =TRUE;

	settimer(TaskTimer, 10);    //start BAP-DLL-Timer	

}

FSG_OperationState_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				gAudioSD_FSG_OperationState_OpState     =Indication_array[3];
                gAudioSD_FSG_OperationState_HMI_State   =Indication_array[4];
                
                //Panel
                if((gAudioSD_FSG_OperationState_OpState <0x04) && (gAudioSD_FSG_OperationState_OpState !=0x02))
                    putvalue(env_ASG_AudioSD_FSGOpState_s, gAudioSD_FSG_OperationState_OpState_string[gAudioSD_FSG_OperationState_OpState]);
                else if (gAudioSD_FSG_OperationState_OpState ==FSGOPERATIONSTATE_DEFECT)
                    putvalue(env_ASG_AudioSD_FSGOpState_s, gstring_defect);
                else 
                    putvalue(env_ASG_AudioSD_FSGOpState_s, gstring_reserved);

                if(gAudioSD_FSG_OperationState_HMI_State<0x02)
                    putvalue(env_ASG_AudioSD_FSGOpState_HMI_s, gAudioSD_FSG_OperationState_HMI_State_string[gAudioSD_FSG_OperationState_HMI_State]);
                else 
                    putvalue(env_ASG_AudioSD_FSGOpState_HMI_s, gstring_reserved);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD FSG_OperationState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

FSG_OperationState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_OperationState;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Request: invalid request %d", request);
		break;
	}
}

FSG_Setup_Indication (dword Indication_array[], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				gAudioSD_FSGSetup_maxVolume                 =Indication_array[3];
                gAudioSD_FSGSetup_supportedVolumeTypes      =Indication_array[4];
                gAudioSD_FSGSetup_ReceptionList_AutoUpdate  =Indication_array[5];
                gAudioSD_FSGSetup_Setup_Extensions          =Indication_array[6];

                gAudioSD_FSGSetup_entertainmentVolume   =gAudioSD_FSGSetup_supportedVolumeTypes &0x01;           //Bit '0'                       
                gAudioSD_FSGSetup_navigationVolume      =(gAudioSD_FSGSetup_supportedVolumeTypes &0x02)/0x02;    //Bit '1' 
                gAudioSD_FSGSetup_announcementVolume    =(gAudioSD_FSGSetup_supportedVolumeTypes &0x04)/0x04;    //Bit '2' 
                gAudioSD_FSGSetup_phoneVolume           =(gAudioSD_FSGSetup_supportedVolumeTypes &0x08)/0x08;    //Bit '3'
                gAudioSD_FSGSetup_SDSVolume             =(gAudioSD_FSGSetup_supportedVolumeTypes &0x10)/0x10;    //Bit '4'  
                gAudioSD_FSGSetup_phoneRingingVolume    =(gAudioSD_FSGSetup_supportedVolumeTypes &0x20)/0x20;    //Bit '5' 
                gAudioSD_FSGSetup_carParkingFader       =(gAudioSD_FSGSetup_supportedVolumeTypes &0x40)/0x40;    //Bit '6'
                gAudioSD_FSGSetup_readMessageVolume     =(gAudioSD_FSGSetup_supportedVolumeTypes &0x80)/0x80;    //Bit '7'  


                gAudioSD_FSGSetup_FMReceptionList       =gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x01;          //Bit'0'
                gAudioSD_FSGSetup_AMReceptionList       =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x02)/0x02;   //Bit'1'
                gAudioSD_FSGSetup_DABReceptionList      =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x04)/0x04;   //Bit'2'
                gAudioSD_FSGSetup_SDARSReceptionList    =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x08)/0x08;   //Bit'3'
                gAudioSD_FSGSetup_AMLWReceptionList     =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x10)/0x10;   //Bit'4'
                gAudioSD_FSGSetup_AMSWReceptionList     =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x20)/0x20;   //Bit'5'
                gAudioSD_FSGSetup_TVDVBReceptionList    =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x40)/0x40;   //Bit'6'
                gAudioSD_FSGSetup_ORReceptionList       =(gAudioSD_FSGSetup_ReceptionList_AutoUpdate &0x80)/0x80;   //Bit'7'
                
                gAudioSD_FSGSetup_Setup_Extensions_DAB  =gAudioSD_FSGSetup_Setup_Extensions &0x01; 
                gAudioSD_FSGSetup_Setup_Extensions_CL   =(gAudioSD_FSGSetup_Setup_Extensions &0x02)/0x02; 
                gAudioSD_FSGSetup_Setup_Extensions_CA   =(gAudioSD_FSGSetup_Setup_Extensions &0x04)/0x04; 
                gAudioSD_FSGSetup_Setup_Extensions_SA   =(gAudioSD_FSGSetup_Setup_Extensions &0x08)/0x08; 
                gAudioSD_FSGSetup_Setup_Extensions_Su   =(gAudioSD_FSGSetup_Setup_Extensions &0x10)/0x10; 

                putvalue(env_ASG_AudioSD_FSGSetup_MaxVol, gAudioSD_FSGSetup_maxVolume);

                putvalue(env_ASG_AudioSD_FSGSetup_Ent, gAudioSD_FSGSetup_entertainmentVolume);
                putvalue(env_ASG_AudioSD_FSGSetup_Ent_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_entertainmentVolume]); 
				
                putvalue(env_ASG_AudioSD_FSGSetup_Nav, gAudioSD_FSGSetup_navigationVolume);
                putvalue(env_ASG_AudioSD_FSGSetup_Nav_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_navigationVolume]); 
                
                putvalue(env_ASG_AudioSD_FSGSetup_Ano, gAudioSD_FSGSetup_announcementVolume); 
                putvalue(env_ASG_AudioSD_FSGSetup_Ano_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_announcementVolume]); 
                
                putvalue(env_ASG_AudioSD_FSGSetup_Pho, gAudioSD_FSGSetup_phoneVolume);
                putvalue(env_ASG_AudioSD_FSGSetup_Pho_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_phoneVolume]);  
                
                putvalue(env_ASG_AudioSD_FSGSetup_SDS, gAudioSD_FSGSetup_SDSVolume);  
                putvalue(env_ASG_AudioSD_FSGSetup_SDS_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_SDSVolume]); 

                putvalue(env_ASG_AudioSD_FSGSetup_PRVol, gAudioSD_FSGSetup_phoneRingingVolume); 
                putvalue(env_ASG_AudioSD_FSGSetup_PRVol_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_phoneRingingVolume]); 
                
                putvalue(env_ASG_AudioSD_FSGSetup_CarPF, gAudioSD_FSGSetup_carParkingFader);
                putvalue(env_ASG_AudioSD_FSGSetup_CarPF_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_carParkingFader]);  
                
                putvalue(env_ASG_AudioSD_FSGSetup_RMVol, gAudioSD_FSGSetup_readMessageVolume);  
                putvalue(env_ASG_AudioSD_FSGSetup_RMVol_s, gAudioSD_FSGSetup_supportedVolumeTypes_string[gAudioSD_FSGSetup_readMessageVolume]); 


			    putvalue(env_ASG_AudioSD_FSGSetup_FM, gAudioSD_FSGSetup_FMReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_FM_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_FMReceptionList]);
            
                putvalue(env_ASG_AudioSD_FSGSetup_AM, gAudioSD_FSGSetup_AMReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_AM_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_AMReceptionList]);
                
                putvalue(env_ASG_AudioSD_FSGSetup_DAB, gAudioSD_FSGSetup_DABReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_DAB_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_DABReceptionList]);
                
                putvalue(env_ASG_AudioSD_FSGSetup_SDARS, gAudioSD_FSGSetup_SDARSReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_SDARS_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_SDARSReceptionList]);

                putvalue(env_ASG_AudioSD_FSGSetup_AMLW, gAudioSD_FSGSetup_AMLWReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_AMLW_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_AMLWReceptionList]);

                putvalue(env_ASG_AudioSD_FSGSetup_AMSW, gAudioSD_FSGSetup_AMSWReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_AMSW_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_AMSWReceptionList]);

                putvalue(env_ASG_AudioSD_FSGSetup_TVDVB, gAudioSD_FSGSetup_TVDVBReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_TVDVB_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_TVDVBReceptionList]);

                putvalue(env_ASG_AudioSD_FSGSetup_OR, gAudioSD_FSGSetup_ORReceptionList);
                putvalue(env_ASG_AudioSD_FSGSetup_OR_s, gAudioSD_FSGSetup_ReceptionList_AutoUpdate_string[gAudioSD_FSGSetup_ORReceptionList]);

                putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL, gAudioSD_FSGSetup_Setup_Extensions_CL);
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_CL_s, gAudioSD_FSGSetup_Setup_Extensions_CL_string[gAudioSD_FSGSetup_Setup_Extensions_CL]);

                putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA, gAudioSD_FSGSetup_Setup_Extensions_DAB);
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_DA_s, gAudioSD_FSGSetup_Setup_Extensions_DAB_string[gAudioSD_FSGSetup_Setup_Extensions_DAB]);
            
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA, gAudioSD_FSGSetup_Setup_Extensions_CA);
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_CA_s, gAudioSD_FSGSetup_Setup_Extensions_CA_string[gAudioSD_FSGSetup_Setup_Extensions_CA]);
     
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA, gAudioSD_FSGSetup_Setup_Extensions_SA);
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_SA_s, gAudioSD_FSGSetup_Setup_Extensions_SA_string[gAudioSD_FSGSetup_Setup_Extensions_SA]);
     
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su, gAudioSD_FSGSetup_Setup_Extensions_Su);
                putvalue(env_ASG_AudioSD_FSGSetup_Ex_Su_s, gAudioSD_FSGSetup_Setup_Extensions_Su_string[gAudioSD_FSGSetup_Setup_Extensions_Su]);
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD FSG_Setup_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

FSG_Setup_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_Setup;	        //Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
	        requestarray[3] =Bap_Void;                   //request type
			set_status_requestbuffer (requestarray, 4, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_AudioSD_Request: invalid request %d", request);
		break;
	}
}

activeSource_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ActiveSource;	    //Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Request: invalid request %d", request);
		break;
	}
}

activeSource_Indication (dword Indication_array [], int datalength)
{
  /*
  if(datalength !=6)
	{
    	writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BAP-datalength-error");
    }
    else
	{
  */
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				        gAudioSD_activeSource_SourceType            =Indication_array[3];
                gAudioSD_audioSource_SourceList_Reference   =Indication_array[4] +(Indication_array[5]*0x100);
                gAudioSD_audioSource_TypeOfNumber           =(Indication_array[6] &0xF0) /0x10;
                gAudioSD_audioSource_ListAvailable          =Indication_array[6] &0x0F;
                gAudioSD_audioSource_ListState              =(Indication_array[7] &0xF0) /0x10;
                gAudioSD_audioSource_ListAvailable2         =Indication_array[7] &0x0F;
                gAudioSD_audioSource_Number                 =Indication_array[8];
                
                gAudioSD_audioSource_ReceptionList      =gAudioSD_audioSource_ListAvailable &0x01;
                gAudioSD_audioSource_PresetList         =(gAudioSD_audioSource_ListAvailable &0x02) /0x02;
                gAudioSD_audioSource_MediaBrowserList   =(gAudioSD_audioSource_ListAvailable &0x04) /0x04;
                gAudioSD_audioSource_SiriusAlertList    =(gAudioSD_audioSource_ListAvailable &0x08) /0x08;
                gAudioSD_audioSource_LastStationList    =gAudioSD_audioSource_ListAvailable2 &0x01;
                gAudioSD_audioSource_FavoriteList       =(gAudioSD_audioSource_ListAvailable2 &0x02) /0x02;

                //Panel
                //SourceType
                if (gAudioSD_activeSource_SourceType == ACTIVESOURCE_UNKNOWNSOURCE)
                    putvalue(env_ASG_AudioSD_AS_SourceType_s,gAudioSD_activeSource_SourceType_unknown_s);
                else if (gAudioSD_activeSource_SourceType <0x2E)
                    putvalue(env_ASG_AudioSD_AS_SourceType_s,gAudioSD_activeSource_SourceType_string[gAudioSD_activeSource_SourceType]);
                else
                    putvalue(env_ASG_AudioSD_AS_SourceType_s,gstring_reserved);
                
                //Reference
                putvalue(env_ASG_AudioSD_AS_SL_Ref, gAudioSD_audioSource_SourceList_Reference);

                //TypeOfNumber
                if (gAudioSD_audioSource_TypeOfNumber ==ACTIVESOURCE_INVALIDNUMBER)
                    putvalue(env_ASG_AudioSD_AS_TypeOfNum_s, gAudioSD_activeSource_SourceType_InvalidNumber_s);
                
                else if(gAudioSD_audioSource_TypeOfNumber <0x6)
                    putvalue(env_ASG_AudioSD_AS_TypeOfNum_s, gAudioSD_audioSource_TypeOfNumber_string[gAudioSD_audioSource_TypeOfNumber]);

                else
                    putvalue(env_ASG_AudioSD_AS_TypeOfNum_s,gstring_reserved);
                
                //ListAvailable
                putvalue(env_ASG_AudioSD_AS_LiAv_RL, gAudioSD_audioSource_ReceptionList);
                putvalue(env_ASG_AudioSD_AS_LiAv_RL_s, gAudioSD_audioSource_ListAvailable_string[gAudioSD_audioSource_ReceptionList]);

                putvalue(env_ASG_AudioSD_AS_LiAv_PL, gAudioSD_audioSource_PresetList);
                putvalue(env_ASG_AudioSD_AS_LiAv_PL_s, gAudioSD_audioSource_ListAvailable_string[gAudioSD_audioSource_PresetList]);

                putvalue(env_ASG_AudioSD_AS_LiAv_ML, gAudioSD_audioSource_MediaBrowserList);
                putvalue(env_ASG_AudioSD_AS_LiAv_ML_s, gAudioSD_audioSource_ListAvailable_string[gAudioSD_audioSource_MediaBrowserList]);
                
                putvalue(env_ASG_AudioSD_AS_LiAv_SAL, gAudioSD_audioSource_SiriusAlertList);
                putvalue(env_ASG_AudioSD_AS_LiAv_SAL_s, gAudioSD_audioSource_ListAvailable_string[gAudioSD_audioSource_SiriusAlertList]);
                
                putvalue(env_ASG_AudioSD_AS_LiAv2_LSL, gAudioSD_audioSource_LastStationList);
                putvalue(env_ASG_AudioSD_AS_LiAv2_LSL_s, gAudioSD_audioSource_ListAvailable2_string[gAudioSD_audioSource_LastStationList]);
                
                putvalue(env_ASG_AudioSD_AS_LiAv2_FL, gAudioSD_audioSource_FavoriteList);
                putvalue(env_ASG_AudioSD_AS_LiAv2_FL_s, gAudioSD_audioSource_ListAvailable2_string[gAudioSD_audioSource_FavoriteList]);
                
                //ListState
                if (gAudioSD_audioSource_ListState <0x5)
                    putvalue(env_ASG_AudioSD_AS_ListState_s, gAudioSD_audioSource_ListState_string[gAudioSD_audioSource_ListState]);
                
                else
                    putvalue(env_ASG_AudioSD_AS_ListState_s, gstring_reserved);

                //Number
                putvalue(env_ASG_AudioSD_AS_Number, gAudioSD_audioSource_Number);;
                    
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD activeSource_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
    //}
}

activeSourceName_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ActiveSourceName;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Request: invalid request %d", request);
		break;
	}
}

activeSourceName_Indication (dword Indication_array [], int datalength)
{
    int i=0;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
                
                //clear
                for(i=0; i<ACTIVE_SOURCE_NAME_LENGTH; i++)
                    gAudioSD_activeSourceName[i] =0;                    

                //get data
                if(datalength >=(Indication_array[3]+4))
                {
                    for (i=0; i<Indication_array[3]; i++)
				        gAudioSD_activeSourceName[i] =Indication_array[4+i];
                }
                //Panel
                putvalue(env_ASG_AudioSD_ASName_Name_s, gAudioSD_activeSourceName);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD activeSourceName_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

currentVolume_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentVolume;	    //Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Request: invalid request %d", request);
		break;
	}
}

currentVolume_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                
                //get data
				gAudioSD_currentVolume_EntertainmentVolume  =Indication_array[3];
                gAudioSD_currentVolume_NavigationVolume     =Indication_array[4];         
                gAudioSD_currentVolume_TaVolume             =Indication_array[5];
                gAudioSD_currentVolume_PhoneVolume          =Indication_array[6];
                gAudioSD_currentVolume_SDSVolume            =Indication_array[7];
                gAudioSD_currentVolume_ChangingVolumeType   =Indication_array[8];

                //Panel
                putvalue(env_ASG_AudioSD_CurrVol_EntVol,gAudioSD_currentVolume_EntertainmentVolume);
                putvalue(env_ASG_AudioSD_CurrVol_NavVol,gAudioSD_currentVolume_NavigationVolume);
                putvalue(env_ASG_AudioSD_CurrVol_TaVol,gAudioSD_currentVolume_TaVolume);
                putvalue(env_ASG_AudioSD_CurrVol_PhoVol,gAudioSD_currentVolume_PhoneVolume);
                putvalue(env_ASG_AudioSD_CurrVol_SDSVol,gAudioSD_currentVolume_SDSVolume);
                
                if(gAudioSD_currentVolume_ChangingVolumeType <0x11)
                    putvalue(env_ASG_AudioSD_CurrVol_chType_s,gAudioSD_currentVolume_ChangingVolumeType_string[gAudioSD_currentVolume_ChangingVolumeType]);
                
                else
                    putvalue(env_ASG_AudioSD_CurrVol_chType_s, gstring_reserved);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD currentVolume_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

Mute_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	//LSG-ID
	requestarray[1] =FctID_Mute;	//Fct.-ID
	requestarray[2] =request;       //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;

        case DataSetGet_REQ:
                requestarray[3] =gAudioSD_Mute_MuteState;		    

			set_status_requestbuffer (requestarray, 4, Bap_UInt8);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Mute_Request: invalid request %d", request);
		break;
	}
}

Mute_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				gAudioSD_Mute_MuteState     =Indication_array[3];
                
                gAudioSD_Mute_Entertainment =gAudioSD_Mute_MuteState &0x01;
                gAudioSD_Mute_DAB           =(gAudioSD_Mute_MuteState &0x02) /0x02;
                gAudioSD_Mute_DVB           =(gAudioSD_Mute_MuteState &0x04) /0x04;
                gAudioSD_Mute_SDARS         =(gAudioSD_Mute_MuteState &0x08) /0x08;
                gAudioSD_Mute_sync_IBOC     =(gAudioSD_Mute_MuteState &0x10) /0x10;
                gAudioSD_Mute_Phone         =(gAudioSD_Mute_MuteState &0x20) /0x20;
                gAudioSD_Mute_IBOC          =(gAudioSD_Mute_MuteState &0x40) /0x40;
                gAudioSD_Mute_OnlineRadio   =(gAudioSD_Mute_MuteState &0x80) /0x80;

                //Panel
                putvalue(env_ASG_AudioSD_Mute_Enter, gAudioSD_Mute_Entertainment);
                putvalue(env_ASG_AudioSD_Mute_DAB, gAudioSD_Mute_DAB);
                putvalue(env_ASG_AudioSD_Mute_DVB, gAudioSD_Mute_DVB);
                putvalue(env_ASG_AudioSD_Mute_SDARS, gAudioSD_Mute_SDARS);
                putvalue(env_ASG_AudioSD_Mute_sync_IBOC, gAudioSD_Mute_sync_IBOC);
                putvalue(env_ASG_AudioSD_Mute_IBOC, gAudioSD_Mute_IBOC);
                putvalue(env_ASG_AudioSD_Mute_Call, gAudioSD_Mute_Phone);
                putvalue(env_ASG_AudioSD_Mute_OnRad, gAudioSD_Mute_OnlineRadio);
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Mute_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Mute_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Mute_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD Mute_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD Mute_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

on envVar env_ASG_AudioSD_Mute_set
{
	if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
		gAudioSD_Mute_MuteState   =getvalue(env_ASG_AudioSD_Mute_Enter);
		gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_DAB)*0x02;
        gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_DVB)*0x04;
        gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_SDARS)*0x08;
        gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_IBOC)*0x10;
        gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_Call)*0x20;
        gAudioSD_Mute_MuteState   +=getvalue(env_ASG_AudioSD_Mute_OnRad)*0x80;
        		
        Mute_Request(DataSetGet_REQ);
	}
}

SourceState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_SourceState;	//Fct.-ID
	requestarray[2] =request;           //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;

        case DataSetGet_REQ:
                requestarray[3] =gAudioSD_SourceState_StateInfo;
                requestarray[4] =gAudioSD_SourceState_Scope;		    

			set_status_requestbuffer (requestarray, 5, Bap_ByteSequence);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Request: invalid request %d", request);
		break;
	}
}

SourceState_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				gAudioSD_SourceState_StateInfo =Indication_array[3];
                gAudioSD_SourceState_Scope     =Indication_array[4];
                                
                //Panel
                if (gAudioSD_SourceState_StateInfo <0x08)
                {
                    putvalue(env_ASG_AudioSD_SrcSt_SateInfo_s, gAudioSD_SourceState_StateInfo_string[gAudioSD_SourceState_StateInfo]);
                    putvalue(env_ASG_AudioSD_SrcSt_SateInfo, gAudioSD_SourceState_StateInfo);
                }
                else
                    putvalue(env_ASG_AudioSD_SrcSt_SateInfo_s, gstring_reserved);

                if (gAudioSD_SourceState_Scope <0x09)
                {
                    putvalue(env_ASG_AudioSD_SrcSt_Scope_s, gAudioSD_SourceState_Scope_string[gAudioSD_SourceState_Scope]);
                    putvalue(env_ASG_AudioSD_SrcSt_Scope, gAudioSD_SourceState_Scope);
                }
                else
                    putvalue(env_ASG_AudioSD_SrcSt_Scope_s, gstring_reserved);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SourceState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

GeneralInfoSwitches_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
        gAudioSD_GeneralInfoSwitches_OnOffSwitches  =Indication_array[3];
        gAudioSD_GeneralInfoSwitches_Modification   =Indication_array[4];
        
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA       =gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x01;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x02) /0x02;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic  =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x04) /0x04;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x08) /0x08;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS       =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x10) /0x10;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online     =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x20) /0x20;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x40) /0x40;

        gAudioSD_GeneralInfoSwitches_Modification_TPTA       =gAudioSD_GeneralInfoSwitches_Modification &0x01;
        gAudioSD_GeneralInfoSwitches_Modification_RDS        =(gAudioSD_GeneralInfoSwitches_Modification &0x02) /0x02;
        gAudioSD_GeneralInfoSwitches_Modification_JPtraffic  =(gAudioSD_GeneralInfoSwitches_Modification &0x04) /0x04;
        gAudioSD_GeneralInfoSwitches_Modification_TMC        =(gAudioSD_GeneralInfoSwitches_Modification &0x08) /0x08;
        gAudioSD_GeneralInfoSwitches_Modification_VICS       =(gAudioSD_GeneralInfoSwitches_Modification &0x10) /0x10;
        gAudioSD_GeneralInfoSwitches_Modification_Online     =(gAudioSD_GeneralInfoSwitches_Modification &0x20) /0x20;
        gAudioSD_GeneralInfoSwitches_Modification_DAB        =(gAudioSD_GeneralInfoSwitches_Modification &0x40) /0x40;
        
        //Panel
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_RD, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_TM, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_VI, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_ON, gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online);
        putvalue(env_ASG_AudioSD_GIS_OnOffSw_DAB, gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB);

        putvalue(env_ASG_AudioSD_GIS_Mod_TP, gAudioSD_GeneralInfoSwitches_Modification_TPTA);
        putvalue(env_ASG_AudioSD_GIS_Mod_TP_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_TPTA]);
        
        putvalue(env_ASG_AudioSD_GIS_Mod_RD, gAudioSD_GeneralInfoSwitches_Modification_RDS);
        putvalue(env_ASG_AudioSD_GIS_Mod_RD_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_RDS]);

        putvalue(env_ASG_AudioSD_GIS_Mod_JP, gAudioSD_GeneralInfoSwitches_Modification_JPtraffic);
        putvalue(env_ASG_AudioSD_GIS_Mod_JP_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_JPtraffic]);

        putvalue(env_ASG_AudioSD_GIS_Mod_TM, gAudioSD_GeneralInfoSwitches_Modification_TMC);
        putvalue(env_ASG_AudioSD_GIS_Mod_TM_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_TMC]);

        putvalue(env_ASG_AudioSD_GIS_Mod_VI, gAudioSD_GeneralInfoSwitches_Modification_VICS);
        putvalue(env_ASG_AudioSD_GIS_Mod_VI_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_VICS]);

        putvalue(env_ASG_AudioSD_GIS_Mod_ON, gAudioSD_GeneralInfoSwitches_Modification_Online);
        putvalue(env_ASG_AudioSD_GIS_Mod_ON_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_Online]);
        
        putvalue(env_ASG_AudioSD_GIS_Mod_DAB, gAudioSD_GeneralInfoSwitches_Modification_DAB);
        putvalue(env_ASG_AudioSD_GIS_Mod_DAB_s, gAudioSD_GeneralInfoSwitches_Modification_string[gAudioSD_GeneralInfoSwitches_Modification_DAB]);
      break;
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: Application-Error: 0x%x", Indication_array[3]);			
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD GeneralInfoSwitches_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

GeneralInfoSwitches_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_GeneralInfoSwitches;	//Fct.-ID
  	requestarray[2] =request;                   //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
      case DataSetGet_REQ:
        requestarray[3] =gAudioSD_GeneralInfoSwitches_OnOffSwitches;
        requestarray[4] =gAudioSD_GeneralInfoSwitches_Reserve;		    
  			set_status_requestbuffer (requestarray, 5, Bap_ByteSequence);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Request: invalid request %d", request);
  		break;
  	}
}

on envVar env_ASG_AudioSD_GIS_Set
{
	if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
    		gAudioSD_GeneralInfoSwitches_OnOffSwitches   =getvalue(env_ASG_AudioSD_GIS_OnOffSw_TP);
    		gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_RD)*0x02;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_JP)*0x04;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_TM)*0x08;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_VI)*0x10;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_ON)*0x20;
        gAudioSD_GeneralInfoSwitches_OnOffSwitches   +=getvalue(env_ASG_AudioSD_GIS_OnOffSw_DAB)*0x40;
		
        GeneralInfoSwitches_Request(DataSetGet_REQ);
	}
}

CurrentStationInfo_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentStationInfo;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Request: invalid request %d", request);
		break;
	}
}

CurrentStationInfo_Indication (dword Indication_array [], int datalength)
{
    int i =0, Offset =0, length =0;
    
    switch (gBAP_Indication[2])
	{
		case Data_IND:
            if(datalength >=17) 
            {
                //get data
                length =Indication_array[3];
                Offset =4;
                
                
                //PrimaryInformation
                //clear
                for (i=0; i<PRIMARYINFORMATION_TEXTLENGTH; i++)
                    gAudioSD_CSI_PrimaryInformation[i] =0;
                
                for (i=0; i< length; i++)
                { 
                    gAudioSD_CSI_PrimaryInformation[i] =Indication_array[Offset];
                    Offset++;
                }

                //PIType
                gAudioSD_CSI_PI_Type =Indication_array[Offset];
                Offset++;

                //PIID
                gAudioSD_CSI_PIID =Indication_array[Offset]; 
                Offset++;
                gAudioSD_CSI_PIID +=Indication_array[Offset] *0x100;
                Offset++;

                
                //SecondaryInformation
                //clear
                for (i=0; i<SECONDARYINFORMATION_TEXTLENGTH; i++)
                    gAudioSD_CSI_SecondaryInformation[i] =0;
                
                length =Indication_array[Offset];
                Offset++;

                for (i=0; i< length; i++)
                { 
                    gAudioSD_CSI_SecondaryInformation[i] =Indication_array[Offset];
                    Offset++;
                }

                //SIType
                gAudioSD_CSI_SI_Type =Indication_array[Offset];
                Offset++;

                
                //TeritaryInformation
                //clear
                for (i=0; i<TERTIARYINFORMATION_TEXTLENGTH; i++)
                    gAudioSD_CSI_TertiaryInformation[i] =0;
                
                length =Indication_array[Offset];
                Offset++;

                for (i=0; i< length; i++)
                { 
                    gAudioSD_CSI_TertiaryInformation[i] =Indication_array[Offset];
                    Offset++;
                }

                //TIType
                gAudioSD_CSI_TI_Type =Indication_array[Offset];
                Offset++;

                
                //QuaternaryInformation
                //clear
                for (i=0; i<QUATERNARYINFORMATION_TEXTLENGTH; i++)
                    gAudioSD_CSI_QuarternaryInformation[i] =0;
                
                length =Indication_array[Offset];
                Offset++;

                for (i=0; i< length; i++)
                { 
                    gAudioSD_CSI_QuarternaryInformation[i] =Indication_array[Offset];
                    Offset++;
                }

                //QIType
                gAudioSD_CSI_QI_Type =Indication_array[Offset];
                Offset++;
                

                //StationInfoSwitches
                gAudioSD_CSI_StationInfoSwitches =Indication_array[Offset];
                Offset++;

                gAudioSD_CSI_TATP  =gAudioSD_CSI_StationInfoSwitches &0x01;
                gAudioSD_CSI_TMC   =(gAudioSD_CSI_StationInfoSwitches &0x02) /0x02;
                gAudioSD_CSI_VICS  =(gAudioSD_CSI_StationInfoSwitches &0x04) /0x04;
                gAudioSD_CSI_IBOC  =(gAudioSD_CSI_StationInfoSwitches &0x08) /0x08;
                
                //StationProperties
                gAudioSD_CSI_StationProperties =Indication_array[Offset];
                Offset++;
                
                gAudioSD_CSI_StationProperties_DABlinked    =gAudioSD_CSI_StationProperties &0x01;
                gAudioSD_CSI_StationProperties_IBOC         =(gAudioSD_CSI_StationProperties &0x02) /0x02;
                gAudioSD_CSI_StationProperties_DABservice   =(gAudioSD_CSI_StationProperties &0x04) /0x04;
                gAudioSD_CSI_StationProperties_OnlineRad    =(gAudioSD_CSI_StationProperties &0x08) /0x08;
                
                //ChannelID
                gAudioSD_CSI_ChannelID =Indication_array[Offset];
                Offset++;
                gAudioSD_CSI_ChannelID +=(Indication_array[Offset] *0x100);
                Offset++;
                                
				//Panel
                putvalue(env_ASG_AudioSD_CSI_PInfo_s, gAudioSD_CSI_PrimaryInformation);
                putvalue(env_ASG_AudioSD_CSI_SInfo_s, gAudioSD_CSI_SecondaryInformation);
                putvalue(env_ASG_AudioSD_CSI_TInfo_s, gAudioSD_CSI_TertiaryInformation);
                putvalue(env_ASG_AudioSD_CSI_QInfo_s, gAudioSD_CSI_QuarternaryInformation);
                
                if (gAudioSD_CSI_PI_Type<0x55)
                    putvalue(env_ASG_AudioSD_CSI_PType_s, gAudioSD_CSI_PI_Type_string[gAudioSD_CSI_PI_Type]);
                else
                    {
                    if(gAudioSD_CSI_PI_Type == 0x60)
                        putvalue(env_ASG_AudioSD_CSI_PType_s, gAudioSD_CSI_PI_Type_string[gAudioSD_CSI_PI_Type]);
                    else
                        putvalue(env_ASG_AudioSD_CSI_PType_s, gstring_reserved);
                    }             
                if (gAudioSD_CSI_SI_Type<0x55)
                    putvalue(env_ASG_AudioSD_CSI_SType_s, gAudioSD_CSI_SI_Type_string[gAudioSD_CSI_SI_Type]);
                else
                    {
                    if(gAudioSD_CSI_SI_Type == 0x60)
                        putvalue(env_ASG_AudioSD_CSI_SType_s, gAudioSD_CSI_SI_Type_string[gAudioSD_CSI_SI_Type]);
                    else
                        putvalue(env_ASG_AudioSD_CSI_SType_s, gstring_reserved);
                    }

                if (gAudioSD_CSI_TI_Type<0x55)
                    putvalue(env_ASG_AudioSD_CSI_TType_s, gAudioSD_CSI_TI_Type_string[gAudioSD_CSI_TI_Type]);
                else
                    {
                    if(gAudioSD_CSI_TI_Type == 0x60)
                        putvalue(env_ASG_AudioSD_CSI_TType_s, gAudioSD_CSI_TI_Type_string[gAudioSD_CSI_TI_Type]);
                    else
                        putvalue(env_ASG_AudioSD_CSI_TType_s, gstring_reserved);
                    }

                if (gAudioSD_CSI_QI_Type<0x55)
                    putvalue(env_ASG_AudioSD_CSI_QType_s, gAudioSD_CSI_QI_Type_string[gAudioSD_CSI_QI_Type]);
                else
                    {
                    if(gAudioSD_CSI_QI_Type == 0x60)
                        putvalue(env_ASG_AudioSD_CSI_QType_s, gAudioSD_CSI_QI_Type_string[gAudioSD_CSI_QI_Type]);
                    else
                        putvalue(env_ASG_AudioSD_CSI_QType_s, gstring_reserved);
                    }

                putvalue(env_ASG_AudioSD_CSI_PID, gAudioSD_CSI_PIID);

                putvalue(env_ASG_AudioSD_CSI_SIS_TA, gAudioSD_CSI_TATP);
                putvalue(env_ASG_AudioSD_CSI_SIS_TA_s, gAudioSD_CSI_StationInfoSwitches_string[gAudioSD_CSI_TATP]);

                putvalue(env_ASG_AudioSD_CSI_SIS_TMC, gAudioSD_CSI_TMC);
                putvalue(env_ASG_AudioSD_CSI_SIS_TMC_s, gAudioSD_CSI_StationInfoSwitches_string[gAudioSD_CSI_TMC]);

                putvalue(env_ASG_AudioSD_CSI_SIS_VICS, gAudioSD_CSI_VICS);
                putvalue(env_ASG_AudioSD_CSI_SIS_VICS_s, gAudioSD_CSI_StationInfoSwitches_string[gAudioSD_CSI_VICS]);

                putvalue(env_ASG_AudioSD_CSI_SIS_IBOC, gAudioSD_CSI_IBOC);
                putvalue(env_ASG_AudioSD_CSI_SIS_IBOC_s, gAudioSD_CSI_StationInfoSwitches_string[gAudioSD_CSI_IBOC]);
            
                putvalue(env_ASG_AudioSD_CSI_SP_Bit0,gAudioSD_CSI_StationProperties_DABlinked);
                putvalue(env_ASG_AudioSD_CSI_SP_Bit0_s,gAudioSD_CSI_StationProperties_Bit0_string[gAudioSD_CSI_StationProperties_DABlinked]);
                
                putvalue(env_ASG_AudioSD_CSI_SP_Bit1,gAudioSD_CSI_StationProperties_IBOC);
                putvalue(env_ASG_AudioSD_CSI_SP_Bit1_s,gAudioSD_CSI_StationProperties_Bit1_string[gAudioSD_CSI_StationProperties_IBOC]);

                putvalue(env_ASG_AudioSD_CSI_SP_Bit2,gAudioSD_CSI_StationProperties_DABservice);
                putvalue(env_ASG_AudioSD_CSI_SP_Bit2_s,gAudioSD_CSI_StationProperties_Bit2_string[gAudioSD_CSI_StationProperties_DABservice]);
                
                putvalue(env_ASG_AudioSD_CSI_SP_Bit3,gAudioSD_CSI_StationProperties_OnlineRad);
                putvalue(env_ASG_AudioSD_CSI_SP_Bit3_s,gAudioSD_CSI_StationProperties_Bit3_string[gAudioSD_CSI_StationProperties_OnlineRad]);


                putvalue(env_ASG_AudioSD_CSI_ChannelID,gAudioSD_CSI_ChannelID);
            }
        break;
			
        case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStationInfo_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

TPMemoInfo_Request (byte request)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_TPMemoInfo;	//Fct.-ID
	requestarray[2] =request;               //request type
	   
    switch (request)
	{
		case DataGet_REQ: 										
	        set_status_requestbuffer (requestarray, 3, Bap_Void);
            		 
         break;
		
        default:
			writelineEx(gError_Trace, 0, "ASG-AudioSD TPMemoInfo_Request: unknown request %d", request);
		break;
	}
}

TPMemoInfo_Indication (dword Indication_array [], int datalength)
{
    int i=0;

    switch (gBAP_Indication[2])
    {
	    case Data_IND:
            if(datalength>= 8) 
            {
                //get data
			    gAudioSD_TPMemoInfo_CurrentMsgNumber    =Indication_array[3];
                gAudioSD_TPMemoInfo_TotalMsgNumber      =Indication_array[4];
                gAudioSD_TPMemoInfo_hour                =Indication_array[5];
                gAudioSD_TPMemoInfo_minute              =Indication_array[6];
                
                //clear
                for (i=0; i<STATIONNAME_TEXTLENGTH; i++)
                    gAudioSD_TPMemoInfo_StationName[i] =0;

                for (i=0; i<Indication_array[7]; i++)
                    gAudioSD_TPMemoInfo_StationName[i] =Indication_array[8+i];
                                       
                //Panel
                putvalue(env_ASG_AudioSD_TPMemInfo_CMN, gAudioSD_TPMemoInfo_CurrentMsgNumber);
                putvalue(env_ASG_AudioSD_TPMemInfo_TMN,gAudioSD_TPMemoInfo_TotalMsgNumber);
                putvalue(env_ASG_AudioSD_TPMemInfo_MT_ho,gAudioSD_TPMemoInfo_hour);
                putvalue(env_ASG_AudioSD_TPMemInfo_MT_min,gAudioSD_TPMemoInfo_minute);
                putvalue(env_ASG_AudioSD_TPMemInfo_Name_s, gAudioSD_TPMemoInfo_StationName);
            }
        break;
			
        case Error_IND:
					
		    if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD TPMemoInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD TPMemoInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD TPMemoInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD TPMemoInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
		    writelineEx(gError_Trace, 0,"ASG-AudioSD TPMemoInfo_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
    }
}

ReceptionList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_ReceptionList;	//Fct.-ID
	requestarray[2] =request;               //request type

    switch(request)
	{
        case DataGet_REQ:              
                requestarray[3] =((gReceptionList_ASGID *0x10) &0xF0) +(gReceptionList_TAID &0x0F);
                requestarray[4] =gReceptionList_ElementType;
                requestarray[5] =(gReceptionList_ParentID &0x00FF);
                requestarray[6] =((gReceptionList_ParentID &0xFF00) /0x100);
                
                /***ArrayHeader***/
			    requestarray[7] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =8;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Request: invalid request %d", request);
		break;
    }
}

ReceptionList_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;
    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gReceptionList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gReceptionList_TAID  =Indication_array[3] &0x0F;
                
                gReceptionList_ElementType =Indication_array[4];
                
                gReceptionList_ParentID =Indication_array[5]; 
                gReceptionList_ParentID +=(Indication_array[6] *0x100);              

                gReceptionList_TotalNumListElements =Indication_array[7];
                gReceptionList_TotalNumListElements +=(Indication_array[8] *0x100);
              
                /***ArrayHeader***/
                mode            =(Indication_array[9] &0xF0) /0x10;
                recordaddress   =Indication_array[9] &0x0F;
                Offset =10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gReceptionList_Pos[i])  
                            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Type, Attributes, PResetID, FmREG_Code, Category, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Type, Attributes

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> PresetID, FmREG_Code, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 5: //recordaddress =5 -> Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 6: //recordaddress =6 -> Type, Attributes, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
                putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
                putvalue(env_ASG_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
                putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
                putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);

                gReceptionList_recordaddress =recordaddress;
                gReceptionList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                //get data  
                gReceptionList_ElementType =Indication_array[3];
                
                gReceptionList_ParentID =Indication_array[4]; 
                gReceptionList_ParentID +=(Indication_array[5] *0x100);              
              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_RL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_RL_ListOpState, "'full range update' received");
                }
                else if (datalength>11)
                {
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gReceptionList_Pos[i])  
                            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Type, Attributes, PResetID, FmREG_Code, Category, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Type, Attributes

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> PresetID, FmREG_Code, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 5: //recordaddress =5 -> Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 6: //recordaddress =6 -> Type,Attributes,Category,Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                }                   
                
                //Panel
                putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
                putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
                putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
                putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);

                gReceptionList_recordaddress =recordaddress;
                gReceptionList_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD ReceptionList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gReceptionList_TotalNumListElements<=AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE)
        gReceptionList_SlidingWindow_State =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gReceptionList_SlidingWindow_State =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE;

    if (gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK)
        ReceptionList_ListHandling ();
    else
        ReceptionList_display();
}

display_InfoList ()
{/*
    if (gInfoList_ONOFF==1)
	{
        putvalue(env_ASG_AudioSD_InfoList_Num, gInfoList_TotalNumListElements);
	
	    putvalue(env_ASG_AudioSD_InfoList_Name_1, gInfoList_Name[3]);
	    putvalue(env_ASG_AudioSD_InfoList_Type_1, gInfoList_Type_s[gInfoList_Type[3]]);
	    putvalue(env_ASG_AudioSD_InfoList_Pos_1, gInfoList_FSGHandle[3]);

        putvalue(env_ASG_AudioSD_InfoList_Name_2, gInfoList_Name[4]);
	    putvalue(env_ASG_AudioSD_InfoList_Type_2, gInfoList_Type_s[gInfoList_Type[4]]);
	    putvalue(env_ASG_AudioSD_InfoList_Pos_2, gInfoList_FSGHandle[4]);
    
        if (getvalue(env_ASG_AudioSD_SaveStation_Src) == 0x01 || getvalue(env_ASG_AudioSD_SaveStation_Src) == 0x02 || getvalue(env_ASG_AudioSD_SaveStation_Src) == 0x03)
            putvalue(env_ASG_AudioSD_SaveStation_fsgH, gInfoList_FSGHandle[4]);
        putvalue(env_ASG_AudioSD_DAC_FSGHandle, gInfoList_FSGHandle[4]);    

        putvalue(env_ASG_AudioSD_InfoList_Name_3, gInfoList_Name[5]);
	    putvalue(env_ASG_AudioSD_InfoList_Type_3, gInfoList_Type_s[gInfoList_Type[5]]);
        putvalue(env_ASG_AudioSD_InfoList_Pos_3, gInfoList_FSGHandle[5]);
    }
    */
}

AnnouncementInfo_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_AnnouncementInfo;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Request: invalid request %d", request);
		break;
	}
}

AnnouncementInfo_Indication (dword Indication_array [], int datalength)
{   
    int i =0;   
    
    switch (gBAP_Indication[2])
	{
	    case Data_IND:
            if(datalength >=2) 
            {
                //get data
				gAudioSD_AnnouncementInfo_Type =Indication_array[3];
                
                //clear
                for(i=0; i<ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
                    gAudioSD_AnnouncementInfo_StationName[i] =0;
                
                for(i=0; i<Indication_array[4]; i++)
                    gAudioSD_AnnouncementInfo_StationName[i] =Indication_array[5+i];

                //Panel
                if(gAudioSD_AnnouncementInfo_Type <0x0E)
                    putvalue(env_ASG_AudioSD_AnInf_Type_s, gAudioSD_AnnouncementInfo_Type_string[gAudioSD_AnnouncementInfo_Type]);
                
                else
                    putvalue(env_ASG_AudioSD_AnInf_Type_s, gstring_reserved);

                putvalue(env_ASG_AudioSD_AnInf_Name_s, gAudioSD_AnnouncementInfo_StationName);
             }
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		    break;
		    default:
			    writelineEx(gError_Trace, 0,"ASG-AudioSD AnnouncementInfo_Indication: unknown indication %x", gBAP_Indication[2]);
		    break;
	    }
}

InfoStates_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
        gAudioSD_InfoStates_States =Indication_array[3];
        
        //Panel
        if (gAudioSD_InfoStates_States <0x52)
            putvalue(env_ASG_AudioSD_InfoSt_States_s, gAudioSD_InfoStates_States_string[gAudioSD_InfoStates_States]);
        else if (gAudioSD_InfoStates_States ==0xff)
            putvalue(env_ASG_AudioSD_InfoSt_States_s,gstring_unknown);    
        else
            putvalue(env_ASG_AudioSD_InfoSt_States_s,gstring_reserved);
      break;
      case Error_IND:
  			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  			else if(Indication_array[3]<0x30)			//BPL-error
  				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  			else if(Indication_array[3]<0x40)			//BAL-error
  				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  			else
  				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD InfoStates_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
 }

InfoStates_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_InfoStates;	        //Fct.-ID
  	requestarray[2] =request;                   //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Request: invalid request %d", request);
  		break;
  	}
}

AnnouncementEscape_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_AnnouncementEscape;	    //Fct.-ID
	requestarray[2] =request;                       //request type
	
    switch(request)
	{
		case StartResult_REQ:

		    set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Request: invalid request %d", request);
		break;
	}
}

AnnouncementEscape_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
				
                gAudioSD_AnnoucementEsc_Result =Indication_array[3];
                if(gAudioSD_AnnoucementEsc_Result <0x05)	
					putvalue(env_ASG_AudioSD_AnE_Res_s, gAudioSD_AnnoucementEsc_Result_s[gAudioSD_AnnoucementEsc_Result]);   
				else
					putvalue(env_ASG_AudioSD_AnE_Res_s, gstring_reserved);               
		break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: Application-Error: 0x%x", Indication_array[3]);
                    putvalue(env_ASG_AudioSD_AnE_Err,Indication_array[3]);
                    
                    if (Indication_array[3] ==0)
                        putvalue(env_ASG_AudioSD_AnE_Err_s,"no error");
                    
                    else if((Indication_array[3]-0x40)<17)
                        putvalue(env_ASG_AudioSD_AnE_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
                    else
                        putvalue(env_ASG_AudioSD_AnE_Err_s,gstring_reserved);
                }
			
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD AnnouncementEscape_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

DedicatedAudioControl_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_DedicatedAudioControl;	//Fct.-ID
	requestarray[2] =request;                       //request type
	
    switch(request)
	{
		case StartResult_REQ:
            requestarray[3] =gAudioSD_DAC_CT;                 
		    requestarray[4] =gAudioSD_DAC_FSGhandle &0x00FF;
            requestarray[5] =(gAudioSD_DAC_FSGhandle &0xFF00) /0x100;
            requestarray[6] =gAudioSD_DAC_LT;

			set_status_requestbuffer (requestarray, 7, Bap_ByteSequence);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Request: invalid request %d", request);
		break;
	}
}

DedicatedAudioControl_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
        gAudioSD_DAC_Result =Indication_array[3];
        if(gAudioSD_DAC_Result <0x04)	
	        putvalue(env_ASG_AudioSD_DAC_Res_s, gAudioSD_DAC_Result_s[gAudioSD_DAC_Result]);   
				else
					putvalue(env_ASG_AudioSD_DAC_Res_s, gstring_reserved);               
		break;
		case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
            writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: Application-Error: 0x%x", Indication_array[3]);
            putvalue(env_ASG_AudioSD_DAC_Err,Indication_array[3]);
            if (Indication_array[3] ==0)
                putvalue(env_ASG_AudioSD_DAC_Err_s,"no error");
            else if((Indication_array[3]-0x40)<17)
                putvalue(env_ASG_AudioSD_DAC_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
            else
                putvalue(env_ASG_AudioSD_DAC_Err_s,gstring_reserved);
        }	
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD DedicatedAudioControl_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

on envVar env_ASG_AudioSD_DAC_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_DAC_CT         =getvalue(env_ASG_AudioSD_DAC_CT);
        gAudioSD_DAC_LT         =getvalue(env_ASG_AudioSD_DAC_LT);
        gAudioSD_DAC_FSGhandle  =getvalue(env_ASG_AudioSD_DAC_FSGHandle);

        putvalue(env_ASG_AudioSD_DAC_Err,0);
        putvalue(env_ASG_AudioSD_DAC_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_DAC_Res_s,empty_string);
        
        DedicatedAudioControl_Request(StartResult_REQ, 0);
	}
}

ReceptionListType_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				     gAudioSD_ReceptionListType_Type =Indication_array[3];
                
                //Panel
                if (gAudioSD_ReceptionListType_Type <0x0C)
                    putvalue(env_ASG_AudioSD_RecListTy_Type_s, gAudioSD_ReceptionListType_Type_string[gAudioSD_ReceptionListType_Type]);
                
                else if (gAudioSD_ReceptionListType_Type ==NORECEPTIONLISTAVAILABLE)
                    putvalue(env_ASG_AudioSD_RecListTy_Type_s, gAudioSD_ReceptionListType_Type_string_0xff);

                else
                    putvalue(env_ASG_AudioSD_RecListTy_Type_s, gstring_reserved);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionListType_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionListType_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionListType_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionListType_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD ReceptionListType_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
	
}

ReceptionListType_Request(byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ReceptionListType;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionListType_Request: invalid request %d", request);
		break;
	}
}

SourceList_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_SourceList;	    //Fct.-ID
	requestarray[2] =request;               //request type

    switch(request)
	{
        case DataGet_REQ:              
                requestarray[3] =((gSourceList_ASGID *0x10) &0xF0) +(gSourceList_TAID &0x0F);
                
                /***ArrayHeader***/
			    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Request: invalid request %d", request);
		break;
    }
}

SourceList_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;
    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gSourceList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gSourceList_TAID  =Indication_array[3] &0x0F;             

                gSourceList_TotalNumListElements =Indication_array[4];
                gSourceList_TotalNumListElements +=(Indication_array[5] *0x100);
              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSourceList_Pos[i])  
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                        
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                            
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Mediatype
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_SL_ASGID, gSourceList_ASGID);
                putvalue(env_ASG_AudioSD_SL_TAID, gSourceList_TAID);
                putvalue(env_ASG_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);

                gSourceList_recordaddress =recordaddress;
                gSourceList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                //get data
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_SL_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSourceList_Pos[i])  
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Mediatype
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }                  

                gSourceList_recordaddress =recordaddress;
                gSourceList_transmitpos   =transmitpos;             
                }
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SourceList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gSourceList_TotalNumListElements<=AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE)
        gSourceList_SlidingWindow_State =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gSourceList_SlidingWindow_State =AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE;

    if (gSourceList_CallBackReason !=AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK)
        SourceList_ListHandling ();
    else
        SourceList_display();
}

display_SourceList ()
{/*
byte Attributes_built, Attributes_Error, Attributes_playable, Attributes_read;
//only visible elements
/****first element****
	Attributes_built    =  (gSourceList_Attributes[3] & 0x01) / 0x01;
    Attributes_Error    =  (gSourceList_Attributes[3] & 0x02) / 0x02;
    Attributes_playable =  (gSourceList_Attributes[3] & 0x04) / 0x04;
    Attributes_read     =  (gSourceList_Attributes[3] & 0x08) / 0x08;	
    
    putvalue(env_ASG_AudioSD_SL_Name_1, gSourceList_Name[3]);
    putvalue(env_ASG_AudioSD_SL_Type_1, gSourceList_Type_s[gSourceList_Type[3]]);
	putvalue(env_ASG_AudioSD_SL_ID_1, gSourceList_InstanceID[3]);
    putvalue(env_ASG_AudioSD_SL_Pos_1, gSourceList_FSGHandle[3]);

    putvalue(env_ASG_AudioSD_SL_built_1,gSourceList_Attributes_built_s[Attributes_built]);
    putvalue(env_ASG_AudioSD_SL_Error_1,gSourceList_Attributes_Error_s[Attributes_Error]);
    putvalue(env_ASG_AudioSD_SL_playable_1,gSourceList_Attributes_playable_s[Attributes_playable]);
    putvalue(env_ASG_AudioSD_SL_read_1,gSourceList_Attributes_read_s[Attributes_read]);                                            

/****second element****   
    Attributes_built    =  (gSourceList_Attributes[4] & 0x01) / 0x01;
    Attributes_Error    =  (gSourceList_Attributes[4] & 0x02) / 0x02;
    Attributes_playable =  (gSourceList_Attributes[4] & 0x04) / 0x04;
    Attributes_read     =  (gSourceList_Attributes[4] & 0x08) / 0x08;	

    putvalue(env_ASG_AudioSD_SL_Name_2, gSourceList_Name[4]);
	putvalue(env_ASG_AudioSD_SL_Type_2, gSourceList_Type_s[gSourceList_Type[4]]);
	putvalue(env_ASG_AudioSD_SL_ID_2, gSourceList_InstanceID[4]);
    putvalue(env_ASG_AudioSD_SL_Pos_2, gSourceList_FSGHandle[4]);
    putvalue(env_ASG_AudioSD_SwSource_Ref, gSourceList_FSGHandle[4]);  

    putvalue(env_ASG_AudioSD_SL_built_2,gSourceList_Attributes_built_s[Attributes_built]);
    putvalue(env_ASG_AudioSD_SL_Error_2,gSourceList_Attributes_Error_s[Attributes_Error]);
    putvalue(env_ASG_AudioSD_SL_playable_2,gSourceList_Attributes_playable_s[Attributes_playable]);
    putvalue(env_ASG_AudioSD_SL_read_2,gSourceList_Attributes_read_s[Attributes_read]); 
    
/****third element****       
    
    Attributes_built    =  (gSourceList_Attributes[5] & 0x01) / 0x01;
    Attributes_Error    =  (gSourceList_Attributes[5] & 0x02) / 0x02;
    Attributes_playable =  (gSourceList_Attributes[5] & 0x04) / 0x04;
    Attributes_read     =  (gSourceList_Attributes[5] & 0x08) / 0x08;	

    putvalue(env_ASG_AudioSD_SL_Name_3, gSourceList_Name[5]);
	putvalue(env_ASG_AudioSD_SL_Type_3, gSourceList_Type_s[gSourceList_Type[5]]);
    putvalue(env_ASG_AudioSD_SL_ID_3, gSourceList_InstanceID[5]);
    putvalue(env_ASG_AudioSD_SL_Pos_3, gSourceList_FSGHandle[5]);

    putvalue(env_ASG_AudioSD_SL_built_3,gSourceList_Attributes_built_s[Attributes_built]);
    putvalue(env_ASG_AudioSD_SL_Error_3,gSourceList_Attributes_Error_s[Attributes_Error]);
    putvalue(env_ASG_AudioSD_SL_playable_3,gSourceList_Attributes_playable_s[Attributes_playable]);
    putvalue(env_ASG_AudioSD_SL_read_3,gSourceList_Attributes_read_s[Attributes_read]);*/
}

on envVar env_ASG_AudioSD_SL_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gSourceList_ListHandlingType      =AUDIO_SOURCELIST_BUILDUPCACHE;             //build-up complete cache...
            gSourceList_cacheBuildUp          =AUDIO_SOURCELIST_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            SourceList_ListHandling ();
        }
        else
        {
            gSourceList_SlidingWindow_State   =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
            gSourceList_ListHandlingType      =AUDIO_SOURCELIST_NOCACHE;
            gSourceList_cacheBuildUp          =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;
            gSourceList_CallBackReason        =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;

            gSourceList_cacheDown             =FALSE;
            gSourceList_cacheUp               =FALSE;
            gSourceList_LastFirstElement      =0;

            gSourceList_recordaddress         =0;
            gSourceList_transmitpos           =1;
            gSourceList_CursorAction          =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
            gSourceList_DisplayStatus         =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; j++)
            {     
                gSourceList_Pos[j]                              =0;
                gSourceList_SourceType[j]                       =0;
                gSourceList_InstanceID[j]                       =0;
                gSourceList_MediaType[j]                        =0;
                gSourceList_Attributes_BuiltIn_Bit0[j]          =0;
                gSourceList_Attributes_MediaError_Bit1[j]       =0;
                gSourceList_Attributes_MediaPlay_Bit2[j]        =0;
                gSourceList_Attributes_MediaRead_Bit3[j]        =0;
                gSourceList_Attributes_MediaLoad_Bit4[j]        =0;
                gSourceList_Attributes_ImportRun_Bit5[j]        =0;
                gSourceList_Attributes_MediaSupp_Bit6[j]        =0;
                gSourceList_Attributes[j]                       =0;
                gSourceList_ListEntryReceptionInformation[j]    =0;

                for(i=0;i<AUDIO_SOURCELIST_NAME_LENGTH;i++)
			        gSourceList_Name[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_SL_pos_0, 0);
            putvalue(env_ASG_AudioSD_SL_pos_1, 0);
            putvalue(env_ASG_AudioSD_SL_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_SL_SrcType_0, 0);
            putvalue(env_ASG_AudioSD_SL_SrcType_1, 0);
            putvalue(env_ASG_AudioSD_SL_SrcType_2, 0);

            putvalue(env_ASG_AudioSD_SL_SrcType_s_0,empty_string);
            putvalue(env_ASG_AudioSD_SL_SrcType_s_1,empty_string);
            putvalue(env_ASG_AudioSD_SL_SrcType_s_2,empty_string);

            putvalue(env_ASG_AudioSD_SL_IID_0, 0);
            putvalue(env_ASG_AudioSD_SL_IID_1, 0);
            putvalue(env_ASG_AudioSD_SL_IID_2, 0);

            putvalue(env_ASG_AudioSD_SL_MedType_0, 0);
            putvalue(env_ASG_AudioSD_SL_MedType_1, 0);
            putvalue(env_ASG_AudioSD_SL_MedType_2, 0);

            putvalue(env_ASG_AudioSD_SL_MedType_s_0,empty_string);
            putvalue(env_ASG_AudioSD_SL_MedType_s_1,empty_string);
            putvalue(env_ASG_AudioSD_SL_MedType_s_2,empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2, empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2, empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2, empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2, empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2, empty_string);

            putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, 0);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2, empty_string);
            
            putvalue(env_ASG_AudioSD_SL_Name_s_0, empty_string);
            putvalue(env_ASG_AudioSD_SL_Name_s_1, empty_string);
            putvalue(env_ASG_AudioSD_SL_Name_s_2, empty_string);
            
        }
    }
}   

SwitchSource_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
				
                gAudioSD_SwitchSource_Result =Indication_array[3];
                if(gAudioSD_SwitchSource_Result <0x04)	
					putvalue(env_ASG_AudioSD_SwSource_Res_s, gAudioSD_SwitchSource_Result_s[gAudioSD_SwitchSource_Result]);   
				else
					putvalue(env_ASG_AudioSD_SwSource_Res_s, gstring_reserved);               
		break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: Application-Error: 0x%x", Indication_array[3]);
                    putvalue(env_ASG_AudioSD_SwSource_Err,Indication_array[3]);
                    
                    if (Indication_array[3] ==0)
                        putvalue(env_ASG_AudioSD_SwSource_Err_s,"no error");
                    
                    else if((Indication_array[3]-0x40)<17)
                        putvalue(env_ASG_AudioSD_SwSource_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
                    else
                        putvalue(env_ASG_AudioSD_SwSource_Err_s,gstring_reserved);
                }
			
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SwitchSource_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

SwitchSource_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_SwitchSource;	//Fct.-ID
	requestarray[2] =request;               //request type
	
    switch(request)
	{
		case StartResult_REQ:               
		    requestarray[3] =gAudioSD_SwitchSource_Ref;

			set_status_requestbuffer (requestarray, 4, Bap_UInt16);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Request: invalid request %d", request);
		break;
	}
}

on envVar env_ASG_AudioSD_SrcSt_Set
{
	if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
		gAudioSD_SourceState_StateInfo  =getvalue(env_ASG_AudioSD_SrcSt_SateInfo);
        gAudioSD_SourceState_Scope      =getvalue(env_ASG_AudioSD_SrcSt_Scope);    
		
        SourceState_Request(DataSetGet_REQ);
	}
}

CurrentStationHandle_Indication (dword Indication_array [], int datalength)
{
	/*if(gBAP_Indication[5] !=4)
		writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BAP-datalength-error");
	else*/
	{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
                gAudioSD_CSIhandle_FSGhandle                =Indication_array[3] +(Indication_array[4] *0x100);
                gAudioSD_CSIhandle_FSGhandle_absolutePOS    =Indication_array[5] +(Indication_array[6] *0x100);
                gAudioSD_CSIhandle_PresetListRef            =Indication_array[7];
                gAudioSD_CSIhandle_PresetListabsolutePos    =Indication_array[8];
                gAudioSD_CSIhandle_DABEnsembleHandle        =Indication_array[9] +(Indication_array[10] *0x100);
                gAudioSD_CSIhandle_DABEnsembleAbsPos        =Indication_array[11] +(Indication_array[12] *0x100);
                
                //Panel
                putvalue(env_ASG_AudioSD_CSH_FSGh,gAudioSD_CSIhandle_FSGhandle);
                putvalue(env_ASG_AudioSD_CSH_FSGh_abs,gAudioSD_CSIhandle_FSGhandle_absolutePOS);
                putvalue(env_ASG_AudioSD_CSH_PL_Ref,gAudioSD_CSIhandle_PresetListRef);
                putvalue(env_ASG_AudioSD_CSH_PL_abs,gAudioSD_CSIhandle_PresetListabsolutePos);
                putvalue(env_ASG_AudioSD_CSH_DAB_E_han,gAudioSD_CSIhandle_DABEnsembleHandle);
                putvalue(env_ASG_AudioSD_CSH_DAB_E_abs,gAudioSD_CSIhandle_DABEnsembleAbsPos);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStationHandle_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
	}
}

CurrentStationHandle_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_CurrentStation_Handle;	//Fct.-ID
	requestarray[2] =request;                       //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Request: invalid request %d", request);
		break;
	}
}

MediaBrowserFolderLevel_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                    //LSG-ID
	requestarray[1] =FctID_MediaBrowser_FolderLevel;	//Fct.-ID
	requestarray[2] =request;                           //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Request: invalid request %d", request);
		break;
	}
}

MediaBrowserFolderLevel_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				gAudioSD_MediaBrowser_FL_FolderLevel            =Indication_array[3];
                gAudioSD_MediaBrowser_FL_RefMediaBrowser        =Indication_array[4] +(Indication_array[5] *0x100);
                gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos =Indication_array[6] +(Indication_array[7] *0x100);        
                
                //Panel
                putvalue(env_ASG_AudioSD_MeBrLevel_FL, gAudioSD_MediaBrowser_FL_FolderLevel);
                putvalue(env_ASG_AudioSD_MeBrLevel_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
                putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);      

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaBrowserFolderLevel_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

MediaPath_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_MediaPath;   //Fct.-ID
	requestarray[2] =request;           //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaPath_Request: invalid request %d", request);
		break;
	}
}

MediaPath_Indication (dword Indication_array [], int datalength)
{
    int i =0;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
            if(datalength>= 5) 
            {
                //get data
				gAudioSD_MediaPath_FolderType =Indication_array[3];
                
                //clear
                for (i=0; i<MEDIAPATH_PATH_TEXTLENGTH; i++)
                    gAudioSD_MediaPath_Path[i] =0;
                
                for (i=0; i<Indication_array[4]; i++)
                    gAudioSD_MediaPath_Path[i] =Indication_array[5+i];      
                
                //Panel
                if(gAudioSD_MediaPath_FolderType <0x55)
                  putvalue(env_ASG_AudioSD_MePath_Type_s, gAudioSD_MediaPath_FolderType_string[gAudioSD_MediaPath_FolderType]);
                else if (gAudioSD_MediaPath_FolderType <0xFF)
                  putvalue(env_ASG_AudioSD_MePath_Type_s, gstring_reserved);
                else
                  putvalue(env_ASG_AudioSD_MePath_Type_s, "not supported");

                putvalue(env_ASG_AudioSD_MePath_Path_s, gAudioSD_MediaPath_Path);
            }
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaPath_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaPath_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaPath_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaPath_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaPath_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

PreferredList_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
        gAudioSD_PreferredList_List =Indication_array[3];
               
        //Panel
        putValue(env_ASG_AudioSD_PrefList_List, gAudioSD_PreferredList_List);
        if(gAudioSD_PreferredList_List <0x06)
            putvalue(env_ASG_AudioSD_PrefList_List_s, gAudioSD_PreferredList_List_string[gAudioSD_PreferredList_List]);
        else
            putvalue(env_ASG_AudioSD_PrefList_List_s, gstring_reserved);
      break;
      case Error_IND:		
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PreferredList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PreferredList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PreferredList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD PreferredList_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD PreferredList_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

PreferredList_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_PreferredList;	//Fct.-ID
	requestarray[2] =request;               //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
 
		break;
        case DataSetGet_REQ:

            requestarray[3] = getValue(env_ASG_AudioSD_PrefList_List);		    
			set_status_requestbuffer (requestarray, 4, Bap_UInt8);

		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD PreferredList_Request: invalid request %d", request);
		break;
	}
}

SDSState_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
          //get data
	        gAudioSD_SDSState_State =Indication_array[3];
          
          //Panel
          putvalue(env_ASG_AudioSD_SDSState_State, gAudioSD_SDSState_State);
          if(gAudioSD_SDSState_State <0x13)
              putvalue(env_ASG_AudioSD_SDSState_State_s, gAudioSD_SDSState_State_string[gAudioSD_SDSState_State]);
          else
              putvalue(env_ASG_AudioSD_SDSState_State_s, gstring_reserved);
      break;
      case Error_IND:
  				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  				else if(Indication_array[3]<0x30)			//BPL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  				else if(Indication_array[3]<0x40)			//BAL-error
  					writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  				else
  					writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			  writelineEx(gError_Trace, 0,"ASG-AudioSD SDSState_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

SDSState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_SDS_State;	//Fct.-ID
	requestarray[2] =request;           //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
        case DataSetGet_REQ:

                requestarray[3] = gSDS_State_state;		    

			set_status_requestbuffer (requestarray, 4, Bap_UInt8);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Request: invalid request %d", request);
		break;
	}
}

ASGCapabilities_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ASG_Capabilities;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;

        case DataSetGet_REQ:

                requestarray[3] =gAudioSD_ASGCapabilities_PresentationCapabilities;		    

			set_status_requestbuffer (requestarray, 4, Bap_UInt8);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Request: invalid request %d", request);
		break;
	}
}

on envVar env_ASG_AudioSD_ASGCap_set
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
        gAudioSD_ASGCapabilities_PresentationCapabilities =getvalue(env_ASG_AudioSD_ASGCap_PrC_DAB);
        gAudioSD_ASGCapabilities_PresentationCapabilities +=(getvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS))*0x02;

        ASGCapabilities_Request(DataSetGet_REQ);
    }
}

ASGCapabilities_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                //get data
				gAudioSD_ASGCapabilities_PresentationCapabilities     =Indication_array[3];
         
                gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 =gAudioSD_ASGCapabilities_PresentationCapabilities &0x01;
                gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 =(gAudioSD_ASGCapabilities_PresentationCapabilities &0x02)/0x02;               
                
                //Panel
                putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
                putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0]);

                putvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
                putvalue(env_ASG_AudioSD_ASGCap_PrC_SDA_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1]);

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD ASGCapabilities_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

FunctionSynchronisation_Indication (dword Indication_array [], int datalength)
{   
    int i =0;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
                
                //clear
                for(i=0;i<8;i++)
                    gAudioSD_FunctionSynchronisation_FctList[i] =0;

                //get data
				        gAudioSD_FunctionSynchronisation_FctList[0] =Indication_array[3];
                gAudioSD_FunctionSynchronisation_FctList[1] =Indication_array[4];
                gAudioSD_FunctionSynchronisation_FctList[2] =Indication_array[5];
                gAudioSD_FunctionSynchronisation_FctList[3] =Indication_array[6];
                gAudioSD_FunctionSynchronisation_FctList[4] =Indication_array[7];
                gAudioSD_FunctionSynchronisation_FctList[5] =Indication_array[8];
                gAudioSD_FunctionSynchronisation_FctList[6] =Indication_array[9];
                gAudioSD_FunctionSynchronisation_FctList[7] =Indication_array[10];                
                                              
                //Byte 2
                gAudioSD_FunctionSynchronisation_FctList_Bit23  =gAudioSD_FunctionSynchronisation_FctList[2] &0x01;   
                gAudioSD_FunctionSynchronisation_FctList_Bit22  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x02) /0x02;
                gAudioSD_FunctionSynchronisation_FctList_Bit21  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x04) /0x04;
                gAudioSD_FunctionSynchronisation_FctList_Bit20  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_Bit19  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_Bit18  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_Bit17  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_Bit16  =(gAudioSD_FunctionSynchronisation_FctList[2] &0x80) /0x80;

                //Byte 3
                gAudioSD_FunctionSynchronisation_FctList_Bit31  =gAudioSD_FunctionSynchronisation_FctList[3] &0x01;   
                gAudioSD_FunctionSynchronisation_FctList_Bit30  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x02) /0x02;
                gAudioSD_FunctionSynchronisation_FctList_Bit29  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x04) /0x04;
                gAudioSD_FunctionSynchronisation_FctList_Bit28  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_Bit27  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_Bit26  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_Bit25  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_Bit24  =(gAudioSD_FunctionSynchronisation_FctList[3] &0x80) /0x80;

                //Byte 4
                gAudioSD_FunctionSynchronisation_FctList_Bit39  =gAudioSD_FunctionSynchronisation_FctList[4] &0x01;   
                gAudioSD_FunctionSynchronisation_FctList_Bit38  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x02) /0x02;
                gAudioSD_FunctionSynchronisation_FctList_Bit37  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x04) /0x04;
                gAudioSD_FunctionSynchronisation_FctList_Bit36  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_Bit35  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_Bit34  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_Bit33  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_Bit32  =(gAudioSD_FunctionSynchronisation_FctList[4] &0x80) /0x80;

                //Byte 5
                gAudioSD_FunctionSynchronisation_FctList_Bit47  =gAudioSD_FunctionSynchronisation_FctList[5] &0x01;   
                gAudioSD_FunctionSynchronisation_FctList_Bit46  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x02) /0x02;
                gAudioSD_FunctionSynchronisation_FctList_Bit45  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x04) /0x04;
                gAudioSD_FunctionSynchronisation_FctList_Bit44  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_Bit43  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_Bit42  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_Bit41  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_Bit40  =(gAudioSD_FunctionSynchronisation_FctList[5] &0x80) /0x80;

                //Byte 6
                gAudioSD_FunctionSynchronisation_FctList_2_Bit07  =gAudioSD_FunctionSynchronisation_FctList[6] &0x01;   
                gAudioSD_FunctionSynchronisation_FctList_2_Bit06  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x02) /0x02;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit05  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x04) /0x04;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit04  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit03  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit02  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit01  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_2_Bit00  =(gAudioSD_FunctionSynchronisation_FctList[6] &0x80) /0x80;
                
                //Byte 7
                gAudioSD_FunctionSynchronisation_FctList_3_Bit04  =(gAudioSD_FunctionSynchronisation_FctList[7] &0x08) /0x08;
                gAudioSD_FunctionSynchronisation_FctList_3_Bit03  =(gAudioSD_FunctionSynchronisation_FctList[7] &0x10) /0x10;
                gAudioSD_FunctionSynchronisation_FctList_3_Bit02  =(gAudioSD_FunctionSynchronisation_FctList[7] &0x20) /0x20;
                gAudioSD_FunctionSynchronisation_FctList_3_Bit01  =(gAudioSD_FunctionSynchronisation_FctList[7] &0x40) /0x40;
                gAudioSD_FunctionSynchronisation_FctList_3_Bit00  =(gAudioSD_FunctionSynchronisation_FctList[7] &0x80) /0x80;


                //Panel
                putvalue(env_ASG_AudioSD_FctSyn_Bit16,gAudioSD_FunctionSynchronisation_FctList_Bit16);
                putvalue(env_ASG_AudioSD_FctSyn_Bit17,gAudioSD_FunctionSynchronisation_FctList_Bit17);
                putvalue(env_ASG_AudioSD_FctSyn_Bit18,gAudioSD_FunctionSynchronisation_FctList_Bit18);
                putvalue(env_ASG_AudioSD_FctSyn_Bit19,gAudioSD_FunctionSynchronisation_FctList_Bit19);
                putvalue(env_ASG_AudioSD_FctSyn_Bit20,gAudioSD_FunctionSynchronisation_FctList_Bit20);
                putvalue(env_ASG_AudioSD_FctSyn_Bit21,gAudioSD_FunctionSynchronisation_FctList_Bit21);
                putvalue(env_ASG_AudioSD_FctSyn_Bit22,gAudioSD_FunctionSynchronisation_FctList_Bit22);
                putvalue(env_ASG_AudioSD_FctSyn_Bit23,gAudioSD_FunctionSynchronisation_FctList_Bit23);
                putvalue(env_ASG_AudioSD_FctSyn_Bit24,gAudioSD_FunctionSynchronisation_FctList_Bit24);
                putvalue(env_ASG_AudioSD_FctSyn_Bit25,gAudioSD_FunctionSynchronisation_FctList_Bit25);
                putvalue(env_ASG_AudioSD_FctSyn_Bit26,gAudioSD_FunctionSynchronisation_FctList_Bit26);
                putvalue(env_ASG_AudioSD_FctSyn_Bit27,gAudioSD_FunctionSynchronisation_FctList_Bit27);
                putvalue(env_ASG_AudioSD_FctSyn_Bit28,gAudioSD_FunctionSynchronisation_FctList_Bit28);
                putvalue(env_ASG_AudioSD_FctSyn_Bit29,gAudioSD_FunctionSynchronisation_FctList_Bit29);
                putvalue(env_ASG_AudioSD_FctSyn_Bit30,gAudioSD_FunctionSynchronisation_FctList_Bit30);
                putvalue(env_ASG_AudioSD_FctSyn_Bit31,gAudioSD_FunctionSynchronisation_FctList_Bit31);
                putvalue(env_ASG_AudioSD_FctSyn_Bit32,gAudioSD_FunctionSynchronisation_FctList_Bit32);
                putvalue(env_ASG_AudioSD_FctSyn_Bit33,gAudioSD_FunctionSynchronisation_FctList_Bit33);
                putvalue(env_ASG_AudioSD_FctSyn_Bit34,gAudioSD_FunctionSynchronisation_FctList_Bit34);
                putvalue(env_ASG_AudioSD_FctSyn_Bit35,gAudioSD_FunctionSynchronisation_FctList_Bit35);
                putvalue(env_ASG_AudioSD_FctSyn_Bit36,gAudioSD_FunctionSynchronisation_FctList_Bit36);
                putvalue(env_ASG_AudioSD_FctSyn_Bit37,gAudioSD_FunctionSynchronisation_FctList_Bit37);
                putvalue(env_ASG_AudioSD_FctSyn_Bit38,gAudioSD_FunctionSynchronisation_FctList_Bit38);
                putvalue(env_ASG_AudioSD_FctSyn_Bit39,gAudioSD_FunctionSynchronisation_FctList_Bit39);
                putvalue(env_ASG_AudioSD_FctSyn_Bit40,gAudioSD_FunctionSynchronisation_FctList_Bit40);
                putvalue(env_ASG_AudioSD_FctSyn_Bit41,gAudioSD_FunctionSynchronisation_FctList_Bit41);
                putvalue(env_ASG_AudioSD_FctSyn_Bit42,gAudioSD_FunctionSynchronisation_FctList_Bit42);
                putvalue(env_ASG_AudioSD_FctSyn_Bit43,gAudioSD_FunctionSynchronisation_FctList_Bit43);
                putvalue(env_ASG_AudioSD_FctSyn_Bit44,gAudioSD_FunctionSynchronisation_FctList_Bit44);
                putvalue(env_ASG_AudioSD_FctSyn_Bit45,gAudioSD_FunctionSynchronisation_FctList_Bit45);
                putvalue(env_ASG_AudioSD_FctSyn_Bit46,gAudioSD_FunctionSynchronisation_FctList_Bit46);
                putvalue(env_ASG_AudioSD_FctSyn_Bit47,gAudioSD_FunctionSynchronisation_FctList_Bit47);

                putvalue(env_ASG_AudioSD_FctSyn_2_Bit00,gAudioSD_FunctionSynchronisation_FctList_2_Bit00);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit01,gAudioSD_FunctionSynchronisation_FctList_2_Bit01);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit02,gAudioSD_FunctionSynchronisation_FctList_2_Bit02);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit03,gAudioSD_FunctionSynchronisation_FctList_2_Bit03);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit04,gAudioSD_FunctionSynchronisation_FctList_2_Bit04);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit05,gAudioSD_FunctionSynchronisation_FctList_2_Bit05);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit06,gAudioSD_FunctionSynchronisation_FctList_2_Bit06);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit07,gAudioSD_FunctionSynchronisation_FctList_2_Bit07);
                
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit00,gAudioSD_FunctionSynchronisation_FctList_3_Bit00);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit01,gAudioSD_FunctionSynchronisation_FctList_3_Bit01);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit02,gAudioSD_FunctionSynchronisation_FctList_3_Bit02);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit03,gAudioSD_FunctionSynchronisation_FctList_3_Bit03);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit04,gAudioSD_FunctionSynchronisation_FctList_3_Bit04);

                putvalue(env_ASG_AudioSD_FctSyn_Bit16_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit16]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit17_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit17]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit18_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit18]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit19_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit19]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit20_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit20]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit21_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit21]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit22_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit22]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit23_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit23]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit24_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit24]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit25_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit25]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit26_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit26]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit27_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit27]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit28_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit28]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit29_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit29]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit30_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit30]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit31_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit31]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit32_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit32]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit33_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit33]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit34_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit34]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit35_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit35]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit36_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit36]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit37_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit37]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit38_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit38]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit39_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit39]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit40_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit40]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit41_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit41]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit42_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit42]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit43_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit43]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit44_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit44]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit45_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit45]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit46_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit46]);
                putvalue(env_ASG_AudioSD_FctSyn_Bit47_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_Bit47]);

                putvalue(env_ASG_AudioSD_FctSyn_2_Bit00_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit00]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit01_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit01]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit02_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit02]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit03_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit03]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit04_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit04]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit05_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit05]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit06_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit06]);
                putvalue(env_ASG_AudioSD_FctSyn_2_Bit07_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_2_Bit07]);
                
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit00_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_3_Bit00]);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit01_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_3_Bit01]);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit02_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_3_Bit02]);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit03_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_3_Bit03]);
                putvalue(env_ASG_AudioSD_FctSyn_3_Bit04_s,gAudioSD_FunctionSynchronisation_FctList_string[gAudioSD_FunctionSynchronisation_FctList_3_Bit04]);
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionSynchronisation_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionSynchronisation_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionSynchronisation_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionSynchronisation_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD FunctionSynchronisation_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

FunctionSynchronisation_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_FunctionSynchronisation;	//Fct.-ID
	requestarray[2] =request;                       //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionSynchronisation_Request: invalid request %d", request);
		break;
	}
}

display_FunctionSynchronisation ()
{
    putvalue(env_ASG_AudioSD_FctSyn_Bit16, (gAudioSD_FunctionSynchronisation_FctList[2] &0x01));
    putvalue(env_ASG_AudioSD_FctSyn_Bit16_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x01)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit17, (gAudioSD_FunctionSynchronisation_FctList[2] &0x02));
    putvalue(env_ASG_AudioSD_FctSyn_Bit17_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x02)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit18, (gAudioSD_FunctionSynchronisation_FctList[2] &0x04));
    putvalue(env_ASG_AudioSD_FctSyn_Bit18_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x04)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit19, (gAudioSD_FunctionSynchronisation_FctList[2] &0x08));
    putvalue(env_ASG_AudioSD_FctSyn_Bit19_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x08)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit20, (gAudioSD_FunctionSynchronisation_FctList[2] &0x10));
    putvalue(env_ASG_AudioSD_FctSyn_Bit20_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x10)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit21, (gAudioSD_FunctionSynchronisation_FctList[2] &0x20));
    putvalue(env_ASG_AudioSD_FctSyn_Bit21_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x20)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit22, (gAudioSD_FunctionSynchronisation_FctList[2] &0x40));
    putvalue(env_ASG_AudioSD_FctSyn_Bit22_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x40)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit23, (gAudioSD_FunctionSynchronisation_FctList[2] &0x80));
    putvalue(env_ASG_AudioSD_FctSyn_Bit23_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[2] &0x80)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit24, (gAudioSD_FunctionSynchronisation_FctList[3] &0x01));
    putvalue(env_ASG_AudioSD_FctSyn_Bit24_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x01)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit25, (gAudioSD_FunctionSynchronisation_FctList[3] &0x02));
    putvalue(env_ASG_AudioSD_FctSyn_Bit25_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x02)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit26, (gAudioSD_FunctionSynchronisation_FctList[3] &0x04));
    putvalue(env_ASG_AudioSD_FctSyn_Bit26_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x04)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit27, (gAudioSD_FunctionSynchronisation_FctList[3] &0x08));
    putvalue(env_ASG_AudioSD_FctSyn_Bit27_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x08)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit28, (gAudioSD_FunctionSynchronisation_FctList[3] &0x10));
    putvalue(env_ASG_AudioSD_FctSyn_Bit28_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x10)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit29, (gAudioSD_FunctionSynchronisation_FctList[3] &0x20));
    putvalue(env_ASG_AudioSD_FctSyn_Bit29_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x20)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit30, (gAudioSD_FunctionSynchronisation_FctList[3] &0x40));
    putvalue(env_ASG_AudioSD_FctSyn_Bit30_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x40)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit31, (gAudioSD_FunctionSynchronisation_FctList[3] &0x80));
    putvalue(env_ASG_AudioSD_FctSyn_Bit31_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[3] &0x80)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit32, (gAudioSD_FunctionSynchronisation_FctList[4] &0x01));
    putvalue(env_ASG_AudioSD_FctSyn_Bit32_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x01)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit33, (gAudioSD_FunctionSynchronisation_FctList[4] &0x02));
    putvalue(env_ASG_AudioSD_FctSyn_Bit33_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x02)]);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit34, (gAudioSD_FunctionSynchronisation_FctList[4] &0x04));
    putvalue(env_ASG_AudioSD_FctSyn_Bit34_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x04)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit35, (gAudioSD_FunctionSynchronisation_FctList[4] &0x08));
    putvalue(env_ASG_AudioSD_FctSyn_Bit35_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x08)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit36, (gAudioSD_FunctionSynchronisation_FctList[4] &0x10));
    putvalue(env_ASG_AudioSD_FctSyn_Bit36_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x10)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit37, (gAudioSD_FunctionSynchronisation_FctList[4] &0x20));
    putvalue(env_ASG_AudioSD_FctSyn_Bit37_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x20)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit38, (gAudioSD_FunctionSynchronisation_FctList[4] &0x40));
    putvalue(env_ASG_AudioSD_FctSyn_Bit38_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x40)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit39, (gAudioSD_FunctionSynchronisation_FctList[4] &0x80));
    putvalue(env_ASG_AudioSD_FctSyn_Bit39_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[4] &0x80)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit40, (gAudioSD_FunctionSynchronisation_FctList[5] &0x01));
    putvalue(env_ASG_AudioSD_FctSyn_Bit40_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[5] &0x01)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit41, (gAudioSD_FunctionSynchronisation_FctList[5] &0x02));
    putvalue(env_ASG_AudioSD_FctSyn_Bit41_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[5] &0x02)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit42, (gAudioSD_FunctionSynchronisation_FctList[5] &0x04));
    putvalue(env_ASG_AudioSD_FctSyn_Bit42_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[5] &0x04)]);

    putvalue(env_ASG_AudioSD_FctSyn_Bit43, (gAudioSD_FunctionSynchronisation_FctList[5] &0x10));
    putvalue(env_ASG_AudioSD_FctSyn_Bit43_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[5] &0x10)]);
                
    putvalue(env_ASG_AudioSD_FctSyn_Bit44, (gAudioSD_FunctionSynchronisation_FctList[5] &0x20));
    putvalue(env_ASG_AudioSD_FctSyn_Bit44_s, gAudioSD_FunctionSynchronisation_FctList_string[(gAudioSD_FunctionSynchronisation_FctList[5] &0x20)]);
}

RadioTVPresetList_Indication(dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;
    
    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gRadioTVPresetList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gRadioTVPresetList_TAID  =Indication_array[3] &0x0F;             

                gRadioTVPresetList_TotalNumListElements =Indication_array[4];
              
                /***ArrayHeader***/
                mode            =(Indication_array[5] &0xF0) /0x10;
                recordaddress   =Indication_array[5] &0x0F;
                Offset =6;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 
                
                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gRadioTVPresetList_Pos[i])  
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record
                         
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> PresetIndex, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
                putvalue(env_ASG_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
                putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);

                gRadioTVPresetList_recordaddress =recordaddress;
                gRadioTVPresetList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                //get data
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gRadioTVPresetList_Pos[i])  
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_RTPL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_RTPL_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> PresetIndex, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }                  
                }
                gRadioTVPresetList_recordaddress =recordaddress;
                gRadioTVPresetList_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD RadioTVPresetList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gRadioTVPresetList_TotalNumListElements<=AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE)
        gRadioTVPresetList_SlidingWindow_State =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gRadioTVPresetList_SlidingWindow_State =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE;

    if (gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK)
        RadioTVPresetList_ListHandling ();
    else
        RadioTVPresetList_display();
}

RadioTVPresetList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_RadioTV_PresetList;	//Fct.-ID
	requestarray[2] =request;                   //request type
    
    switch(request)
	{
        case DataGet_REQ:            
                requestarray[3] =((gRadioTVPresetList_ASGID *0x10) &0xF0) +(gRadioTVPresetList_TAID &0x0F);
                
                /***ArrayHeader***/
			    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Request: invalid request %d", request);
		break;
    }
}

MediaBrowser_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gMediaBrowser_ASGID =(Indication_array[3] &0xF0) /0x10;
                gMediaBrowser_TAID  =Indication_array[3] &0x0F;
                
                gMediaBrowser_TotalNumListElements =Indication_array[4];
                gMediaBrowser_TotalNumListElements +=(Indication_array[5] *0x100);
                
                gMediaBrowser_ActiveListPos =Indication_array[6]; 
                gMediaBrowser_ActiveListPos +=(Indication_array[7] *0x100);                              
              
                /***ArrayHeader***/
                mode            =(Indication_array[8] &0xF0) /0x10;
                recordaddress   =Indication_array[8] &0x0F;
                Offset =9;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gMediaBrowser_Pos[i])  
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                   
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> FileName
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
                putvalue(env_ASG_AudioSD_MB_TAID, gMediaBrowser_TAID);
                putvalue(env_ASG_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
                putvalue(env_ASG_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);

                gMediaBrowser_recordaddress =recordaddress;
                gMediaBrowser_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                             
              /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gMediaBrowser_Pos[i])  
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;              
                    }
                }

                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_MB_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_MB_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                   
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> FileName
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                }                   
                
                //Panel
                gMediaBrowser_recordaddress =recordaddress;
                gMediaBrowser_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowser_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowser_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowser_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowser_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaBrowser_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gMediaBrowser_TotalNumListElements<=AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE)
        gMediaBrowser_SlidingWindow_State =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
    else
        gMediaBrowser_SlidingWindow_State =AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE;

    if (gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK)
        MediaBrowser_ListHandling ();
    else
        MediaBrowser_display();
}

MediaBrowser_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_MediaBrowser;	//Fct.-ID
	requestarray[2] =request;               //request type

    switch(request)
	{
        case DataGet_REQ:              
                requestarray[3] =((gMediaBrowser_ASGID *0x10) &0xF0) +(gMediaBrowser_TAID &0x0F);
                
                /***ArrayHeader***/
			    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowser_Request: invalid request %d", request);
		break;
    }
}

MediaBrowserControl_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
				
                gAudioSD_MBrC_Result =Indication_array[3];
                if(gAudioSD_MBrC_Result <0x04)	
					putvalue(env_ASG_AudioSD_MBrC_Res_s, gAudioSD_MBrC_Result_s[gAudioSD_MBrC_Result]);   
				else
					putvalue(env_ASG_AudioSD_MBrC_Res_s, gstring_reserved);               
		break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserControl_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserControl_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserControl_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserControl_Indication: Application-Error: 0x%x", Indication_array[3]);
                    putvalue(env_ASG_AudioSD_MBrC_Err,Indication_array[3]);
                    
                    if (Indication_array[3] ==0)
                        putvalue(env_ASG_AudioSD_MBrC_Err_s,"no error");
                    
                    else if((Indication_array[3]-0x40)<17)
                        putvalue(env_ASG_AudioSD_MBrC_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
                    else
                        putvalue(env_ASG_AudioSD_MBrC_Err_s,gstring_reserved); 
                }
			
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaBrowserControl_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

MediaBrowserControl_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_MediaBrowserControl;	    //Fct.-ID
	requestarray[2] =request;                       //request type
	
    switch(request)
	{
		case StartResult_REQ:
            requestarray[3] =gAudioSD_MBrC_Control;                 
		    requestarray[4] =gAudioSD_MBrC_Ref &0x00FF;
            requestarray[5] =(gAudioSD_MBrC_Ref &0xFF00) /0x100;

			set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserControl_Request: invalid request %d", request);
		break;
	}
}

MediaFileInfo_Indication (dword Indication_array [], int datalength)
{
    int i =0, Offset =0, length =0;
	
    switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
				
            if(datalength >=5) 
            {
                gAudioSD_MediaFileInfo_Result =Indication_array[3];

                //Artist
                //clear string
                for(i=0; i<AUDIO_MEDIAFILINFO_ARTIST_LENGTH; i++)
                    gAudioSD_MediaFileInfo_Artist_s[i] =0;
                    
                length =Indication_array[4];
                Offset=5;

                for (i=0; i<length;i++)
                {
                    gAudioSD_MediaFileInfo_Artist_s[i]  =Indication_array[Offset];
                    Offset++;
                }

                //Title
                //clear string
                for(i=0; i<AUDIO_MEDIAFILINFO_TITLE_LENGTH; i++)
                    gAudioSD_MediaFileInfo_Title_s[i] =0;
                    
                length =Indication_array[Offset];
                Offset++;

                for (i=0; i<length;i++)
                {
                    gAudioSD_MediaFileInfo_Title_s[i]  =Indication_array[Offset];
                    Offset++;
                }

                //Album
                //clear string
                for(i=0; i<AUDIO_MEDIAFILINFO_ALBUM_LENGTH; i++)
                    gAudioSD_MediaFileInfo_Album_s[i] =0;
                    
                length =Indication_array[Offset];
                Offset++;

                for (i=0; i<length;i++)
                {
                    gAudioSD_MediaFileInfo_Album_s[i]  =Indication_array[Offset];
                    Offset++;
                } 
                
                //Panel
                if(gAudioSD_MediaFileInfo_Result <0x04)	
					putvalue(env_ASG_AudioSD_MFI_Res_s, gAudioSD_MediaFileInfo_Result_s[gAudioSD_MediaFileInfo_Result]);   
				else
					putvalue(env_ASG_AudioSD_MFI_Res_s, gstring_reserved);  

                putvalue(env_ASG_AudioSD_MFI_Artist_s, gAudioSD_MediaFileInfo_Artist_s);
                putvalue(env_ASG_AudioSD_MFI_Title_s, gAudioSD_MediaFileInfo_Title_s);
                putvalue(env_ASG_AudioSD_MFI_Album_s, gAudioSD_MediaFileInfo_Album_s);             
            }		
        break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaFileInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaFileInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaFileInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD MediaFileInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
                    putvalue(env_ASG_AudioSD_MFI_Err,Indication_array[3]);
                    
                    if (Indication_array[3] ==0)
                        putvalue(env_ASG_AudioSD_MFI_Err_s,"no error");
                    
                    else if((Indication_array[3]-0x40)<17)
                        putvalue(env_ASG_AudioSD_MFI_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
                    else
                        putvalue(env_ASG_AudioSD_MFI_Err_s,gstring_reserved);
                }
			
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaFileInfo_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

MediaFileInfo_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_MediaFileInfo;	//Fct.-ID
	requestarray[2] =request;               //request type
	
    switch(request)
	{
		case StartResult_REQ:               
		    requestarray[3] =gAudioSD_MediaFileInfo_Ref;

			set_status_requestbuffer (requestarray, 4, Bap_UInt16);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaFileInfo_Request: invalid request %d", request);
		break;
	}
}

GetNextListPos_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
				
                gAudioSD_GetNextListPos_Result          =Indication_array[3];
                gAudioSD_GetNextListPos_CurrentPos      =Indication_array[4] +(Indication_array[5] *0x100);
                gAudioSD_GetNextListPos_nextPos         =Indication_array[6] +(Indication_array[7] *0x100);
                gAudioSD_GetNextListPos_absoluteListPos =Indication_array[8] +(Indication_array[9] *0x100);

                //Panel
                if(gAudioSD_GetNextListPos_Result <0x04)	
        					putvalue(env_ASG_AudioSD_GNLP_Res_s, gAudioSD_GetNextListPos_Result_string[gAudioSD_GetNextListPos_Result]);   
        				else
        					putvalue(env_ASG_AudioSD_GNLP_Res_s, gstring_reserved);
                    
                putvalue(env_ASG_AudioSD_GNLP_CurrPos, gAudioSD_GetNextListPos_CurrentPos);
                putvalue(env_ASG_AudioSD_GNLP_nextPos, gAudioSD_GetNextListPos_nextPos);
                putvalue(env_ASG_AudioSD_GNLP_AbsPos, gAudioSD_GetNextListPos_absoluteListPos);               
		break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GetNextListPos_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GetNextListPos_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD GetNextListPos_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD GetNextListPos_Indication: Application-Error: 0x%x", Indication_array[3]);
                    putvalue(env_ASG_AudioSD_GNLP_Err,Indication_array[3]);
                    
                    if (Indication_array[3] ==0)
                        putvalue(env_ASG_AudioSD_GNLP_Err_s,"no error");
                    
                    else if((Indication_array[3]-0x40)<17)
                        putvalue(env_ASG_AudioSD_GNLP_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
                    else
                        putvalue(env_ASG_AudioSD_GNLP_Err_s,gstring_reserved); 
                }
			
		        
        break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD GetNextListPos_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

GetNextListPos_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_GetNextListPos;	//Fct.-ID
	requestarray[2] =request;               //request type
	
    switch(request)
	{
		case StartResult_REQ:                
		    requestarray[3] =gAudioSD_GetNextListPos_CurrentPos &0x00FF;
            requestarray[4] =(gAudioSD_GetNextListPos_CurrentPos &0xFF00) /0x100;
            requestarray[5] =gAudioSD_GetNextListPos_Offset &0x00FF;
            requestarray[6] =(gAudioSD_GetNextListPos_Offset &0xFF00) /0x100;
            requestarray[7] =gAudioSD_GetNextListPos_ListType;

			set_status_requestbuffer (requestarray, 8, Bap_ByteSequence);
		break;
        case AbortResult_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD GetNextListPos_Request: invalid request %d", request);
		break;
	}
}

on envVar env_ASG_AudioSD_DAC_Abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {        
        DedicatedAudioControl_Request(AbortResult_REQ, 0);
        
        putvalue(env_ASG_AudioSD_DAC_Err,0);
        putvalue(env_ASG_AudioSD_DAC_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_DAC_Res_s,empty_string);
    }
}

on envVar env_ASG_AudioSD_AnE_SR
{
    if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        putvalue(env_ASG_AudioSD_AnE_Err,0);
        putvalue(env_ASG_AudioSD_AnE_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_AnE_Res_s,empty_string);
        
        AnnouncementEscape_Request(StartResult_REQ, 0);
    }
}

on envVar env_ASG_AudioSD_AnE_Abort
{
    if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        AnnouncementEscape_Request(AbortResult_REQ, 0);
        
        putvalue(env_ASG_AudioSD_AnE_Err,0);
        putvalue(env_ASG_AudioSD_AnE_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_AnE_Res_s,empty_string);
    }
}

on envVar env_ASG_AudioSD_SwSource_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        gAudioSD_SwitchSource_Ref  =getvalue(env_ASG_AudioSD_SwSource_Ref);

        putvalue(env_ASG_AudioSD_SwSource_Err,0);
        putvalue(env_ASG_AudioSD_SwSource_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_SwSource_Res_s,empty_string);
        
        SwitchSource_Request(StartResult_REQ, 0);
    }
}

on envVar env_ASG_AudioSD_SwSource_abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        putvalue(env_ASG_AudioSD_SwSource_Err,0);
        putvalue(env_ASG_AudioSD_SwSource_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_SwSource_Res_s,empty_string);

        SwitchSource_Request(AbortResult_REQ, 0);
    }
}

on envVar env_ASG_AudioSD_MBrC_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_MBrC_Control     =getvalue(env_ASG_AudioSD_MBrC_Control);
        gAudioSD_MBrC_Ref         =getvalue(env_ASG_AudioSD_MBrC_Ref);

        putvalue(env_ASG_AudioSD_MBrC_Err,0);
        putvalue(env_ASG_AudioSD_MBrC_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_MBrC_Res_s,empty_string);
        
        MediaBrowserControl_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_MBrC_Abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        putvalue(env_ASG_AudioSD_MBrC_Err,0);
        putvalue(env_ASG_AudioSD_MBrC_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_MBrC_Res_s,empty_string);
            
        MediaBrowserControl_Request(AbortResult_REQ, 0);
    }
}

on envVar env_ASG_AudioSD_MFI_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_MediaFileInfo_Ref  =getvalue(env_ASG_AudioSD_MFI_Ref);

        putvalue(env_ASG_AudioSD_MFI_Err,0);
        putvalue(env_ASG_AudioSD_MFI_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_MFI_Res_s,empty_string);
        
        MediaFileInfo_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_MFI_abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        putvalue(env_ASG_AudioSD_MFI_Err,0);
        putvalue(env_ASG_AudioSD_MFI_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_MFI_Res_s,empty_string);

        MediaFileInfo_Request(AbortResult_REQ, 0);
    }
}

on envVar env_ASG_AudioSD_GNLP_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_GetNextListPos_CurrentPos  =getvalue(env_ASG_AudioSD_GNLP_CurrPos);
        gAudioSD_GetNextListPos_Offset      =getvalue(env_ASG_AudioSD_GNLP_Offset);
        gAudioSD_GetNextListPos_ListType    =getvalue(env_ASG_AudioSD_GNLP_LT);

        putvalue(env_ASG_AudioSD_GNLP_Err,0);
        putvalue(env_ASG_AudioSD_GNLP_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_GNLP_Res_s,empty_string);
        
        GetNextListPos_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_GNLP_abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
    {
        putvalue(env_ASG_AudioSD_GNLP_Err,0);
        putvalue(env_ASG_AudioSD_GNLP_Err_s,empty_string);
        putvalue(env_ASG_AudioSD_GNLP_Res_s,empty_string);

        GetNextListPos_Request(AbortResult_REQ, 0);
    }
}

int ReceptionList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gReceptionList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gReceptionList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gReceptionList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int ReceptionList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_RECEPTIONLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_RECEPTIONLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

ReceptionList_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_Type, buffer_PresetID, buffer_FmREG_Code, buffer_Category, buffer_ReceptionInformation;
    byte buffer_Attributes_bit0, buffer_Attributes_bit1, buffer_Attributes_bit2, buffer_Attributes_bit3, 
      buffer_Attributes_bit4, buffer_Attributes_bit5, buffer_Attributes_bit6, buffer_Attributes_bit7, 
      buffer_Attributes_bit8, buffer_Attributes_bit9, buffer_Attributes_bitA, buffer_Attributes_bitB, buffer_Attributes_bitC;
    word requested_startelement, startelement, elements, buffer_Pos, buffer_Attributes;
    char buffer_Name[AUDIO_RECEPTIONLIST_NAME_LENGTH], buffer_Frequency[AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH];
    int i,j,k;
    
    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_Type                 =0;
    buffer_PresetID             =0;
    buffer_ReceptionInformation =0;
    buffer_Attributes           =0;
    buffer_Attributes_bit0      =0;
    buffer_Attributes_bit1      =0;
    buffer_Attributes_bit2      =0;
    buffer_Attributes_bit3      =0;
    buffer_Attributes_bit4      =0;
    buffer_Attributes_bit5      =0;
    buffer_Attributes_bit6      =0;
    buffer_Attributes_bit7      =0;
    buffer_Attributes_bit8      =0;
    buffer_Attributes_bit9      =0;
    buffer_Attributes_bitA      =0;
    buffer_Attributes_bitB      =0;
    buffer_Attributes_bitC      =0;
    buffer_PresetID             =0;
    
    /***build-up complete cache***/

    switch (gReceptionList_ListHandlingType)
    {
        case AUDIO_RECEPTIONLIST_BUILDUPCACHE:
             
            switch (gReceptionList_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_UP:  
                    if(gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE && gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gReceptionList_CallBackReason)
                        {
                            case AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE:

                                    if(gReceptionList_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gReceptionList_cacheBuildUp      =AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        ReceptionList_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gReceptionList_cacheBuildUp      =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_NOCACHE;              
                                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK; 
                                        gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
                                        
                                        putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);
                                        ReceptionList_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gReceptionList_CallBackReason  =AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE;

                        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_WINDOW: 
                    if(gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE && gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gReceptionList_CallBackReason)
                        {
                            case AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gReceptionList_cacheBuildUp      =AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT;    
                                    
                                    ReceptionList_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        putvalue(env_ASG_AudioSD_RL_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gReceptionList_CallBackReason  =AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE;

                        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_DOWN:
                    if(gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE && gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gReceptionList_CallBackReason)
                        {
                            case AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gReceptionList_cacheBuildUp      =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_NOCACHE;              
                                    gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;
                                    gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
                                    
                                    gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH;
                                    
                                    putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);
                                    ReceptionList_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gReceptionList_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gReceptionList_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE;
                        
                        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_RECEPTIONLIST_DOWN_CACHE: 
                    if (gReceptionList_CallBackReason ==AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gReceptionList_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST; 
                            gReceptionList_cacheDown         =TRUE;

                            ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gReceptionList_CallBackReason =AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST;
                            ReceptionList_ListHandling(); 
                        }    
                    }
                    else if (gReceptionList_CallBackReason ==AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_NOCACHE;
                        gReceptionList_cacheDown         =FALSE;
                        gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);
                        ReceptionList_display();
                        gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH;
                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        putvalue(env_ASG_AudioSD_RL_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gReceptionList_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gReceptionList_Pos[i];
                                    buffer_Type             =gReceptionList_Type[i];
                                    buffer_Attributes       =gReceptionList_Attributes[i];
                                    buffer_Attributes_bit0  =gReceptionList_Attributes_available_Bit0[i];
                                    buffer_Attributes_bit1  =gReceptionList_Attributes_DVB_Bit1[i];
                                    buffer_Attributes_bit2  =gReceptionList_Attributes_DAB_Bit2[i];
                                    buffer_Attributes_bit3  =gReceptionList_Attributes_DAB_Bit3[i];
                                    buffer_Attributes_bit4  =gReceptionList_Attributes_DAB_Bit4[i];
                                    buffer_Attributes_bit5  =gReceptionList_Attributes_TP_Bit5[i];
                                    buffer_Attributes_bit6  =gReceptionList_Attributes_TMC_Bit6[i];
                                    buffer_Attributes_bit7  =gReceptionList_Attributes_SDARS_Bit7[i];
                                    buffer_Attributes_bit8  =gReceptionList_Attributes_DABserv_Bit8[i];
                                    buffer_Attributes_bit9  =gReceptionList_Attributes_FMOnline_Bit9[i];
                                    buffer_Attributes_bitA  =gReceptionList_Attributes_StationSelect_BitA[i];
                                    buffer_Attributes_bitB  =gReceptionList_Attributes_OnlineRadioMute_BitB[i];
                                    buffer_Attributes_bitC  =gReceptionList_Attributes_StationLinked_BitC[i];
                                    buffer_PresetID         =gReceptionList_PresetID[i];
                                    buffer_FmREG_Code       =gReceptionList_FmRegCode[i];
                                    buffer_Category         =gReceptionList_Category[i];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Name[i]);k++) 
                                        buffer_Name[k]=gReceptionList_Name[i][k];
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        buffer_Frequency[k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Frequency[i]);k++) 
                                        buffer_Frequency[k]=gReceptionList_Frequency[i][k];
                                    

                                    //copy data from Pos '1' to Pos '0'
                                    gReceptionList_Pos[i]                       =gReceptionList_Pos[j]; 
                                    gReceptionList_Type[i]                      =gReceptionList_Type[j];
                                    gReceptionList_Attributes[i]                =gReceptionList_Attributes[j];
                                    gReceptionList_Attributes_available_Bit0[i] =gReceptionList_Attributes_available_Bit0[j];
                                    gReceptionList_Attributes_DVB_Bit1[i]       =gReceptionList_Attributes_DVB_Bit1[j];
                                    gReceptionList_Attributes_DAB_Bit2[i]       =gReceptionList_Attributes_DAB_Bit2[j];
                                    gReceptionList_Attributes_DAB_Bit3[i]       =gReceptionList_Attributes_DAB_Bit3[j];
                                    gReceptionList_Attributes_DAB_Bit4[i]       =gReceptionList_Attributes_DAB_Bit4[j];
                                    gReceptionList_Attributes_TP_Bit5[i]        =gReceptionList_Attributes_TP_Bit5[j];
                                    gReceptionList_Attributes_TMC_Bit6[i]       =gReceptionList_Attributes_TMC_Bit6[j];
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =gReceptionList_Attributes_SDARS_Bit7[j];
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =gReceptionList_Attributes_DABserv_Bit8[j];
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =gReceptionList_Attributes_FMOnline_Bit9[j];
                                    gReceptionList_Attributes_StationSelect_BitA[i]  =gReceptionList_Attributes_StationSelect_BitA[j];
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=gReceptionList_Attributes_OnlineRadioMute_BitB[j];
                                    gReceptionList_Attributes_StationLinked_BitC[i]  =gReceptionList_Attributes_StationLinked_BitC[j];
                                    gReceptionList_PresetID[i]      =gReceptionList_PresetID[j]; 
                                    gReceptionList_FmRegCode[i]     =gReceptionList_FmRegCode[j];
                                    gReceptionList_Category[i]      =gReceptionList_Category[j];
                                
                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Name[j]);k++) 
                                        gReceptionList_Name[i][k]=gReceptionList_Name[j][k];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Frequency[j]);k++) 
                                        gReceptionList_Frequency[i][k]=gReceptionList_Frequency[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gReceptionList_ListEntryReceptionInformation[i] =0;
                                    gReceptionList_Pos[i]                           =0;
                                    gReceptionList_Type[i]                          =0;
                                    gReceptionList_Attributes[i]                    =0;
                                    gReceptionList_Attributes_available_Bit0[i]     =0;
                                    gReceptionList_Attributes_DVB_Bit1[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit2[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit3[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit4[i]           =0;
                                    gReceptionList_Attributes_TP_Bit5[i]            =0;
                                    gReceptionList_Attributes_TMC_Bit6[i]           =0;
                                    gReceptionList_Attributes_SDARS_Bit7[i]         =0;
                                    gReceptionList_Attributes_DABserv_Bit8[i]       =0;
                                    gReceptionList_Attributes_FMOnline_Bit9[i]      =0;
                                    gReceptionList_Attributes_StationSelect_BitA[i] =0;
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=0;
                                    gReceptionList_Attributes_StationLinked_BitC[i] =0;
                                    gReceptionList_PresetID[i]                      =0;
                                    gReceptionList_FmRegCode[i]                     =0;
                                    gReceptionList_Category[i]                      =0;

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gReceptionList_Pos[i]                       =buffer_Pos; 
                                    gReceptionList_Type[i]                      =buffer_Type;
                                    gReceptionList_Attributes[i]                =buffer_Attributes;
                                    gReceptionList_Attributes_available_Bit0[i] =buffer_Attributes_bit0;
                                    gReceptionList_Attributes_DVB_Bit1[i]       =buffer_Attributes_bit1;
                                    gReceptionList_Attributes_DAB_Bit2[i]       =buffer_Attributes_bit2;
                                    gReceptionList_Attributes_DAB_Bit3[i]       =buffer_Attributes_bit3;
                                    gReceptionList_Attributes_DAB_Bit4[i]       =buffer_Attributes_bit4;
                                    gReceptionList_Attributes_TP_Bit5[i]        =buffer_Attributes_bit5;
                                    gReceptionList_Attributes_TMC_Bit6[i]       =buffer_Attributes_bit6;
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =buffer_Attributes_bit7;
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =buffer_Attributes_bit8;
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =buffer_Attributes_bit9;
                                    gReceptionList_Attributes_StationSelect_BitA[i]=buffer_Attributes_bitA;
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=buffer_Attributes_bitB;
                                    gReceptionList_Attributes_StationLinked_BitC[i]=buffer_Attributes_bitC;
                                    gReceptionList_PresetID[i]                  =buffer_PresetID;
                                    gReceptionList_FmRegCode[i]                 =buffer_FmREG_Code;
                                    gReceptionList_Category[i]                  =buffer_Category;

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gReceptionList_Name[i][k]=buffer_Name[k];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Frequency);k++) 
                                        gReceptionList_Frequency[i][k]=buffer_Frequency[k];
                                    
                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gReceptionList_Pos[i]                       =gReceptionList_Pos[j]; 
                                    gReceptionList_Type[i]                      =gReceptionList_Type[j];
                                    gReceptionList_Attributes[i]                =gReceptionList_Attributes[j];
                                    gReceptionList_Attributes_available_Bit0[i] =gReceptionList_Attributes_available_Bit0[j];
                                    gReceptionList_Attributes_DVB_Bit1[i]       =gReceptionList_Attributes_DVB_Bit1[j]; 
                                    gReceptionList_Attributes_DAB_Bit2[i]       =gReceptionList_Attributes_DAB_Bit2[j];
                                    gReceptionList_Attributes_DAB_Bit3[i]       =gReceptionList_Attributes_DAB_Bit3[j];
                                    gReceptionList_Attributes_DAB_Bit4[i]       =gReceptionList_Attributes_DAB_Bit4[j];
                                    gReceptionList_Attributes_TP_Bit5[i]        =gReceptionList_Attributes_TP_Bit5[j];
                                    gReceptionList_Attributes_TMC_Bit6[i]       =gReceptionList_Attributes_TMC_Bit6[j];
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =gReceptionList_Attributes_SDARS_Bit7[j];
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =gReceptionList_Attributes_DABserv_Bit8[j];
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =gReceptionList_Attributes_FMOnline_Bit9[j];
                                    gReceptionList_Attributes_StationSelect_BitA[i]=gReceptionList_Attributes_StationSelect_BitA[j];
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=gReceptionList_Attributes_OnlineRadioMute_BitB[j];
                                    gReceptionList_Attributes_StationLinked_BitC[i]=gReceptionList_Attributes_StationLinked_BitC[j];
                                    gReceptionList_PresetID[i]                  =gReceptionList_PresetID[j]; 
                                    gReceptionList_FmRegCode[i]                 =gReceptionList_FmRegCode[j]; 
                                    gReceptionList_Category[i]                  =gReceptionList_Category[j];  
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Name[j]);k++) 
                                        gReceptionList_Name[i][k]=gReceptionList_Name[j][k];
                                        
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Frequency[j]);k++) 
                                        gReceptionList_Frequency[i][k]=gReceptionList_Frequency[j][k];        
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_RECEPTIONLIST_UP_CACHE: 
                    if (gReceptionList_CallBackReason ==AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gReceptionList_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gReceptionList_cacheUp        =TRUE;
                            gReceptionList_CallBackReason =AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST;
                            
                            ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gReceptionList_CallBackReason =AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST;
                            ReceptionList_ListHandling();
                        }           
                    }

                    else if (gReceptionList_CallBackReason ==AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_NOCACHE;
                        gReceptionList_cacheUp           =FALSE;
                        gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_RL_ListOpState, empty_string);
                        ReceptionList_display();
                        gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH;
                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        putvalue(env_ASG_AudioSD_RL_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gReceptionList_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gReceptionList_Pos[i];
                                    buffer_Type             =gReceptionList_Type[i];
                                    buffer_Attributes       =gReceptionList_Attributes[i];
                                    buffer_Attributes_bit0  =gReceptionList_Attributes_available_Bit0[i];
                                    buffer_Attributes_bit1  =gReceptionList_Attributes_DVB_Bit1[i];
                                    buffer_Attributes_bit2  =gReceptionList_Attributes_DAB_Bit2[i];
                                    buffer_Attributes_bit3  =gReceptionList_Attributes_DAB_Bit3[i];
                                    buffer_Attributes_bit4  =gReceptionList_Attributes_DAB_Bit4[i];
                                    buffer_Attributes_bit5  =gReceptionList_Attributes_TP_Bit5[i];
                                    buffer_Attributes_bit6  =gReceptionList_Attributes_TMC_Bit6[i];
                                    buffer_Attributes_bit7  =gReceptionList_Attributes_SDARS_Bit7[i];
                                    buffer_Attributes_bit8  =gReceptionList_Attributes_DABserv_Bit8[i];
                                    buffer_Attributes_bit9  =gReceptionList_Attributes_FMOnline_Bit9[i];
                                    buffer_Attributes_bitA  =gReceptionList_Attributes_StationSelect_BitA[i];
                                    buffer_Attributes_bitB  =gReceptionList_Attributes_OnlineRadioMute_BitB[i];
                                    buffer_Attributes_bitC  =gReceptionList_Attributes_StationLinked_BitC[i];
                                    buffer_PresetID         =gReceptionList_PresetID[i];
                                    buffer_FmREG_Code       =gReceptionList_FmRegCode[i];
                                    buffer_Category         =gReceptionList_Category[i];                           
                                    

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Name[i]);k++) 
                                        buffer_Name[k]=gReceptionList_Name[i][k];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        buffer_Frequency[k] =0;                                     

                                    for(k=0;k<strlen(gReceptionList_Frequency[i]);k++) 
                                        buffer_Frequency[k]=gReceptionList_Frequency[i][k];

                                    
                                    //copy data from Pos '7' to Pos '8'
                                    gReceptionList_Pos[i]                       =gReceptionList_Pos[j]; 
                                    gReceptionList_Type[i]                      =gReceptionList_Type[j];
                                    gReceptionList_Attributes[i]                =gReceptionList_Attributes[j];
                                    gReceptionList_Attributes_available_Bit0[i] =gReceptionList_Attributes_available_Bit0[j];
                                    gReceptionList_Attributes_DVB_Bit1[i]       =gReceptionList_Attributes_DVB_Bit1[j];
                                    gReceptionList_Attributes_DAB_Bit2[i]       =gReceptionList_Attributes_DAB_Bit2[j];
                                    gReceptionList_Attributes_DAB_Bit3[i]       =gReceptionList_Attributes_DAB_Bit3[j];
                                    gReceptionList_Attributes_DAB_Bit4[i]       =gReceptionList_Attributes_DAB_Bit4[j];
                                    gReceptionList_Attributes_TP_Bit5[i]        =gReceptionList_Attributes_TP_Bit5[j];
                                    gReceptionList_Attributes_TMC_Bit6[i]       =gReceptionList_Attributes_TMC_Bit6[j];
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =gReceptionList_Attributes_SDARS_Bit7[j];
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =gReceptionList_Attributes_DABserv_Bit8[j];
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =gReceptionList_Attributes_FMOnline_Bit9[j];
                                    gReceptionList_Attributes_StationSelect_BitA[i]=gReceptionList_Attributes_StationSelect_BitA[j];
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=gReceptionList_Attributes_OnlineRadioMute_BitB[j];
                                    gReceptionList_Attributes_StationLinked_BitC[i]=gReceptionList_Attributes_StationLinked_BitC[j];
                                    gReceptionList_PresetID[i]                  =gReceptionList_PresetID[j];
                                    gReceptionList_FmRegCode[i]                 =gReceptionList_FmRegCode[j];
                                    gReceptionList_Category[i]                  =gReceptionList_Category[j];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Name[j]);k++) 
                                        gReceptionList_Name[i][k]=gReceptionList_Name[j][k];
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Frequency[j]);k++) 
                                        gReceptionList_Frequency[i][k]=gReceptionList_Frequency[j][k];     
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gReceptionList_ListEntryReceptionInformation[i] =0;
                                    gReceptionList_Pos[i]                           =0;
                                    gReceptionList_Type[i]                          =0;
                                    gReceptionList_Attributes[i]                    =0;
                                    gReceptionList_Attributes_available_Bit0[i]     =0;
                                    gReceptionList_Attributes_DVB_Bit1[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit2[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit3[i]           =0;
                                    gReceptionList_Attributes_DAB_Bit4[i]           =0;
                                    gReceptionList_Attributes_TP_Bit5[i]            =0;
                                    gReceptionList_Attributes_TMC_Bit6[i]           =0;
                                    gReceptionList_Attributes_SDARS_Bit7[i]         =0;
                                    gReceptionList_Attributes_DABserv_Bit8[i]       =0;
                                    gReceptionList_Attributes_FMOnline_Bit9[i]      =0;
                                    gReceptionList_Attributes_StationSelect_BitA[i] =0;
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=0;
                                    gReceptionList_Attributes_StationLinked_BitC[i] =0;
                                    gReceptionList_PresetID[i]                      =0;
                                    gReceptionList_FmRegCode[i]                     =0;
                                    gReceptionList_Category[i]                      =0;
                            
                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gReceptionList_Pos[i]                       =buffer_Pos; 
                                    gReceptionList_Type[i]                      =buffer_Type;
                                    gReceptionList_Attributes[i]                =buffer_Attributes;
                                    gReceptionList_Attributes_available_Bit0[i] =buffer_Attributes_bit0;
                                    gReceptionList_Attributes_DVB_Bit1[i]       =buffer_Attributes_bit1;
                                    gReceptionList_Attributes_DAB_Bit2[i]       =buffer_Attributes_bit2;
                                    gReceptionList_Attributes_DAB_Bit3[i]       =buffer_Attributes_bit3;
                                    gReceptionList_Attributes_DAB_Bit4[i]       =buffer_Attributes_bit4;
                                    gReceptionList_Attributes_TP_Bit5[i]        =buffer_Attributes_bit5;
                                    gReceptionList_Attributes_TMC_Bit6[i]       =buffer_Attributes_bit6;
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =buffer_Attributes_bit7;
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =buffer_Attributes_bit8;
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =buffer_Attributes_bit9;
                                    gReceptionList_Attributes_StationSelect_BitA[i]  =buffer_Attributes_bitA;
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]  =buffer_Attributes_bitB;
                                    gReceptionList_Attributes_StationLinked_BitC[i]  =buffer_Attributes_bitC;
                                    gReceptionList_PresetID[i]                  =buffer_PresetID;
                                    gReceptionList_FmRegCode[i]                 =buffer_FmREG_Code;
                                    gReceptionList_Category[i]                  =buffer_Category;

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gReceptionList_Name[i][k]=buffer_Name[k];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Frequency);k++) 
                                        gReceptionList_Frequency[i][k]=buffer_Frequency[k];
                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gReceptionList_Pos[i]                       =gReceptionList_Pos[j]; 
                                    gReceptionList_Type[i]                      =gReceptionList_Type[j];
                                    gReceptionList_Attributes[i]                =gReceptionList_Attributes[j];
                                    gReceptionList_Attributes_available_Bit0[i] =gReceptionList_Attributes_available_Bit0[j];
                                    gReceptionList_Attributes_DVB_Bit1[i]       =gReceptionList_Attributes_DVB_Bit1[j];
                                    gReceptionList_Attributes_DAB_Bit2[i]       =gReceptionList_Attributes_DAB_Bit2[j];
                                    gReceptionList_Attributes_DAB_Bit3[i]       =gReceptionList_Attributes_DAB_Bit3[j];
                                    gReceptionList_Attributes_DAB_Bit4[i]       =gReceptionList_Attributes_DAB_Bit4[j];
                                    gReceptionList_Attributes_TP_Bit5[i]        =gReceptionList_Attributes_TP_Bit5[j];
                                    gReceptionList_Attributes_TMC_Bit6[i]       =gReceptionList_Attributes_TMC_Bit6[j];
                                    gReceptionList_Attributes_SDARS_Bit7[i]     =gReceptionList_Attributes_SDARS_Bit7[j];
                                    gReceptionList_Attributes_DABserv_Bit8[i]   =gReceptionList_Attributes_DABserv_Bit8[j];
                                    gReceptionList_Attributes_FMOnline_Bit9[i]  =gReceptionList_Attributes_FMOnline_Bit9[j];
                                    gReceptionList_Attributes_StationSelect_BitA[i]=gReceptionList_Attributes_StationSelect_BitA[j];
                                    gReceptionList_Attributes_OnlineRadioMute_BitB[i]=gReceptionList_Attributes_OnlineRadioMute_BitB[j];
                                    gReceptionList_Attributes_StationLinked_BitC[i]=gReceptionList_Attributes_StationLinked_BitC[j];
                                    gReceptionList_PresetID[i]                  =gReceptionList_PresetID[j];
                                    gReceptionList_FmRegCode[i]                 =gReceptionList_FmRegCode[j];
                                    gReceptionList_Category[i]                  =gReceptionList_Category[j];

                                    for (k=0; k<AUDIO_RECEPTIONLIST_NAME_LENGTH;k++) //clear string
                                        gReceptionList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Name[j]);k++) 
                                        gReceptionList_Name[i][k]=gReceptionList_Name[j][k];
                                    
                                    for (k=0; k<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gReceptionList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gReceptionList_Frequency[j]);k++) 
                                        gReceptionList_Frequency[i][k]=gReceptionList_Frequency[j][k];
                                    
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gReceptionList_CallBackReason    =AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

ReceptionList_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_RL_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gReceptionList_DisplayStatus ==AUDIO_RECEPTIONLIST_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gReceptionList_CursorAction ==AUDIO_RECEPTIONLIST_CURSORACTION_DOWN)
                Element_1 =ReceptionList_GetNextCachedElement(gReceptionList_LastFirstElement, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gReceptionList_CursorAction ==AUDIO_RECEPTIONLIST_CURSORACTION_UP)            
                Element_1 =ReceptionList_GetNextCachedElement(gReceptionList_LastFirstElement, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_RL_pos_0, gReceptionList_Pos[Element_1]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_0, gReceptionList_Type[Element_1]);

                if(gReceptionList_Type[Element_1] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gReceptionList_Type_s[gReceptionList_Type[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2|| gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, gReceptionList_Attributes_available_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, gReceptionList_Attributes_DVB_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, gReceptionList_Attributes_DAB_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, gReceptionList_Attributes_DAB_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, gReceptionList_Attributes_DAB_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, gReceptionList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, gReceptionList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, gReceptionList_Attributes_SDARS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_1]]);


                putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, gReceptionList_Attributes_DABserv_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, gReceptionList_Attributes_FMOnline_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, gReceptionList_Attributes_StationSelect_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, gReceptionList_Attributes_StationLinked_BitC[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_1]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_0,gReceptionList_PresetID[Element_1]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_0,gReceptionList_FmRegCode[Element_1]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_0, gReceptionList_Category[Element_1]);

                if(gReceptionList_Type[Element_1] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gReceptionList_Category_s[gReceptionList_Category[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_0,gReceptionList_Name[Element_1]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_0,gReceptionList_Frequency[Element_1]);

            gReceptionList_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =ReceptionList_GetNextCachedElement(Element_1, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            //Pos
            putvalue(env_ASG_AudioSD_RL_pos_1, gReceptionList_Pos[Element_2]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_1, gReceptionList_Type[Element_2]);

                if(gReceptionList_Type[Element_2] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gReceptionList_Type_s[gReceptionList_Type[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, gReceptionList_Attributes_available_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, gReceptionList_Attributes_DVB_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, gReceptionList_Attributes_DAB_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, gReceptionList_Attributes_DAB_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, gReceptionList_Attributes_DAB_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, gReceptionList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, gReceptionList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, gReceptionList_Attributes_SDARS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, gReceptionList_Attributes_DABserv_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, gReceptionList_Attributes_FMOnline_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, gReceptionList_Attributes_StationSelect_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, gReceptionList_Attributes_StationLinked_BitC[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_2]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_1,gReceptionList_PresetID[Element_2]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_1,gReceptionList_FmRegCode[Element_2]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_1, gReceptionList_Category[Element_2]);

                if(gReceptionList_Type[Element_2] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gReceptionList_Category_s[gReceptionList_Category[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_1,gReceptionList_Name[Element_2]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_1,gReceptionList_Frequency[Element_2]);
             
            
            //3. Element          
            Element_3 =ReceptionList_GetNextCachedElement(Element_2, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_RL_pos_2, gReceptionList_Pos[Element_3]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_2, gReceptionList_Type[Element_3]);

                if(gReceptionList_Type[Element_3] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gReceptionList_Type_s[gReceptionList_Type[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6)
              {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, gReceptionList_Attributes_available_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, gReceptionList_Attributes_DVB_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, gReceptionList_Attributes_DAB_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, gReceptionList_Attributes_DAB_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, gReceptionList_Attributes_DAB_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, gReceptionList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, gReceptionList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, gReceptionList_Attributes_SDARS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, gReceptionList_Attributes_DABserv_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, gReceptionList_Attributes_FMOnline_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_3]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, gReceptionList_Attributes_StationSelect_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, gReceptionList_Attributes_StationLinked_BitC[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_3]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_2,gReceptionList_PresetID[Element_3]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_2,gReceptionList_FmRegCode[Element_3]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_2, gReceptionList_Category[Element_3]);

                if(gReceptionList_Type[Element_3] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gReceptionList_Category_s[gReceptionList_Category[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_2,gReceptionList_Name[Element_3]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_2,gReceptionList_Frequency[Element_3]);         
        }

        /******'sliding Window' active or 'build-up List'******/
        else if(gReceptionList_DisplayStatus ==AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gReceptionList_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_RL_OnOff))
            {   
                Element_1 =0;
                
            //Pos
            if (gReceptionList_transmitpos)
                putvalue(env_ASG_AudioSD_RL_pos_0, gReceptionList_Pos[Element_1]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_0, gReceptionList_Type[Element_1]);

                if(gReceptionList_Type[Element_1] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gReceptionList_Type_s[gReceptionList_Type[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, gReceptionList_Attributes_available_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, gReceptionList_Attributes_DVB_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, gReceptionList_Attributes_DAB_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, gReceptionList_Attributes_DAB_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, gReceptionList_Attributes_DAB_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, gReceptionList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, gReceptionList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, gReceptionList_Attributes_SDARS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, gReceptionList_Attributes_DABserv_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_1]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, gReceptionList_Attributes_FMOnline_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, gReceptionList_Attributes_StationSelect_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, gReceptionList_Attributes_StationLinked_BitC[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_1]]);

            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_0,gReceptionList_PresetID[Element_1]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_0,gReceptionList_FmRegCode[Element_1]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_0, gReceptionList_Category[Element_1]);

                if(gReceptionList_Type[Element_1] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gReceptionList_Category_s[gReceptionList_Category[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_0,gReceptionList_Name[Element_1]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_0,gReceptionList_Frequency[Element_1]);
                
                gReceptionList_LastFirstElement =0;
             }

            
            //2. Element    
            if(gReceptionList_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_RL_OnOff))
            {
                Element_2 =1;
            //Pos
            if (gReceptionList_transmitpos)        
                putvalue(env_ASG_AudioSD_RL_pos_1, gReceptionList_Pos[Element_2]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_1, gReceptionList_Type[Element_2]);

                if(gReceptionList_Type[Element_2] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gReceptionList_Type_s[gReceptionList_Type[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, gReceptionList_Attributes_available_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, gReceptionList_Attributes_DVB_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, gReceptionList_Attributes_DAB_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, gReceptionList_Attributes_DAB_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, gReceptionList_Attributes_DAB_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, gReceptionList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, gReceptionList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, gReceptionList_Attributes_SDARS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_2]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, gReceptionList_Attributes_DABserv_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, gReceptionList_Attributes_FMOnline_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, gReceptionList_Attributes_StationSelect_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, gReceptionList_Attributes_StationLinked_BitC[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_2]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_1,gReceptionList_PresetID[Element_2]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_1,gReceptionList_FmRegCode[Element_2]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_1, gReceptionList_Category[Element_2]);

                if(gReceptionList_Type[Element_2] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gReceptionList_Category_s[gReceptionList_Category[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_1,gReceptionList_Name[Element_2]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_1,gReceptionList_Frequency[Element_2]);
             }

             //3. Element    
            if(gReceptionList_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_RL_OnOff))
            {
             Element_3 =2;
             //Pos
             if (gReceptionList_transmitpos)       
                putvalue(env_ASG_AudioSD_RL_pos_2, gReceptionList_Pos[Element_3]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_2, gReceptionList_Type[Element_3]);

                if(gReceptionList_Type[Element_3] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gReceptionList_Type_s[gReceptionList_Type[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, gReceptionList_Attributes_available_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, gReceptionList_Attributes_DVB_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, gReceptionList_Attributes_DAB_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, gReceptionList_Attributes_DAB_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, gReceptionList_Attributes_DAB_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, gReceptionList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, gReceptionList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, gReceptionList_Attributes_SDARS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, gReceptionList_Attributes_DABserv_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, gReceptionList_Attributes_FMOnline_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, gReceptionList_Attributes_StationSelect_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, gReceptionList_Attributes_StationLinked_BitC[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_3]]);

            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_2,gReceptionList_PresetID[Element_3]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_2,gReceptionList_FmRegCode[Element_3]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_2, gReceptionList_Category[Element_3]);

                if(gReceptionList_Type[Element_3] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gReceptionList_Category_s[gReceptionList_Category[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_2,gReceptionList_Name[Element_3]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_2,gReceptionList_Frequency[Element_3]);     
            }
        }
        else if (gReceptionList_DisplayStatus ==AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH)
        {               
            //1. Element
            if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gReceptionList_LastFirstElement; 
            else
                Element_1 =0;

            if(gReceptionList_ListEntryReceptionInformation[Element_1])
            {
                //Pos
            putvalue(env_ASG_AudioSD_RL_pos_0, gReceptionList_Pos[Element_1]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_0, gReceptionList_Type[Element_1]);

                if(gReceptionList_Type[Element_1] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gReceptionList_Type_s[gReceptionList_Type[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_0,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, gReceptionList_Attributes_available_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, gReceptionList_Attributes_DVB_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, gReceptionList_Attributes_DAB_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, gReceptionList_Attributes_DAB_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, gReceptionList_Attributes_DAB_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, gReceptionList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, gReceptionList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, gReceptionList_Attributes_SDARS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_1]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, gReceptionList_Attributes_DABserv_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_1]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, gReceptionList_Attributes_FMOnline_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, gReceptionList_Attributes_StationSelect_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, gReceptionList_Attributes_StationLinked_BitC[Element_1]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_1]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_0,gReceptionList_PresetID[Element_1]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_0,gReceptionList_FmRegCode[Element_1]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_0, gReceptionList_Category[Element_1]);

                if(gReceptionList_Type[Element_1] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gReceptionList_Category_s[gReceptionList_Category[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_0,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_0,gReceptionList_Name[Element_1]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_0,gReceptionList_Frequency[Element_1]);
            }

            //2. Element             
            if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =ReceptionList_GetNextCachedElement(Element_1, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gReceptionList_ListEntryReceptionInformation[Element_2])
            {
                //Pos
            putvalue(env_ASG_AudioSD_RL_pos_1, gReceptionList_Pos[Element_2]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_1, gReceptionList_Type[Element_2]);

                if(gReceptionList_Type[Element_2] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gReceptionList_Type_s[gReceptionList_Type[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_1,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, gReceptionList_Attributes_available_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, gReceptionList_Attributes_DVB_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, gReceptionList_Attributes_DAB_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, gReceptionList_Attributes_DAB_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, gReceptionList_Attributes_DAB_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, gReceptionList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, gReceptionList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, gReceptionList_Attributes_SDARS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, gReceptionList_Attributes_DABserv_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_2]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, gReceptionList_Attributes_FMOnline_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_2]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, gReceptionList_Attributes_StationSelect_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, gReceptionList_Attributes_StationLinked_BitC[Element_2]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_2]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_1,gReceptionList_PresetID[Element_2]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_1,gReceptionList_FmRegCode[Element_2]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_1, gReceptionList_Category[Element_2]);

                if(gReceptionList_Type[Element_2] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gReceptionList_Category_s[gReceptionList_Category[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_1,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_1,gReceptionList_Name[Element_2]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_1,gReceptionList_Frequency[Element_2]);
            }

            //3. Element          
            if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =ReceptionList_GetNextCachedElement(Element_2, AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gReceptionList_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
            putvalue(env_ASG_AudioSD_RL_pos_2, gReceptionList_Pos[Element_3]);               
            
            //Type
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Type_2, gReceptionList_Type[Element_3]);

                if(gReceptionList_Type[Element_3] <0x10)
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gReceptionList_Type_s[gReceptionList_Type[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Type_s_2,gstring_reserved);
            }

            //Attributes
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1|| gReceptionList_recordaddress ==2 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, gReceptionList_Attributes_available_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2,gReceptionList_Attributes_available_Bit0_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, gReceptionList_Attributes_DVB_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2,gReceptionList_Attributes_DVB_Bit1_s[gReceptionList_Attributes_available_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, gReceptionList_Attributes_DAB_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2,gReceptionList_Attributes_DAB_Bit2_s[gReceptionList_Attributes_DAB_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, gReceptionList_Attributes_DAB_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2,gReceptionList_Attributes_DAB_Bit3_s[gReceptionList_Attributes_DAB_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, gReceptionList_Attributes_DAB_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2,gReceptionList_Attributes_DAB_Bit4_s[gReceptionList_Attributes_DAB_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, gReceptionList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2,gReceptionList_Attributes_TP_Bit5_s[gReceptionList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, gReceptionList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2,gReceptionList_Attributes_TMC_Bit6_s[gReceptionList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, gReceptionList_Attributes_SDARS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2,gReceptionList_Attributes_SDARS_Bit7_s[gReceptionList_Attributes_SDARS_Bit7[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, gReceptionList_Attributes_DABserv_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2,gReceptionList_Attributes_DABserv_Bit8_s[gReceptionList_Attributes_DABserv_Bit8[Element_3]]);
                
                putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, gReceptionList_Attributes_FMOnline_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2,gReceptionList_Attributes_FMOnline_Bit9_s[gReceptionList_Attributes_FMOnline_Bit9[Element_3]]);

                putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, gReceptionList_Attributes_StationSelect_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2,gReceptionList_Attributes_StationSelect_BitA_s[gReceptionList_Attributes_StationSelect_BitA[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2,gReceptionList_Attributes_OnlineRadioMute_BitB_s[gReceptionList_Attributes_OnlineRadioMute_BitB[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, gReceptionList_Attributes_StationLinked_BitC[Element_3]);
                putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2,gReceptionList_Attributes_StationLinked_BitC_s[gReceptionList_Attributes_StationLinked_BitC[Element_3]]);
            }

            //PresetID
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_PrID_2,gReceptionList_PresetID[Element_3]);
            
            //FmREG_Code
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_RL_FmReg_2,gReceptionList_FmRegCode[Element_3]);

            //Category
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_RL_Cat_2, gReceptionList_Category[Element_3]);

                if(gReceptionList_Type[Element_3] <0x38)
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gReceptionList_Category_s[gReceptionList_Category[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RL_Cat_s_2,gstring_reserved);
            }

            //Name
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==1 || gReceptionList_recordaddress ==3 || gReceptionList_recordaddress ==4 || gReceptionList_recordaddress ==6)
                putvalue(env_ASG_AudioSD_RL_Name_s_2,gReceptionList_Name[Element_3]);
            
            //Frequency
            if (gReceptionList_recordaddress ==0 || gReceptionList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_RL_Freq_s_2,gReceptionList_Frequency[Element_3]);
            }
        }
    }
}

on envVar env_ASG_AudioSD_RL_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gReceptionList_ListHandlingType ==AUDIO_RECEPTIONLIST_NOCACHE)
	{
        gReceptionList_ASGID            =getvalue(env_ASG_AudioSD_RL_ASGID);
        gReceptionList_TAID             =getvalue(env_ASG_AudioSD_RL_TAID);
        gReceptionList_ParentID         =getvalue(env_ASG_AudioSD_RL_ParentID);
        gReceptionList_ElementType      =getvalue(env_ASG_AudioSD_RL_ElementType);

        shift                           =getvalue(env_ASG_AudioSD_RL_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_RL_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_RL_AH_PosTrans);
        indexsize                       =getvalue(env_ASG_AudioSD_RL_AH_IS);
        recordaddress                   =getvalue(env_ASG_AudioSD_RL_AH_RA);
        startelement                    =getvalue(env_ASG_AudioSD_RL_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_RL_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on envVar env_ASG_AudioSD_RL_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gReceptionList_ListHandlingType      =AUDIO_RECEPTIONLIST_BUILDUPCACHE;             //build-up complete cache...
            gReceptionList_cacheBuildUp          =AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            ReceptionList_ListHandling ();
        }
        else
        {
            gReceptionList_SlidingWindow_State   =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
            gReceptionList_ListHandlingType      =AUDIO_RECEPTIONLIST_NOCACHE;
            gReceptionList_cacheBuildUp          =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;
            gReceptionList_CallBackReason        =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;

            gReceptionList_cacheDown             =FALSE;
            gReceptionList_cacheUp               =FALSE;
            gReceptionList_LastFirstElement      =0;

            gReceptionList_recordaddress         =0;
            gReceptionList_transmitpos           =1;
            gReceptionList_CursorAction          =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
            gReceptionList_DisplayStatus         =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; j++)
            {     
                gReceptionList_Pos[j]                            =0;
                gReceptionList_Type[j]                           =0;
                gReceptionList_Attributes_available_Bit0[j]      =0;
                gReceptionList_Attributes_DVB_Bit1[j]            =0;
                gReceptionList_Attributes_DAB_Bit2[j]            =0;
                gReceptionList_Attributes_DAB_Bit3[j]            =0;
                gReceptionList_Attributes_DAB_Bit4[j]            =0;
                gReceptionList_Attributes_TP_Bit5[j]             =0;
                gReceptionList_Attributes_TMC_Bit6[j]            =0;
                gReceptionList_Attributes_SDARS_Bit7[j]          =0;
                gReceptionList_Attributes_DABserv_Bit8[j]        =0;
                gReceptionList_Attributes_FMOnline_Bit9[j]       =0;
                gReceptionList_Attributes_StationSelect_BitA[j]  =0;
                gReceptionList_Attributes_OnlineRadioMute_BitB[j]=0;
                gReceptionList_Attributes_StationLinked_BitC[j]  =0;
                gReceptionList_Attributes[j]                     =0;
                gReceptionList_PresetID[j]                       =0;
                gReceptionList_FmRegCode[j]                      =0;
                gReceptionList_Category[j]                       =0;
                gReceptionList_ListEntryReceptionInformation[j]  =0;

                for(i=0;i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++)
			            gReceptionList_Name[j][i] =0;
                
                for(i=0;i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++)
			            gReceptionList_Frequency[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_RL_pos_0, 0);
            putvalue(env_ASG_AudioSD_RL_pos_1, 0);
            putvalue(env_ASG_AudioSD_RL_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_RL_Type_0, 0);
            putvalue(env_ASG_AudioSD_RL_Type_1, 0);
            putvalue(env_ASG_AudioSD_RL_Type_2, 0);

            putvalue(env_ASG_AudioSD_RL_Type_s_0,empty_string);
            putvalue(env_ASG_AudioSD_RL_Type_s_1,empty_string);
            putvalue(env_ASG_AudioSD_RL_Type_s_2,empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit0_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit0_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit0_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit0_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit1_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit1_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit1_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit1_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit2_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit2_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit2_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit2_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit3_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit3_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit3_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit3_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit4_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit4_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit4_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit4_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit5_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit5_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit5_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit5_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit6_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit6_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit6_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit6_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Attr_bit7_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit7_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit7_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit7_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_Attr_bit8_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit8_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit8_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit8_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_Attr_bit9_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit9_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bit9_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bit9_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_Attr_bitA_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitA_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitA_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitA_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_Attr_bitB_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitB_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitB_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitB_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_Attr_bitC_0, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitC_1, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_bitC_2, 0);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Attr_s_bitC_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RL_PrID_0, 0);
            putvalue(env_ASG_AudioSD_RL_PrID_1, 0);
            putvalue(env_ASG_AudioSD_RL_PrID_2, 0);

            putvalue(env_ASG_AudioSD_RL_FmReg_0, 0);
            putvalue(env_ASG_AudioSD_RL_FmReg_1, 0);
            putvalue(env_ASG_AudioSD_RL_FmReg_2, 0);

            putvalue(env_ASG_AudioSD_RL_Cat_0, 0);
            putvalue(env_ASG_AudioSD_RL_Cat_1, 0);
            putvalue(env_ASG_AudioSD_RL_Cat_2, 0);
            putvalue(env_ASG_AudioSD_RL_Cat_s_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Cat_s_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Cat_s_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Name_s_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Name_s_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Name_s_2, empty_string);

            putvalue(env_ASG_AudioSD_RL_Freq_s_0, empty_string);
            putvalue(env_ASG_AudioSD_RL_Freq_s_1, empty_string);
            putvalue(env_ASG_AudioSD_RL_Freq_s_2, empty_string);
            
        }
    }
}   

on envVar env_ASG_AudioSD_RL_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gReceptionList_ListHandlingType ==AUDIO_RECEPTIONLIST_NOCACHE)
	{      
        gReceptionList_CursorAction =AUDIO_RECEPTIONLIST_CURSORACTION_DOWN;
        
        if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE)
        {   
            gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_DOWN_CACHE;
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
            
            ReceptionList_ListHandling ();
        }
        else if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_DOWN;

            ReceptionList_display();

            //reset values
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_RL_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gReceptionList_ListHandlingType ==AUDIO_RECEPTIONLIST_NOCACHE)
	{   
        gReceptionList_CursorAction =AUDIO_RECEPTIONLIST_CURSORACTION_UP;

        if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE)
        {  
            gReceptionList_ListHandlingType  =AUDIO_RECEPTIONLIST_UP_CACHE;
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
            
            ReceptionList_ListHandling ();
        }
        else if(gReceptionList_SlidingWindow_State ==AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_UP;

            ReceptionList_ListHandling();
            
            ReceptionList_display();

            //reset values
            gReceptionList_DisplayStatus     =AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH;
            gReceptionList_CursorAction      =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
        }    
    }
}

int SourceList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_SOURCELIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gSourceList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gSourceList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gSourceList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int SourceList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_SOURCELIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_SOURCELIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

SourceList_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_SourceType, buffer_InstanceID, buffer_MediaType, buffer_Attributes, buffer_Attributes_bit0, buffer_Attributes_bit1, buffer_Attributes_bit2, buffer_Attributes_bit3, buffer_Attributes_bit4, buffer_Attributes_bit5, buffer_Attributes_bit6, buffer_ReceptionInformation;
    word requested_startelement, startelement, elements, buffer_Pos ;
    char buffer_Name[AUDIO_SOURCELIST_NAME_LENGTH];
    int i,j,k;
    
    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_SourceType           =0;
    buffer_InstanceID           =0;
    buffer_MediaType            =0;
    buffer_ReceptionInformation =0;
    buffer_Attributes           =0;
    buffer_Attributes_bit0      =0;
    buffer_Attributes_bit1      =0;
    buffer_Attributes_bit2      =0;
    buffer_Attributes_bit3      =0;
    buffer_Attributes_bit4      =0;
    buffer_Attributes_bit5      =0;
    
    /***build-up complete cache***/

    switch (gSourceList_ListHandlingType)
    {
        case AUDIO_SOURCELIST_BUILDUPCACHE:
             
            switch (gSourceList_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_SOURCELIST_BUILDUPCACHECACHE_UP:  
                    if(gSourceList_CallBackReason !=AUDIO_SOURCELIST_BUILDUPCACHENOCACHE && gSourceList_CallBackReason !=AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gSourceList_CallBackReason)
                        {
                            case AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE:

                                    if(gSourceList_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gSourceList_cacheBuildUp      =AUDIO_SOURCELIST_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        SourceList_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gSourceList_cacheBuildUp      =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gSourceList_ListHandlingType  =AUDIO_SOURCELIST_NOCACHE;              
                                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK; 
                                        gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
                                        
                                        putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);
                                        SourceList_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSourceList_CallBackReason  =AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE;

                        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_SOURCELIST_BUILDUPCACHECACHE_WINDOW: 
                    if(gSourceList_CallBackReason !=AUDIO_SOURCELIST_BUILDUPCACHENOCACHE && gSourceList_CallBackReason !=AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gSourceList_CallBackReason)
                        {
                            case AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gSourceList_cacheBuildUp      =AUDIO_SOURCELIST_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT;    
                                    
                                    SourceList_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        putvalue(env_ASG_AudioSD_SL_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSourceList_CallBackReason  =AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE;

                        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_SOURCELIST_BUILDUPCACHECACHE_DOWN:
                    if(gSourceList_CallBackReason !=AUDIO_SOURCELIST_BUILDUPCACHENOCACHE && gSourceList_CallBackReason !=AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gSourceList_CallBackReason)
                        {
                            case AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gSourceList_cacheBuildUp      =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gSourceList_ListHandlingType  =AUDIO_SOURCELIST_NOCACHE;              
                                    gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;
                                    gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
                                    
                                    gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_REFRESH;
                                    
                                    putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);
                                    
                                    SourceList_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gSourceList_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gSourceList_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE;
                        
                        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_SOURCELIST_DOWN_CACHE: 
                    if (gSourceList_CallBackReason ==AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gSourceList_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST; 
                            gSourceList_cacheDown         =TRUE;

                            SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gSourceList_CallBackReason =AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST;
                            SourceList_ListHandling(); 
                        }    
                    }
                    else if (gSourceList_CallBackReason ==AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gSourceList_ListHandlingType  =AUDIO_SOURCELIST_NOCACHE;
                        gSourceList_cacheDown         =FALSE;
                        gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);
                        SourceList_display();
                        gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_REFRESH;
                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        putvalue(env_ASG_AudioSD_SL_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gSourceList_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gSourceList_Pos[i];
                                    buffer_SourceType       =gSourceList_SourceType[i];
                                    buffer_InstanceID       =gSourceList_InstanceID[i];
                                    buffer_MediaType        =gSourceList_MediaType[i];
                                    buffer_Attributes       =gSourceList_Attributes[i];
                                    buffer_Attributes_bit0  =gSourceList_Attributes_BuiltIn_Bit0[i];
                                    buffer_Attributes_bit1  =gSourceList_Attributes_MediaError_Bit1[i];
                                    buffer_Attributes_bit2  =gSourceList_Attributes_MediaPlay_Bit2[i];
                                    buffer_Attributes_bit3  =gSourceList_Attributes_MediaRead_Bit3[i];
                                    buffer_Attributes_bit4  =gSourceList_Attributes_MediaLoad_Bit4[i];
                                    buffer_Attributes_bit5  =gSourceList_Attributes_ImportRun_Bit5[i];
                                    buffer_Attributes_bit6  =gSourceList_Attributes_MediaSupp_Bit6[i];

                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gSourceList_Name[i]);k++) 
                                        buffer_Name[k]=gSourceList_Name[i][k];

                                    //copy data from Pos '1' to Pos '0'
                                    gSourceList_Pos[i]                          =gSourceList_Pos[j]; 
                                    gSourceList_SourceType[i]                   =gSourceList_SourceType[j];
                                    gSourceList_InstanceID[i]                   =gSourceList_InstanceID[j];
                                    gSourceList_MediaType[i]                    =gSourceList_MediaType[j]; 
                                    gSourceList_Attributes[i]                   =gSourceList_Attributes[j];
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =gSourceList_Attributes_BuiltIn_Bit0[j];
                                    gSourceList_Attributes_MediaError_Bit1[i]   =gSourceList_Attributes_MediaError_Bit1[j];
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =gSourceList_Attributes_MediaPlay_Bit2[j];
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =gSourceList_Attributes_MediaRead_Bit3[j];
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =gSourceList_Attributes_MediaLoad_Bit4[j];
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =gSourceList_Attributes_ImportRun_Bit5[j]; 
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =gSourceList_Attributes_MediaSupp_Bit6[j]; 
                                
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0;                                     

                                    for(k=0;k<strlen(gSourceList_Name[j]);k++) 
                                        gSourceList_Name[i][k]=gSourceList_Name[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gSourceList_ListEntryReceptionInformation[i]    =0;
                                    gSourceList_Pos[i]                              =0;
                                    gSourceList_SourceType[i]                       =0;
                                    gSourceList_InstanceID[i]                       =0;
                                    gSourceList_MediaType[i]                        =0;
                                    gSourceList_Attributes[i]                       =0;
                                    gSourceList_Attributes_BuiltIn_Bit0[i]          =0;
                                    gSourceList_Attributes_MediaError_Bit1[i]       =0;
                                    gSourceList_Attributes_MediaPlay_Bit2[i]        =0;
                                    gSourceList_Attributes_MediaRead_Bit3[i]        =0;
                                    gSourceList_Attributes_MediaLoad_Bit4[i]        =0;
                                    gSourceList_Attributes_ImportRun_Bit5[i]        =0;
                                    gSourceList_Attributes_MediaSupp_Bit6[i]        =0;
                                    
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gSourceList_Pos[i]                          =buffer_Pos; 
                                    gSourceList_SourceType[i]                   =buffer_SourceType;
                                    gSourceList_InstanceID[i]                   =buffer_InstanceID;
                                    gSourceList_MediaType[i]                    =buffer_MediaType;
                                    gSourceList_Attributes[i]                   =buffer_Attributes;
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =buffer_Attributes_bit0;
                                    gSourceList_Attributes_MediaError_Bit1[i]   =buffer_Attributes_bit1;
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =buffer_Attributes_bit2;
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =buffer_Attributes_bit3;
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =buffer_Attributes_bit4;
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =buffer_Attributes_bit5;
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =buffer_Attributes_bit6;
                                                                        
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gSourceList_Name[i][k]=buffer_Name[k];

                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gSourceList_Pos[i]                          =gSourceList_Pos[j]; 
                                    gSourceList_SourceType[i]                   =gSourceList_SourceType[j];
                                    gSourceList_InstanceID[i]                   =gSourceList_InstanceID[j];
                                    gSourceList_MediaType[i]                    =gSourceList_MediaType[j];
                                    gSourceList_Attributes[i]                   =gSourceList_Attributes[j];
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =gSourceList_Attributes_BuiltIn_Bit0[j];
                                    gSourceList_Attributes_MediaError_Bit1[i]   =gSourceList_Attributes_MediaError_Bit1[j]; 
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =gSourceList_Attributes_MediaPlay_Bit2[j];
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =gSourceList_Attributes_MediaRead_Bit3[j];
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =gSourceList_Attributes_MediaLoad_Bit4[j];
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =gSourceList_Attributes_ImportRun_Bit5[j];
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =gSourceList_Attributes_MediaSupp_Bit6[j];
                                 
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSourceList_Name[j]);k++) 
                                        gSourceList_Name[i][k]=gSourceList_Name[j][k];
                                        
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_SOURCELIST_UP_CACHE: 
                    if (gSourceList_CallBackReason ==AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gSourceList_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gSourceList_cacheUp        =TRUE;
                            gSourceList_CallBackReason =AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST;
                            
                            SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gSourceList_CallBackReason =AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST;
                            SourceList_ListHandling();
                        }           
                    }

                    else if (gSourceList_CallBackReason ==AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gSourceList_ListHandlingType  =AUDIO_SOURCELIST_NOCACHE;
                        gSourceList_cacheUp           =FALSE;
                        gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_SL_ListOpState, empty_string);
                        SourceList_display();
                        gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_REFRESH;
                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        putvalue(env_ASG_AudioSD_SL_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gSourceList_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gSourceList_Pos[i];
                                    buffer_SourceType       =gSourceList_SourceType[i];
                                    buffer_InstanceID       =gSourceList_InstanceID[i];
                                    buffer_MediaType        =gSourceList_MediaType[i];
                                    buffer_Attributes       =gSourceList_Attributes[i];
                                    buffer_Attributes_bit0  =gSourceList_Attributes_BuiltIn_Bit0[i];
                                    buffer_Attributes_bit1  =gSourceList_Attributes_MediaError_Bit1[i];
                                    buffer_Attributes_bit2  =gSourceList_Attributes_MediaPlay_Bit2[i];
                                    buffer_Attributes_bit3  =gSourceList_Attributes_MediaRead_Bit3[i];
                                    buffer_Attributes_bit4  =gSourceList_Attributes_MediaLoad_Bit4[i];
                                    buffer_Attributes_bit5  =gSourceList_Attributes_ImportRun_Bit5[i];                                
                                    buffer_Attributes_bit6  =gSourceList_Attributes_MediaSupp_Bit6[i];   

                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gSourceList_Name[i]);k++) 
                                        buffer_Name[k]=gSourceList_Name[i][k];

                                    //copy data from Pos '7' to Pos '8'
                                    gSourceList_Pos[i]                          =gSourceList_Pos[j]; 
                                    gSourceList_SourceType[i]                   =gSourceList_SourceType[j];
                                    gSourceList_InstanceID[i]                   =gSourceList_InstanceID[j];
                                    gSourceList_MediaType[i]                    =gSourceList_MediaType[j];
                                    gSourceList_Attributes[i]                   =gSourceList_Attributes[j];
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =gSourceList_Attributes_BuiltIn_Bit0[j];
                                    gSourceList_Attributes_MediaError_Bit1[i]   =gSourceList_Attributes_MediaError_Bit1[j];
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =gSourceList_Attributes_MediaPlay_Bit2[j];
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =gSourceList_Attributes_MediaRead_Bit3[j];
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =gSourceList_Attributes_MediaLoad_Bit4[j];
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =gSourceList_Attributes_ImportRun_Bit5[j];
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =gSourceList_Attributes_MediaSupp_Bit6[j];
                                    
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSourceList_Name[j]);k++) 
                                        gSourceList_Name[i][k]=gSourceList_Name[j][k];
                                    
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gSourceList_ListEntryReceptionInformation[i]    =0;
                                    gSourceList_Pos[i]                              =0;
                                    gSourceList_SourceType[i]                       =0;
                                    gSourceList_InstanceID[i]                       =0;
                                    gSourceList_MediaType[i]                        =0;
                                    gSourceList_Attributes[i]                       =0;
                                    gSourceList_Attributes_BuiltIn_Bit0[i]          =0;
                                    gSourceList_Attributes_MediaError_Bit1[i]       =0;
                                    gSourceList_Attributes_MediaPlay_Bit2[i]        =0;
                                    gSourceList_Attributes_MediaRead_Bit3[i]        =0;
                                    gSourceList_Attributes_MediaLoad_Bit4[i]        =0;
                                    gSourceList_Attributes_ImportRun_Bit5[i]        =0;
                                    gSourceList_Attributes_MediaSupp_Bit6[i]        =0;
                            
                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gSourceList_Pos[i]                          =buffer_Pos; 
                                    gSourceList_SourceType[i]                   =buffer_SourceType;
                                    gSourceList_InstanceID[i]                   =buffer_InstanceID;
                                    gSourceList_MediaType[i]                    =buffer_MediaType;
                                    gSourceList_Attributes[i]                   =buffer_Attributes;
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =buffer_Attributes_bit0;
                                    gSourceList_Attributes_MediaError_Bit1[i]   =buffer_Attributes_bit1;
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =buffer_Attributes_bit2;
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =buffer_Attributes_bit3;
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =buffer_Attributes_bit4;
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =buffer_Attributes_bit5;
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =buffer_Attributes_bit6;

                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gSourceList_Name[i][k]=buffer_Name[k];

                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gSourceList_Pos[i]                          =gSourceList_Pos[j]; 
                                    gSourceList_SourceType[i]                   =gSourceList_SourceType[j];
                                    gSourceList_InstanceID[i]                   =gSourceList_InstanceID[j];
                                    gSourceList_MediaType[i]                    =gSourceList_MediaType[j]; 
                                    gSourceList_Attributes[i]                   =gSourceList_Attributes[j];
                                    gSourceList_Attributes_BuiltIn_Bit0[i]      =gSourceList_Attributes_BuiltIn_Bit0[j];
                                    gSourceList_Attributes_MediaError_Bit1[i]   =gSourceList_Attributes_MediaError_Bit1[j];
                                    gSourceList_Attributes_MediaPlay_Bit2[i]    =gSourceList_Attributes_MediaPlay_Bit2[j];
                                    gSourceList_Attributes_MediaRead_Bit3[i]    =gSourceList_Attributes_MediaRead_Bit3[j];
                                    gSourceList_Attributes_MediaLoad_Bit4[i]    =gSourceList_Attributes_MediaLoad_Bit4[j];
                                    gSourceList_Attributes_ImportRun_Bit5[i]    =gSourceList_Attributes_ImportRun_Bit5[j];     
                                    gSourceList_Attributes_MediaSupp_Bit6[i]    =gSourceList_Attributes_MediaSupp_Bit6[j];     

                                    for (k=0; k<AUDIO_SOURCELIST_NAME_LENGTH;k++) //clear string
                                        gSourceList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSourceList_Name[j]);k++) 
                                        gSourceList_Name[i][k]=gSourceList_Name[j][k];
                                     
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gSourceList_CallBackReason    =AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

SourceList_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;
    
    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_SL_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gSourceList_DisplayStatus ==AUDIO_SOURCELIST_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gSourceList_CursorAction ==AUDIO_SOURCELIST_CURSORACTION_DOWN)
                Element_1 =SourceList_GetNextCachedElement(gSourceList_LastFirstElement, AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gSourceList_CursorAction ==AUDIO_SOURCELIST_CURSORACTION_UP)            
                Element_1 =SourceList_GetNextCachedElement(gSourceList_LastFirstElement, AUDIO_SOURCELIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_SL_pos_0, gSourceList_Pos[Element_1]);               
            
            //SourceType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_SL_SrcType_0, gSourceList_SourceType[Element_1]);

                if(gSourceList_SourceType[Element_1] <0x2E)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gSourceList_SourceType_s[gSourceList_SourceType[Element_1]]);
                else if(gSourceList_SourceType[Element_1] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_reserved);
            }

            //InstanceID
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_SL_IID_0,gSourceList_InstanceID[Element_1]);
            
            //MediaType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
            {
                putvalue(env_ASG_AudioSD_SL_MedType_0, gSourceList_MediaType[Element_1]);

                if(gSourceList_MediaType[Element_1] <0x0E)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_0,gSourceList_MediaType_s[gSourceList_MediaType[Element_1]]);
                else if(gSourceList_MediaType[Element_1] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_reserved);
            }

            //Attributes
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
            {
                putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, gSourceList_Attributes_BuiltIn_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, gSourceList_Attributes_MediaError_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, gSourceList_Attributes_MediaPlay_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, gSourceList_Attributes_MediaRead_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, gSourceList_Attributes_MediaLoad_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, gSourceList_Attributes_ImportRun_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit6_0, gSourceList_Attributes_MediaSupp_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_0,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_1]]);
            }

            //Name
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_SL_Name_s_0,gSourceList_Name[Element_1]);

            gSourceList_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =SourceList_GetNextCachedElement(Element_1, AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            //Pos
            putvalue(env_ASG_AudioSD_SL_pos_1, gSourceList_Pos[Element_2]);               
            
            //SourceType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_SL_SrcType_1, gSourceList_SourceType[Element_2]);

                if(gSourceList_SourceType[Element_2] <0x2E)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gSourceList_SourceType_s[gSourceList_SourceType[Element_2]]);
                else if(gSourceList_SourceType[Element_2] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_reserved);
            }

            //InstanceID
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_SL_IID_1,gSourceList_InstanceID[Element_2]);
            
            //MediaType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
            {
                putvalue(env_ASG_AudioSD_SL_MedType_1, gSourceList_MediaType[Element_2]);

                if(gSourceList_MediaType[Element_2] <0x0E)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_1,gSourceList_MediaType_s[gSourceList_MediaType[Element_2]]);
                else if(gSourceList_MediaType[Element_2] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_reserved);
            }

            //Attributes
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
            {
                putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, gSourceList_Attributes_BuiltIn_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, gSourceList_Attributes_MediaError_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, gSourceList_Attributes_MediaPlay_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, gSourceList_Attributes_MediaRead_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, gSourceList_Attributes_MediaLoad_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, gSourceList_Attributes_ImportRun_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit6_1, gSourceList_Attributes_MediaSupp_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_1,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_2]]);
            }

            //Name
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_SL_Name_s_1,gSourceList_Name[Element_2]);
             
            
            //3. Element          
            Element_3 =SourceList_GetNextCachedElement(Element_3, AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_SL_pos_2, gSourceList_Pos[Element_3]);               
            
            //SourceType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_SL_SrcType_2, gSourceList_SourceType[Element_3]);

                if(gSourceList_SourceType[Element_3] <0x2E)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gSourceList_SourceType_s[gSourceList_SourceType[Element_3]]);
                else if(gSourceList_SourceType[Element_3] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_reserved);
            }

            //InstanceID
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_SL_IID_2,gSourceList_InstanceID[Element_3]);
            
            //MediaType
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
            {
                putvalue(env_ASG_AudioSD_SL_MedType_2, gSourceList_MediaType[Element_3]);

                if(gSourceList_MediaType[Element_3] <0x0E)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_2,gSourceList_MediaType_s[gSourceList_MediaType[Element_3]]);
                else if(gSourceList_MediaType[Element_3] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                    putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_reserved);
            }

            //Attributes
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
            {
                putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, gSourceList_Attributes_BuiltIn_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, gSourceList_Attributes_MediaError_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, gSourceList_Attributes_MediaPlay_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, gSourceList_Attributes_MediaRead_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, gSourceList_Attributes_MediaLoad_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, gSourceList_Attributes_ImportRun_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_SL_Attr_bit6_2, gSourceList_Attributes_MediaSupp_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_2,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_3]]);

            }

            //Name
            if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_SL_Name_s_2,gSourceList_Name[Element_3]);         
        }
        
        /******'sliding Window' active or 'build-up List'******/
        else if(gSourceList_DisplayStatus ==AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gSourceList_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_SL_OnOff))
            {   
                Element_1 =0;
                
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_0, gSourceList_Pos[Element_1]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_0, gSourceList_SourceType[Element_1]);

                    if(gSourceList_SourceType[Element_1] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gSourceList_SourceType_s[gSourceList_SourceType[Element_1]]);
                    else if(gSourceList_SourceType[Element_1] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_0,gSourceList_InstanceID[Element_1]);
            
                //MediaType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_0, gSourceList_MediaType[Element_1]);

                    if(gSourceList_MediaType[Element_1] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gSourceList_MediaType_s[gSourceList_MediaType[Element_1]]);
                    else if(gSourceList_MediaType[Element_1] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, gSourceList_Attributes_BuiltIn_Bit0[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, gSourceList_Attributes_MediaError_Bit1[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, gSourceList_Attributes_MediaPlay_Bit2[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, gSourceList_Attributes_MediaRead_Bit3[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_1]]);
    
                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, gSourceList_Attributes_MediaLoad_Bit4[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_1]]);
    
                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, gSourceList_Attributes_ImportRun_Bit5[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_0, gSourceList_Attributes_MediaSupp_Bit6[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_0,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_1]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_0,gSourceList_Name[Element_1]);
            }
            
            //2. Element    
            if(gSourceList_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_SL_OnOff))
            {
                Element_2 =1;
                
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_1, gSourceList_Pos[Element_2]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_1, gSourceList_SourceType[Element_2]);

                    if(gSourceList_SourceType[Element_2] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gSourceList_SourceType_s[gSourceList_SourceType[Element_2]]);
                    else if(gSourceList_SourceType[Element_2] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_1,gSourceList_InstanceID[Element_2]);
            
                //MediaType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_1, gSourceList_MediaType[Element_2]);

                    if(gSourceList_MediaType[Element_2] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gSourceList_MediaType_s[gSourceList_MediaType[Element_2]]);
                    else if(gSourceList_MediaType[Element_2] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, gSourceList_Attributes_BuiltIn_Bit0[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, gSourceList_Attributes_MediaError_Bit1[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, gSourceList_Attributes_MediaPlay_Bit2[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, gSourceList_Attributes_MediaRead_Bit3[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, gSourceList_Attributes_MediaLoad_Bit4[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, gSourceList_Attributes_ImportRun_Bit5[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_1, gSourceList_Attributes_MediaSupp_Bit6[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_1,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_2]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_1,gSourceList_Name[Element_2]);
            }

            //3. Element    
            if(gSourceList_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_SL_OnOff))
            {
                Element_3 =2;
             
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_2, gSourceList_Pos[Element_3]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_2, gSourceList_SourceType[Element_3]);

                    if(gSourceList_SourceType[Element_3] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gSourceList_SourceType_s[gSourceList_SourceType[Element_3]]);
                    else if(gSourceList_SourceType[Element_3] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_2,gSourceList_InstanceID[Element_3]);
            
                //MediaType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_2, gSourceList_MediaType[Element_3]);

                    if(gSourceList_MediaType[Element_3] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gSourceList_MediaType_s[gSourceList_MediaType[Element_3]]);
                    else if(gSourceList_MediaType[Element_3] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, gSourceList_Attributes_BuiltIn_Bit0[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, gSourceList_Attributes_MediaError_Bit1[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, gSourceList_Attributes_MediaPlay_Bit2[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, gSourceList_Attributes_MediaRead_Bit3[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, gSourceList_Attributes_MediaLoad_Bit4[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, gSourceList_Attributes_ImportRun_Bit5[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_2, gSourceList_Attributes_MediaSupp_Bit6[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_2,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_3]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_2,gSourceList_Name[Element_3]);
            }
        }    
            
        else if (gSourceList_DisplayStatus ==AUDIO_SOURCELIST_DISPLAYLIST_REFRESH)
        {          
            //1. Element
            if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gSourceList_LastFirstElement; 
            else
                Element_1 =0;

            if(gSourceList_ListEntryReceptionInformation[Element_1])
            {
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_0, gSourceList_Pos[Element_1]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_0, gSourceList_SourceType[Element_1]);

                    if(gSourceList_SourceType[Element_1] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gSourceList_SourceType_s[gSourceList_SourceType[Element_1]]);
                    else if(gSourceList_SourceType[Element_1] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_0,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_0,gSourceList_InstanceID[Element_1]);
            
                //MediaType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_0, gSourceList_MediaType[Element_1]);

                    if(gSourceList_MediaType[Element_1] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gSourceList_MediaType_s[gSourceList_MediaType[Element_1]]);
                    else if(gSourceList_MediaType[Element_1] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_0,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_0, gSourceList_Attributes_BuiltIn_Bit0[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_0,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_0, gSourceList_Attributes_MediaError_Bit1[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_0,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_0, gSourceList_Attributes_MediaPlay_Bit2[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_0,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_0, gSourceList_Attributes_MediaRead_Bit3[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_0,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_0, gSourceList_Attributes_MediaLoad_Bit4[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_0,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_0, gSourceList_Attributes_ImportRun_Bit5[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_0,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_1]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_0, gSourceList_Attributes_MediaSupp_Bit6[Element_1]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_0,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_1]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_0,gSourceList_Name[Element_1]);
            }//END: Element_1
                

            //2. Element             
            if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =SourceList_GetNextCachedElement(Element_1, AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gSourceList_ListEntryReceptionInformation[Element_2])
            {
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_1, gSourceList_Pos[Element_2]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_1, gSourceList_SourceType[Element_2]);

                    if(gSourceList_SourceType[Element_2] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gSourceList_SourceType_s[gSourceList_SourceType[Element_2]]);
                    else if(gSourceList_SourceType[Element_2] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_1,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_1,gSourceList_InstanceID[Element_2]);
            
                //MediaType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_1, gSourceList_MediaType[Element_2]);

                    if(gSourceList_MediaType[Element_2] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gSourceList_MediaType_s[gSourceList_MediaType[Element_2]]);
                    else if(gSourceList_MediaType[Element_2] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_1,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_1, gSourceList_Attributes_BuiltIn_Bit0[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_1,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_1, gSourceList_Attributes_MediaError_Bit1[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_1,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_1, gSourceList_Attributes_MediaPlay_Bit2[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_1,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_1, gSourceList_Attributes_MediaRead_Bit3[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_1,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_1, gSourceList_Attributes_MediaLoad_Bit4[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_1,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_1, gSourceList_Attributes_ImportRun_Bit5[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_1,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_2]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_1, gSourceList_Attributes_MediaSupp_Bit6[Element_2]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_1,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_2]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_1,gSourceList_Name[Element_2]);
            
            }//END: Element_2

            //3. Element          
            if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =SourceList_GetNextCachedElement(Element_2, AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gSourceList_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
                putvalue(env_ASG_AudioSD_SL_pos_2, gSourceList_Pos[Element_3]);               
            
                //SourceType
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_SL_SrcType_2, gSourceList_SourceType[Element_3]);

                    if(gSourceList_SourceType[Element_3] <0x2E)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gSourceList_SourceType_s[gSourceList_SourceType[Element_3]]);
                    else if(gSourceList_SourceType[Element_3] ==AUDIO_SOURCELIST_ST_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_SrcType_s_2,gstring_reserved);
                }

                //InstanceID
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_SL_IID_2,gSourceList_InstanceID[Element_3]);
            
                //MediaType                                               
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1 || gSourceList_recordaddress ==4) 
                {
                    putvalue(env_ASG_AudioSD_SL_MedType_2, gSourceList_MediaType[Element_3]);

                    if(gSourceList_MediaType[Element_3] <0x0E)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gSourceList_MediaType_s[gSourceList_MediaType[Element_3]]);
                    else if(gSourceList_MediaType[Element_3] ==AUDIO_SOURCELIST_MT_UNKNOWN)
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_SL_MedType_s_2,gstring_reserved);
                }

                //Attributes
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==1|| gSourceList_recordaddress ==3) 
                {
                    putvalue(env_ASG_AudioSD_SL_Attr_bit0_2, gSourceList_Attributes_BuiltIn_Bit0[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit0_2,gSourceList_Attributes_BuiltIn_Bit0_s[gSourceList_Attributes_BuiltIn_Bit0[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit1_2, gSourceList_Attributes_MediaError_Bit1[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit1_2,gSourceList_Attributes_MediaError_Bit1_s[gSourceList_Attributes_MediaError_Bit1[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit2_2, gSourceList_Attributes_MediaPlay_Bit2[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit2_2,gSourceList_Attributes_MediaPlay_Bit2_s[gSourceList_Attributes_MediaPlay_Bit2[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit3_2, gSourceList_Attributes_MediaRead_Bit3[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit3_2,gSourceList_Attributes_MediaRead_Bit3_s[gSourceList_Attributes_MediaRead_Bit3[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit4_2, gSourceList_Attributes_MediaLoad_Bit4[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit4_2,gSourceList_Attributes_MediaLoad_Bit4_s[gSourceList_Attributes_MediaLoad_Bit4[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit5_2, gSourceList_Attributes_ImportRun_Bit5[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit5_2,gSourceList_Attributes_ImportRun_Bit5_s[gSourceList_Attributes_ImportRun_Bit5[Element_3]]);

                    putvalue(env_ASG_AudioSD_SL_Attr_bit6_2, gSourceList_Attributes_MediaSupp_Bit6[Element_3]);
                    putvalue(env_ASG_AudioSD_SL_Attr_s_bit6_2,gSourceList_Attributes_MediaSupp_Bit6_s[gSourceList_Attributes_MediaSupp_Bit6[Element_3]]);

                }

                //Name
                if (gSourceList_recordaddress ==0 || gSourceList_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_SL_Name_s_2,gSourceList_Name[Element_3]);     
            }
        }
    }
}

on envVar env_ASG_AudioSD_SL_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSourceList_ListHandlingType ==AUDIO_SOURCELIST_NOCACHE)
	{      
        gSourceList_CursorAction =AUDIO_SOURCELIST_CURSORACTION_DOWN;
        
        if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE)
        {   
            gSourceList_ListHandlingType  =AUDIO_SOURCELIST_DOWN_CACHE;
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
            
            SourceList_ListHandling ();
        }
        else if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_DOWN;

            SourceList_display();

            //reset values
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_REFRESH;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_SL_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSourceList_ListHandlingType ==AUDIO_SOURCELIST_NOCACHE)
	{   
        gSourceList_CursorAction =AUDIO_SOURCELIST_CURSORACTION_UP;

        if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE)
        {  
            gSourceList_ListHandlingType  =AUDIO_SOURCELIST_UP_CACHE;
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
            
            SourceList_ListHandling ();
        }
        else if(gSourceList_SlidingWindow_State ==AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_UP;

            SourceList_ListHandling();
            
            SourceList_display();

            //reset values
            gSourceList_DisplayStatus     =AUDIO_SOURCELIST_DISPLAYLIST_REFRESH;
            gSourceList_CursorAction      =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
        }    
    }
}

on envVar env_ASG_AudioSD_SL_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSourceList_ListHandlingType ==AUDIO_SOURCELIST_NOCACHE)
	{
        gSourceList_ASGID            =getvalue(env_ASG_AudioSD_SL_ASGID);
        gSourceList_TAID             =getvalue(env_ASG_AudioSD_SL_TAID);

        shift                           =getvalue(env_ASG_AudioSD_SL_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_SL_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_SL_AH_PosTrans);
        indexsize                       =getvalue(env_ASG_AudioSD_SL_AH_IS);
        recordaddress                   =getvalue(env_ASG_AudioSD_SL_AH_RA);
        startelement                    =getvalue(env_ASG_AudioSD_SL_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_SL_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

int RadioTVPresetList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gRadioTVPresetList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gRadioTVPresetList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gRadioTVPresetList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int RadioTVPresetList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

RadioTVPresetList_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_PresetIndex, buffer_Waveband, buffer_Attributes_bit0, buffer_Attributes_bit1, buffer_Attributes_bit2, buffer_Attributes_bit5, buffer_Attributes_bit6, buffer_Attributes_bit7, buffer_ReceptionInformation;
    byte buffer_Attributes_bit3, buffer_Attributes_bit4, buffer_Attributes_bit8, buffer_Attributes_bit9, buffer_Attributes_bitA;
    word requested_startelement, startelement, elements, buffer_Pos, buffer_Attributes;
    char buffer_Name[AUDIO_RADIOTVPRESETLIST_NAME_LENGTH];
    int i,j,k;

    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_PresetIndex          =0;
    buffer_Waveband             =0;
    buffer_ReceptionInformation =0;
    buffer_Attributes           =0;
    buffer_Attributes_bit0      =0;
    buffer_Attributes_bit1      =0;
    buffer_Attributes_bit2      =0;
    buffer_Attributes_bit3      =0;
    buffer_Attributes_bit4      =0;
    buffer_Attributes_bit5      =0;
    buffer_Attributes_bit6      =0;
    buffer_Attributes_bit7      =0;
    buffer_Attributes_bit8      =0;
    buffer_Attributes_bit9      =0;
    buffer_Attributes_bitA      =0;
    
    /***build-up complete cache***/

    switch (gRadioTVPresetList_ListHandlingType)
    {
        case AUDIO_RADIOTVPRESETLIST_BUILDUPCACHE:
             
            switch (gRadioTVPresetList_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_UP:  
                    if(gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE && gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gRadioTVPresetList_CallBackReason)
                        {
                            case AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE:

                                    if(gRadioTVPresetList_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gRadioTVPresetList_cacheBuildUp      =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        RadioTVPresetList_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gRadioTVPresetList_cacheBuildUp      =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_NOCACHE;              
                                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK; 
                                        gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
                                        
                                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);
                                        RadioTVPresetList_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gRadioTVPresetList_CallBackReason  =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE;

                        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_WINDOW: 
                    if(gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE && gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gRadioTVPresetList_CallBackReason)
                        {
                            case AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gRadioTVPresetList_cacheBuildUp      =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT;    
                                    
                                    RadioTVPresetList_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gRadioTVPresetList_CallBackReason  =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE;

                        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_DOWN:
                    if(gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE && gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gRadioTVPresetList_CallBackReason)
                        {
                            case AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gRadioTVPresetList_cacheBuildUp      =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_NOCACHE;              
                                    gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;
                                    gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
                                    
                                    gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH;
                                    
                                    putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);
                                    
                                    RadioTVPresetList_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gRadioTVPresetList_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gRadioTVPresetList_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE;
                        
                        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_RADIOTVPRESETLIST_DOWN_CACHE: 
                    if (gRadioTVPresetList_CallBackReason ==AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gRadioTVPresetList_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST; 
                            gRadioTVPresetList_cacheDown         =TRUE;

                            RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gRadioTVPresetList_CallBackReason =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST;
                            RadioTVPresetList_ListHandling(); 
                        }    
                    }
                    else if (gRadioTVPresetList_CallBackReason ==AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_NOCACHE;
                        gRadioTVPresetList_cacheDown         =FALSE;
                        gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);
                        RadioTVPresetList_display();
                        gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH;
                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        startelement            =gRadioTVPresetList_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gRadioTVPresetList_Pos[i];
                                    buffer_PresetIndex      =gRadioTVPresetList_PresetIndex[i];
                                    buffer_Waveband         =gRadioTVPresetList_Waveband[i];
                                    buffer_Attributes       =gRadioTVPresetList_Attributes[i];
                                    buffer_Attributes_bit0  =gRadioTVPresetList_Attributes_IBOC_Bit0[i];
                                    buffer_Attributes_bit1  =gRadioTVPresetList_Attributes_DABSecServ_Bit1[i];
                                    buffer_Attributes_bit2  =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i];
                                    buffer_Attributes_bit5  =gRadioTVPresetList_Attributes_TP_Bit5[i];
                                    buffer_Attributes_bit6  =gRadioTVPresetList_Attributes_TMC_Bit6[i];
                                    buffer_Attributes_bit7  =gRadioTVPresetList_Attributes_SDRAS_Bit7[i];
                                    buffer_Attributes_bit3  =gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i];
                                    buffer_Attributes_bit4  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i];
                                    buffer_Attributes_bit8  =gRadioTVPresetList_Attributes_StationSelect_Bit8[i];
                                    buffer_Attributes_bit9  =gRadioTVPresetList_Attributes_OnRadMute_Bit9[i];
                                    buffer_Attributes_bitA  =gRadioTVPresetList_Attributes_StationLinked_BitA[i];

                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gRadioTVPresetList_Name[i]);k++) 
                                        buffer_Name[k]=gRadioTVPresetList_Name[i][k];

                                    //copy data from Pos '1' to Pos '0'
                                    gRadioTVPresetList_Pos[i]                           =gRadioTVPresetList_Pos[j]; 
                                    gRadioTVPresetList_PresetIndex[i]                   =gRadioTVPresetList_PresetIndex[j];
                                    gRadioTVPresetList_Waveband[i]                      =gRadioTVPresetList_Waveband[j]; 
                                    gRadioTVPresetList_Attributes[i]                    =gRadioTVPresetList_Attributes[j];
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =gRadioTVPresetList_Attributes_IBOC_Bit0[j];
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =gRadioTVPresetList_Attributes_DABSecServ_Bit1[j];
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j];
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =gRadioTVPresetList_Attributes_TP_Bit5[j];
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =gRadioTVPresetList_Attributes_TMC_Bit6[j];
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =gRadioTVPresetList_Attributes_SDRAS_Bit7[j];
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]  =gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j];
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j];
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i]  =gRadioTVPresetList_Attributes_StationSelect_Bit8[j];
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]  =gRadioTVPresetList_Attributes_OnRadMute_Bit9[j];
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i]  =gRadioTVPresetList_Attributes_StationLinked_BitA[j];
                                
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0;                                     

                                    for(k=0;k<strlen(gRadioTVPresetList_Name[j]);k++) 
                                        gRadioTVPresetList_Name[i][k]=gRadioTVPresetList_Name[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gRadioTVPresetList_ListEntryReceptionInformation[i]     =0;
                                    gRadioTVPresetList_Pos[i]                               =0;
                                    gRadioTVPresetList_PresetIndex[i]                       =0;
                                    gRadioTVPresetList_Waveband[i]                          =0;
                                    gRadioTVPresetList_Attributes[i]                        =0;
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]              =0;
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]        =0;
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]       =0;
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]                =0;
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]               =0;
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]             =0;
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]    =0;
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]      =0;
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i]     =0;
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]         =0;
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i]     =0;
                                    
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gRadioTVPresetList_Pos[i]                           =buffer_Pos; 
                                    gRadioTVPresetList_PresetIndex[i]                   =buffer_PresetIndex;
                                    gRadioTVPresetList_Waveband[i]                      =buffer_Waveband;
                                    gRadioTVPresetList_Attributes[i]                    =buffer_Attributes;
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =buffer_Attributes_bit0;
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =buffer_Attributes_bit1;
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =buffer_Attributes_bit2;
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =buffer_Attributes_bit7;
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =buffer_Attributes_bit6;
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =buffer_Attributes_bit7;
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]=buffer_Attributes_bit3;
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =buffer_Attributes_bit4;
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i] =buffer_Attributes_bit8;
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]     =buffer_Attributes_bit9;
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i] =buffer_Attributes_bitA;
                                    
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gRadioTVPresetList_Name[i][k]=buffer_Name[k];

                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gRadioTVPresetList_Pos[i]                           =gRadioTVPresetList_Pos[j]; 
                                    gRadioTVPresetList_PresetIndex[i]                   =gRadioTVPresetList_PresetIndex[j];
                                    gRadioTVPresetList_Waveband[i]                      =gRadioTVPresetList_Waveband[j];
                                    gRadioTVPresetList_Attributes[i]                    =gRadioTVPresetList_Attributes[j];
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =gRadioTVPresetList_Attributes_IBOC_Bit0[j];
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =gRadioTVPresetList_Attributes_DABSecServ_Bit1[j]; 
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j];
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =gRadioTVPresetList_Attributes_TP_Bit5[j];
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =gRadioTVPresetList_Attributes_TMC_Bit6[j];
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =gRadioTVPresetList_Attributes_SDRAS_Bit7[j];
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]  =gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j];
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j];
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i]  =gRadioTVPresetList_Attributes_StationSelect_Bit8[j];
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]  =gRadioTVPresetList_Attributes_OnRadMute_Bit9[j];
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i]  =gRadioTVPresetList_Attributes_StationLinked_BitA[j];
                                 
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gRadioTVPresetList_Name[j]);k++) 
                                        gRadioTVPresetList_Name[i][k]=gRadioTVPresetList_Name[j][k];
                                        
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_RADIOTVPRESETLIST_UP_CACHE: 
                    if (gRadioTVPresetList_CallBackReason ==AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gRadioTVPresetList_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gRadioTVPresetList_cacheUp        =TRUE;
                            gRadioTVPresetList_CallBackReason =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST;
                            
                            RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gRadioTVPresetList_CallBackReason =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST;
                            RadioTVPresetList_ListHandling();
                        }           
                    }

                    else if (gRadioTVPresetList_CallBackReason ==AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_NOCACHE;
                        gRadioTVPresetList_cacheUp           =FALSE;
                        gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, empty_string);
                        RadioTVPresetList_display();
                        gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH;
                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        putvalue(env_ASG_AudioSD_RTPL_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        startelement            =gRadioTVPresetList_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gRadioTVPresetList_Pos[i];
                                    buffer_PresetIndex      =gRadioTVPresetList_PresetIndex[i];
                                    buffer_Waveband         =gRadioTVPresetList_Waveband[i];
                                    buffer_Attributes       =gRadioTVPresetList_Attributes[i];
                                    buffer_Attributes_bit0  =gRadioTVPresetList_Attributes_IBOC_Bit0[i];
                                    buffer_Attributes_bit1  =gRadioTVPresetList_Attributes_DABSecServ_Bit1[i];
                                    buffer_Attributes_bit2  =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i];
                                    buffer_Attributes_bit5  =gRadioTVPresetList_Attributes_TP_Bit5[i];
                                    buffer_Attributes_bit6  =gRadioTVPresetList_Attributes_TMC_Bit6[i];
                                    buffer_Attributes_bit7  =gRadioTVPresetList_Attributes_SDRAS_Bit7[i];   
                                    buffer_Attributes_bit3  =gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j];
                                    buffer_Attributes_bit4  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j];
                                    buffer_Attributes_bit8  =gRadioTVPresetList_Attributes_StationSelect_Bit8[j];
                                    buffer_Attributes_bit9  =gRadioTVPresetList_Attributes_OnRadMute_Bit9[j];
                                    buffer_Attributes_bitA  =gRadioTVPresetList_Attributes_StationLinked_BitA[j];

                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gRadioTVPresetList_Name[i]);k++) 
                                        buffer_Name[k]=gRadioTVPresetList_Name[i][k];

                                    //copy data from Pos '7' to Pos '8'
                                    gRadioTVPresetList_Pos[i]                           =gRadioTVPresetList_Pos[j]; 
                                    gRadioTVPresetList_PresetIndex[i]                   =gRadioTVPresetList_PresetIndex[j];
                                    gRadioTVPresetList_Waveband[i]                      =gRadioTVPresetList_Waveband[j];
                                    gRadioTVPresetList_Attributes[i]                    =gRadioTVPresetList_Attributes[j];
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =gRadioTVPresetList_Attributes_IBOC_Bit0[j];
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =gRadioTVPresetList_Attributes_DABSecServ_Bit1[j];
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j];
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =gRadioTVPresetList_Attributes_TP_Bit5[j];
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =gRadioTVPresetList_Attributes_TMC_Bit6[j];
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =gRadioTVPresetList_Attributes_SDRAS_Bit7[j];
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]  =gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j];
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j];
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i]  =gRadioTVPresetList_Attributes_StationSelect_Bit8[j];
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]  =gRadioTVPresetList_Attributes_OnRadMute_Bit9[j];
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i]  =gRadioTVPresetList_Attributes_StationLinked_BitA[j];
                                    
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gRadioTVPresetList_Name[j]);k++) 
                                        gRadioTVPresetList_Name[i][k]=gRadioTVPresetList_Name[j][k];
                                    
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gRadioTVPresetList_ListEntryReceptionInformation[i]    =0;
                                    gRadioTVPresetList_Pos[i]                              =0;
                                    gRadioTVPresetList_PresetIndex[i]                      =0;
                                    gRadioTVPresetList_Waveband[i]                         =0;
                                    gRadioTVPresetList_Attributes[i]                       =0;
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]             =0;
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]       =0;
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]      =0;
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]               =0;
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]              =0;
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]            =0;
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]   =0;
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]     =0;
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i]    =0;
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]        =0;
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i]    =0;
                            
                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gRadioTVPresetList_Pos[i]                           =buffer_Pos; 
                                    gRadioTVPresetList_PresetIndex[i]                   =buffer_PresetIndex;
                                    gRadioTVPresetList_Waveband[i]                      =buffer_Waveband;
                                    gRadioTVPresetList_Attributes[i]                    =buffer_Attributes;
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =buffer_Attributes_bit0;
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =buffer_Attributes_bit1;
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =buffer_Attributes_bit2;
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =buffer_Attributes_bit7;
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =buffer_Attributes_bit6;
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =buffer_Attributes_bit7;
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]=buffer_Attributes_bit3;
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =buffer_Attributes_bit4;
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i] =buffer_Attributes_bit8;
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]     =buffer_Attributes_bit9;
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i] =buffer_Attributes_bitA;

                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gRadioTVPresetList_Name[i][k]=buffer_Name[k];

                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gRadioTVPresetList_Pos[i]                           =gRadioTVPresetList_Pos[j]; 
                                    gRadioTVPresetList_PresetIndex[i]                   =gRadioTVPresetList_PresetIndex[j];
                                    gRadioTVPresetList_Waveband[i]                      =gRadioTVPresetList_Waveband[j];
                                    gRadioTVPresetList_Attributes[i]                    =gRadioTVPresetList_Attributes[j];
                                    gRadioTVPresetList_Attributes_IBOC_Bit0[i]          =gRadioTVPresetList_Attributes_IBOC_Bit0[j];
                                    gRadioTVPresetList_Attributes_DABSecServ_Bit1[i]    =gRadioTVPresetList_Attributes_DABSecServ_Bit1[j];
                                    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[i]   =gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j];
                                    gRadioTVPresetList_Attributes_TP_Bit5[i]            =gRadioTVPresetList_Attributes_TP_Bit5[j];
                                    gRadioTVPresetList_Attributes_TMC_Bit6[i]           =gRadioTVPresetList_Attributes_TMC_Bit6[j];
                                    gRadioTVPresetList_Attributes_SDRAS_Bit7[i]         =gRadioTVPresetList_Attributes_SDRAS_Bit7[j];     
                                    gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[i]=gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j];
                                    gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[i]  =gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j];
                                    gRadioTVPresetList_Attributes_StationSelect_Bit8[i] =gRadioTVPresetList_Attributes_StationSelect_Bit8[j];
                                    gRadioTVPresetList_Attributes_OnRadMute_Bit9[i]     =gRadioTVPresetList_Attributes_OnRadMute_Bit9[j];
                                    gRadioTVPresetList_Attributes_StationLinked_BitA[i] =gRadioTVPresetList_Attributes_StationLinked_BitA[j];

                                    for (k=0; k<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;k++) //clear string
                                        gRadioTVPresetList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gRadioTVPresetList_Name[j]);k++) 
                                        gRadioTVPresetList_Name[i][k]=gRadioTVPresetList_Name[j][k];
                                     
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gRadioTVPresetList_CallBackReason    =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

RadioTVPresetList_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_RTPL_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gRadioTVPresetList_DisplayStatus ==AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gRadioTVPresetList_CursorAction ==AUDIO_RADIOTVPRESETLIST_CURSORACTION_DOWN)
                Element_1 =RadioTVPresetList_GetNextCachedElement(gRadioTVPresetList_LastFirstElement, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gRadioTVPresetList_CursorAction ==AUDIO_RADIOTVPRESETLIST_CURSORACTION_UP)            
                Element_1 =RadioTVPresetList_GetNextCachedElement(gRadioTVPresetList_LastFirstElement, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_0, gRadioTVPresetList_Pos[Element_1]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_0,gRadioTVPresetList_PresetIndex[Element_1]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_0, gRadioTVPresetList_Waveband[Element_1]);

                if(gRadioTVPresetList_Waveband[Element_1] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, gRadioTVPresetList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_0,gRadioTVPresetList_Name[Element_1]);

            gRadioTVPresetList_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =RadioTVPresetList_GetNextCachedElement(Element_1, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_1, gRadioTVPresetList_Pos[Element_2]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_1,gRadioTVPresetList_PresetIndex[Element_2]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_1, gRadioTVPresetList_Waveband[Element_2]);

                if(gRadioTVPresetList_Waveband[Element_2] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, gRadioTVPresetList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_1,gRadioTVPresetList_Name[Element_2]);
             
            
            //3. Element          
            Element_3 =RadioTVPresetList_GetNextCachedElement(Element_2, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_2, gRadioTVPresetList_Pos[Element_3]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_2,gRadioTVPresetList_PresetIndex[Element_3]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_2, gRadioTVPresetList_Waveband[Element_3]);

                if(gRadioTVPresetList_Waveband[Element_3] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, gRadioTVPresetList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_2,gRadioTVPresetList_Name[Element_3]);       
        }
        
        /******'sliding Window' active or 'build-up List'******/
        else if(gRadioTVPresetList_DisplayStatus ==AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gRadioTVPresetList_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_RTPL_OnOff))
            {   
                Element_1 =0;
                
            //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_0, gRadioTVPresetList_Pos[Element_1]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_0,gRadioTVPresetList_PresetIndex[Element_1]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_0, gRadioTVPresetList_Waveband[Element_1]);

                if(gRadioTVPresetList_Waveband[Element_1] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, gRadioTVPresetList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_0,gRadioTVPresetList_Name[Element_1]);
            }
            
            //2. Element    
            if(gRadioTVPresetList_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_RTPL_OnOff))
            {
                Element_2 =1;
                
            //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_1, gRadioTVPresetList_Pos[Element_2]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_1,gRadioTVPresetList_PresetIndex[Element_2]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_1, gRadioTVPresetList_Waveband[Element_2]);

                if(gRadioTVPresetList_Waveband[Element_2] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, gRadioTVPresetList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_1,gRadioTVPresetList_Name[Element_2]);
            }

            //3. Element    
            if(gRadioTVPresetList_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_RTPL_OnOff))
            {
                Element_3 =2;
             
                //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_2, gRadioTVPresetList_Pos[Element_3]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_2,gRadioTVPresetList_PresetIndex[Element_3]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_2, gRadioTVPresetList_Waveband[Element_3]);

                if(gRadioTVPresetList_Waveband[Element_3] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, gRadioTVPresetList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_2,gRadioTVPresetList_Name[Element_3]);
            }
        }    
            
        else if (gRadioTVPresetList_DisplayStatus ==AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH)
        {          
            //1. Element
            if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gRadioTVPresetList_LastFirstElement; 
            else
                Element_1 =0;

            if(gRadioTVPresetList_ListEntryReceptionInformation[Element_1])
            {
                //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_0, gRadioTVPresetList_Pos[Element_1]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_0,gRadioTVPresetList_PresetIndex[Element_1]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_0, gRadioTVPresetList_Waveband[Element_1]);

                if(gRadioTVPresetList_Waveband[Element_1] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_0,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, gRadioTVPresetList_Attributes_TP_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_1]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_1]]);
                
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_1]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_1]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_0,gRadioTVPresetList_Name[Element_1]);
            }//END: Element_1
                

            //2. Element             
            if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =RadioTVPresetList_GetNextCachedElement(Element_1, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gRadioTVPresetList_ListEntryReceptionInformation[Element_2])
            {
                //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_1, gRadioTVPresetList_Pos[Element_2]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_1,gRadioTVPresetList_PresetIndex[Element_2]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_1, gRadioTVPresetList_Waveband[Element_2]);

                if(gRadioTVPresetList_Waveband[Element_2] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_1,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, gRadioTVPresetList_Attributes_TP_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_2]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_2]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_2]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_2]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_1,gRadioTVPresetList_Name[Element_2]);
            
            }//END: Element_2

            //3. Element          
            if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =RadioTVPresetList_GetNextCachedElement(Element_2, AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gRadioTVPresetList_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
            putvalue(env_ASG_AudioSD_RTPL_pos_2, gRadioTVPresetList_Pos[Element_3]);               

            //PresetIndex
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_PI_2,gRadioTVPresetList_PresetIndex[Element_3]);
            
            //Waveband
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_RTPL_WB_2, gRadioTVPresetList_Waveband[Element_3]);

                if(gRadioTVPresetList_Waveband[Element_3] <0x0E)
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_RTPL_WB_s_2,gstring_reserved);
            }

            //Attributes
            if (gRadioTVPresetList_recordaddress ==0) 
            {
                putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2,gRadioTVPresetList_Attributes_IBOC_Bit0_s[gRadioTVPresetList_Attributes_IBOC_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2,gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[gRadioTVPresetList_Attributes_DABSecServ_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2,gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[gRadioTVPresetList_Attributes_DABPrimServ_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, gRadioTVPresetList_Attributes_TP_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2,gRadioTVPresetList_Attributes_TP_Bit5_s[gRadioTVPresetList_Attributes_TP_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2,gRadioTVPresetList_Attributes_TMC_Bit6_s[gRadioTVPresetList_Attributes_TMC_Bit6[Element_3]]);

                putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2,gRadioTVPresetList_Attributes_SDARS_Bit7_s[gRadioTVPresetList_Attributes_SDRAS_Bit7[Element_3]]);
              
                putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2,gRadioTVPresetList_Attributes_OnRadSecondary_Bit3_s[gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2,gRadioTVPresetList_Attributes_OnRadPrimary_Bit4_s[gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2,gRadioTVPresetList_Attributes_StationSelect_Bit8_s[gRadioTVPresetList_Attributes_StationSelect_Bit8[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2,gRadioTVPresetList_Attributes_OnRadMute_Bit9_s[gRadioTVPresetList_Attributes_OnRadMute_Bit9[Element_3]]);
                putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]);
                putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2,gRadioTVPresetList_Attributes_StationLinked_BitA_s[gRadioTVPresetList_Attributes_StationLinked_BitA[Element_3]]);
            }

            //Name
            if (gRadioTVPresetList_recordaddress ==0 || gRadioTVPresetList_recordaddress ==1 || gRadioTVPresetList_recordaddress ==2)
                putvalue(env_ASG_AudioSD_RTPL_Name_s_2,gRadioTVPresetList_Name[Element_3]);     
            }
        }
    }
}

on envVar env_ASG_AudioSD_RTPL_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gRadioTVPresetList_ListHandlingType ==AUDIO_RADIOTVPRESETLIST_NOCACHE)
	{
        gRadioTVPresetList_ASGID            =getvalue(env_ASG_AudioSD_RTPL_ASGID);
        gRadioTVPresetList_TAID             =getvalue(env_ASG_AudioSD_RTPL_TAID);

        shift                           =getvalue(env_ASG_AudioSD_RTPL_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_RTPL_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_RTPL_AH_PosTrans);
        recordaddress                   =getvalue(env_ASG_AudioSD_RTPL_AH_RA);
        indexsize                       =getvalue(env_ASG_AudioSD_RTPL_AH_IS);
        startelement                    =getvalue(env_ASG_AudioSD_RTPL_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_RTPL_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on envVar env_ASG_AudioSD_RTPL_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gRadioTVPresetList_ListHandlingType      =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHE;             //build-up complete cache...
            gRadioTVPresetList_cacheBuildUp          =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            RadioTVPresetList_ListHandling ();
        }
        else
        {
            gRadioTVPresetList_SlidingWindow_State   =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
            gRadioTVPresetList_ListHandlingType      =AUDIO_RADIOTVPRESETLIST_NOCACHE;
            gRadioTVPresetList_cacheBuildUp          =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;
            gRadioTVPresetList_CallBackReason        =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;

            gRadioTVPresetList_cacheDown             =FALSE;
            gRadioTVPresetList_cacheUp               =FALSE;
            gRadioTVPresetList_LastFirstElement      =0;

            gRadioTVPresetList_recordaddress         =0;
            gRadioTVPresetList_transmitpos           =1;
            gRadioTVPresetList_CursorAction          =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
            gRadioTVPresetList_DisplayStatus         =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; j++)
            {     
                gRadioTVPresetList_Pos[j]                               =0;
                gRadioTVPresetList_PresetIndex[j]                       =0;
                gRadioTVPresetList_Waveband[j]                          =0;
                gRadioTVPresetList_Attributes_IBOC_Bit0[j]              =0;
                gRadioTVPresetList_Attributes_DABSecServ_Bit1[j]        =0;
                gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j]       =0;
                gRadioTVPresetList_Attributes_TP_Bit5[j]                =0;
                gRadioTVPresetList_Attributes_TMC_Bit6[j]               =0;
                gRadioTVPresetList_Attributes_SDRAS_Bit7[j]             =0;
                gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[j]    =0;
                gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[j]      =0;
                gRadioTVPresetList_Attributes_OnRadMute_Bit9[j]         =0;
                gRadioTVPresetList_Attributes_StationSelect_Bit8[j]     =0;
                gRadioTVPresetList_Attributes_StationLinked_BitA[j]     =0;
                gRadioTVPresetList_Attributes[j]                        =0;
                gRadioTVPresetList_ListEntryReceptionInformation[j]     =0;

                for(i=0;i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++)
			        gRadioTVPresetList_Name[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_RTPL_pos_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_pos_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_RTPL_PI_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_PI_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_PI_2, 0);

            putvalue(env_ASG_AudioSD_RTPL_WB_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_WB_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_WB_2, 0);

            putvalue(env_ASG_AudioSD_RTPL_WB_s_0,empty_string);
            putvalue(env_ASG_AudioSD_RTPL_WB_s_1,empty_string);
            putvalue(env_ASG_AudioSD_RTPL_WB_s_2,empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit0_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit0_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit0_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit0_2, empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit1_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit1_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit1_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit1_2, empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit2_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit2_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit2_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit2_2, empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit5_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit5_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit5_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit5_2, empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit6_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit6_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit6_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit6_2, empty_string);

            putvalue(env_ASG_AudioSD_RTPL_At_bit7_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit7_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit7_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit7_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_At_bit3_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit3_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit3_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit3_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_At_bit4_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit4_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit4_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit4_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_At_bit8_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit8_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit8_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit8_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_At_bit9_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit9_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bit9_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bit9_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_At_bitA_0, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bitA_1, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_bitA_2, 0);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_At_s_bitA_2, empty_string);
            
            putvalue(env_ASG_AudioSD_RTPL_Name_s_0, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_Name_s_1, empty_string);
            putvalue(env_ASG_AudioSD_RTPL_Name_s_2, empty_string);    
        }
    }
}   

on envVar env_ASG_AudioSD_RTPL_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gRadioTVPresetList_ListHandlingType ==AUDIO_RADIOTVPRESETLIST_NOCACHE)
	{      
        gRadioTVPresetList_CursorAction =AUDIO_RADIOTVPRESETLIST_CURSORACTION_DOWN;
        
        if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE)
        {   
            gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_DOWN_CACHE;
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
            
            RadioTVPresetList_ListHandling ();
        }
        else if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_DOWN;

            RadioTVPresetList_display();

            //reset values
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_RTPL_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gRadioTVPresetList_ListHandlingType ==AUDIO_RADIOTVPRESETLIST_NOCACHE)
	{   
        gRadioTVPresetList_CursorAction =AUDIO_RADIOTVPRESETLIST_CURSORACTION_UP;

        if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE)
        {  
            gRadioTVPresetList_ListHandlingType  =AUDIO_RADIOTVPRESETLIST_UP_CACHE;
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
            
            RadioTVPresetList_ListHandling ();
        }
        else if(gRadioTVPresetList_SlidingWindow_State ==AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_UP;

            RadioTVPresetList_ListHandling();
            
            RadioTVPresetList_display();

            //reset values
            gRadioTVPresetList_DisplayStatus     =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH;
            gRadioTVPresetList_CursorAction      =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
        }    
    }
}

int TpMemoList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gTpMemoList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gTpMemoList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int TpMemoList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_TPMEMOLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_TPMEMOLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

TpMemoList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_TPMemoList;	        //Fct.-ID
	requestarray[2] =request;                   //request type

    switch(request)
	{
        case DataGet_REQ:            
                requestarray[3] =((gTpMemoList_ASGID *0x10) &0xF0) +(gTpMemoList_TAID &0x0F);
                
                /***ArrayHeader***/
			    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD TpMemoList_Request: invalid request %d", request);
		break;
    }
}

TpMemoList_Indication(dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;
    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gTpMemoList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gTpMemoList_TAID  =Indication_array[3] &0x0F;             

                gTpMemoList_TotalNumListElements =Indication_array[4];
              
                /***ArrayHeader***/
                mode            =(Indication_array[5] &0xF0) /0x10;
                recordaddress   =Indication_array[5] &0x0F;
                Offset =6;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 
                
                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gTpMemoList_Pos[i])  
                            i =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record
                         
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //StationName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++) //clear
			                                gTpMemoList_StationName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gTpMemoList_StationName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //StationName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++) //clear
			                                gTpMemoList_StationName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gTpMemoList_StationName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Attributes, MessageTime_Hour, MessageTime_Minute
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                        
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_TML_ASGID, gTpMemoList_ASGID);
                putvalue(env_ASG_AudioSD_TML_TAID, gTpMemoList_TAID);
                putvalue(env_ASG_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements);

                gTpMemoList_recordaddress =recordaddress;
                gTpMemoList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 
                
                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gTpMemoList_Pos[i])  
                            i =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_TML_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_TML_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record
                         
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //StationName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++) //clear
			                                gTpMemoList_StationName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gTpMemoList_StationName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //StationName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++) //clear
			                                gTpMemoList_StationName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gTpMemoList_StationName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Attributes, MessageTime_Hour, MessageTime_Minute
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++; 
                                        
                                        gTpMemoList_Attributes_NewMessage_Bit0[current_element]        =(gTpMemoList_Attributes[current_element] &0x01);
                                    }

                                    //MessageTime_Hour
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Hour[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MessageTime_Minute
                                    if(CacheElements ==TRUE)
                                    {
                                        gTpMemoList_Minute[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    
                    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gTpMemoList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gTpMemoList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gTpMemoList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gTpMemoList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION) 
                            {   
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gTpMemoList_Pos[i] && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gTpMemoList_ListHandlingType !=AUDIO_TPMEMOLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gTpMemoList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =TpMemoList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_TPMEMOLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gTpMemoList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gTpMemoList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gTpMemoList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gTpMemoList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gTpMemoList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =TpMemoList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                        
                     break; //recordaddress =0xf ends
                }
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_TML_ASGID, gTpMemoList_ASGID);
                putvalue(env_ASG_AudioSD_TML_TAID, gTpMemoList_TAID);
                putvalue(env_ASG_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements);

                gTpMemoList_recordaddress =recordaddress;
                gTpMemoList_transmitpos   =transmitpos; 
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD TpMemoList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD TpMemoList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD TpMemoList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD TpMemoList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD TpMemoList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gTpMemoList_TotalNumListElements<=AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE)
        gTpMemoList_SlidingWindow_State =AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gTpMemoList_SlidingWindow_State =AUDIO_TPMEMOLIST_SLIDINGWINDOW_ACTIVE;

    if (gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK)
        TpMemoList_ListHandling ();
    else
        TpMemoList_display();
}

TpMemoList_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_Attributes_bit0, buffer_Attributes, buffer_Hour, buffer_Minute, buffer_ReceptionInformation;
    word requested_startelement, startelement, elements, buffer_Pos;
    char buffer_StationName[AUDIO_TPMEMOLIST_STATIONNAME_LENGTH];
    int i,j,k;

    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_Hour                 =0;
    buffer_Minute               =0;
    buffer_ReceptionInformation =0;
    buffer_Attributes           =0;
    buffer_Attributes_bit0      =0;
    
    /***build-up complete cache***/

    switch (gTpMemoList_ListHandlingType)
    {
        case AUDIO_TPMEMOLIST_BUILDUPCACHE:
             
            switch (gTpMemoList_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_UP:  
                    if(gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE && gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gTpMemoList_CallBackReason)
                        {
                            case AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE:

                                    if(gTpMemoList_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gTpMemoList_cacheBuildUp      =AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        TpMemoList_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gTpMemoList_cacheBuildUp      =AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_NOCACHE;              
                                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK; 
                                        gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
                                        
                                        putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);
                                        TpMemoList_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gTpMemoList_CallBackReason  =AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE;

                        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_WINDOW: 
                    if(gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE && gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gTpMemoList_CallBackReason)
                        {
                            case AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gTpMemoList_cacheBuildUp      =AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT;    
                                    
                                    TpMemoList_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        putvalue(env_ASG_AudioSD_TML_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gTpMemoList_CallBackReason  =AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE;

                        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_DOWN:   
                    if(gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE && gTpMemoList_CallBackReason !=AUDIO_TPMEMOLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gTpMemoList_CallBackReason)
                        {
                            case AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gTpMemoList_cacheBuildUp      =AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_NOCACHE;              
                                    gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;
                                    gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
                                    
                                    gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH;
                                    
                                    putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);
                                    
                                    TpMemoList_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gTpMemoList_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gTpMemoList_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE;
                        
                        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_TPMEMOLIST_DOWN_CACHE: 
                    if (gTpMemoList_CallBackReason ==AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gTpMemoList_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST; 
                            gTpMemoList_cacheDown         =TRUE;

                            TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gTpMemoList_CallBackReason =AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST;
                            TpMemoList_ListHandling(); 
                        }    
                    }
                    else if (gTpMemoList_CallBackReason ==AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_NOCACHE;
                        gTpMemoList_cacheDown         =FALSE;
                        gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);
                        TpMemoList_display();
                        gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH;
                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        putvalue(env_ASG_AudioSD_TML_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        startelement            =gTpMemoList_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gTpMemoList_Pos[i];
                                    buffer_Attributes       =gTpMemoList_Attributes[i];
                                    buffer_Attributes_bit0  =gTpMemoList_Attributes_NewMessage_Bit0[i];
                                    buffer_Hour             =gTpMemoList_Hour[i];
                                    buffer_Minute           =gTpMemoList_Minute[i];
                                    
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        buffer_StationName[k] =0;                                     

                                    for(k=0;k<strlen(gTpMemoList_StationName[i]);k++) 
                                        buffer_StationName[k]=gTpMemoList_StationName[i][k];

                                    //copy data from Pos '1' to Pos '0'
                                    gTpMemoList_Pos[i]                           =gTpMemoList_Pos[j]; 
                                    gTpMemoList_Attributes[i]                    =gTpMemoList_Attributes[j];
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]    =gTpMemoList_Attributes_NewMessage_Bit0[j];
                                    gTpMemoList_Hour[i]                          =gTpMemoList_Hour[j]; 
                                    gTpMemoList_Minute[i]                        =gTpMemoList_Minute[j];    
                                    
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0;                                     

                                    for(k=0;k<strlen(gTpMemoList_StationName[j]);k++) 
                                        gTpMemoList_StationName[i][k]=gTpMemoList_StationName[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gTpMemoList_ListEntryReceptionInformation[i]    =0;
                                    gTpMemoList_Pos[i]                              =0;
                                    gTpMemoList_Attributes[i]                       =0;
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]       =0;
                                    gTpMemoList_Hour[i]                             =0;
                                    gTpMemoList_Minute[i]                           =0;

                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gTpMemoList_Pos[i]                           =buffer_Pos; 
                                    gTpMemoList_Attributes[i]                    =buffer_Attributes;
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]    =buffer_Attributes_bit0;
                                    gTpMemoList_Hour[i]                          =buffer_Hour;
                                    gTpMemoList_Minute[i]                        =buffer_Minute;
                                    
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_StationName);k++) 
                                        gTpMemoList_StationName[i][k]=buffer_StationName[k];

                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gTpMemoList_Pos[i]                          =gTpMemoList_Pos[j]; 
                                    gTpMemoList_Attributes[i]                   =gTpMemoList_Attributes[j];
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]   =gTpMemoList_Attributes_NewMessage_Bit0[j];
                                    gTpMemoList_Hour[i]                         =gTpMemoList_Hour[j];
                                    gTpMemoList_Minute[i]                       =gTpMemoList_Minute[j];
                                 
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gTpMemoList_StationName[j]);k++) 
                                        gTpMemoList_StationName[i][k]=gTpMemoList_StationName[j][k];
                                        
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_TPMEMOLIST_UP_CACHE: 
                    if (gTpMemoList_CallBackReason ==AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gTpMemoList_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gTpMemoList_cacheUp        =TRUE;
                            gTpMemoList_CallBackReason =AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST;
                            
                            TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gTpMemoList_CallBackReason =AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST;
                            TpMemoList_ListHandling();
                        }           
                    }

                    else if (gTpMemoList_CallBackReason ==AUDIO_TPMEMOLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_NOCACHE;
                        gTpMemoList_cacheUp           =FALSE;
                        gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_TML_ListOpState, empty_string);
                        TpMemoList_display();
                        gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH;
                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        putvalue(env_ASG_AudioSD_TML_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        startelement            =gTpMemoList_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gTpMemoList_Pos[i];
                                    buffer_Attributes       =gTpMemoList_Attributes[i];
                                    buffer_Attributes_bit0  =gTpMemoList_Attributes_NewMessage_Bit0[i];                              
                                    buffer_Hour             =gTpMemoList_Hour[i];
                                    buffer_Minute           =gTpMemoList_Minute[i];
                                    
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        buffer_StationName[k] =0;                                     

                                    for(k=0;k<strlen(gTpMemoList_StationName[i]);k++) 
                                        buffer_StationName[k]=gTpMemoList_StationName[i][k];

                                    //copy data from Pos '7' to Pos '8'
                                    gTpMemoList_Pos[i]                          =gTpMemoList_Pos[j]; 
                                    gTpMemoList_Attributes[i]                   =gTpMemoList_Attributes[j];
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]   =gTpMemoList_Attributes_NewMessage_Bit0[j];
                                    gTpMemoList_Hour[i]                         =gTpMemoList_Hour[j];
                                    gTpMemoList_Minute[i]                       =gTpMemoList_Minute[j];

                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gTpMemoList_StationName[j]);k++) 
                                        gTpMemoList_StationName[i][k]=gTpMemoList_StationName[j][k];
                                    
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gTpMemoList_ListEntryReceptionInformation[i]    =0;
                                    gTpMemoList_Pos[i]                              =0;
                                    gTpMemoList_Attributes[i]                       =0;
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]       =0;
                                    gTpMemoList_Hour[i]                             =0;
                                    gTpMemoList_Minute[i]                           =0;                            
                                    
                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gTpMemoList_Pos[i]                          =buffer_Pos; 
                                    gTpMemoList_Attributes[i]                   =buffer_Attributes;
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]   =buffer_Attributes_bit0;
                                    gTpMemoList_Hour[i]                         =buffer_Hour;
                                    gTpMemoList_Minute[i]                       =buffer_Minute;

                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_StationName);k++) 
                                        gTpMemoList_StationName[i][k]=buffer_StationName[k];

                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gTpMemoList_Pos[i]                          =gTpMemoList_Pos[j]; 
                                    gTpMemoList_Attributes[i]                   =gTpMemoList_Attributes[j];
                                    gTpMemoList_Attributes_NewMessage_Bit0[i]   =gTpMemoList_Attributes_NewMessage_Bit0[j];
                                    gTpMemoList_Hour[i]                         =gTpMemoList_Hour[j];
                                    gTpMemoList_Minute[i]                       =gTpMemoList_Minute[j];

                                    for (k=0; k<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;k++) //clear string
                                        gTpMemoList_StationName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gTpMemoList_StationName[j]);k++) 
                                        gTpMemoList_StationName[i][k]=gTpMemoList_StationName[j][k];
                                     
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gTpMemoList_CallBackReason    =AUDIO_TPMEMOLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

TpMemoList_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_TML_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gTpMemoList_DisplayStatus ==AUDIO_TPMEMOLIST_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gTpMemoList_CursorAction ==AUDIO_TPMEMOLIST_CURSORACTION_DOWN)
                Element_1 =TpMemoList_GetNextCachedElement(gTpMemoList_LastFirstElement, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gTpMemoList_CursorAction ==AUDIO_TPMEMOLIST_CURSORACTION_UP)            
                Element_1 =TpMemoList_GetNextCachedElement(gTpMemoList_LastFirstElement, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_TML_pos_0, gTpMemoList_Pos[Element_1]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_0, gTpMemoList_Attributes_NewMessage_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_0,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_1]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_0,gTpMemoList_Hour[Element_1]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_0,gTpMemoList_Minute[Element_1]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_0,gTpMemoList_StationName[Element_1]);

            gTpMemoList_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =TpMemoList_GetNextCachedElement(Element_1, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_TML_pos_1, gTpMemoList_Pos[Element_2]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_1, gTpMemoList_Attributes_NewMessage_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_1,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_2]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_1,gTpMemoList_Hour[Element_2]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_1,gTpMemoList_Minute[Element_2]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_1,gTpMemoList_StationName[Element_2]);
             
            
            //3. Element          
            Element_3 =TpMemoList_GetNextCachedElement(Element_2, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_TML_pos_2, gTpMemoList_Pos[Element_3]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_2, gTpMemoList_Attributes_NewMessage_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_2,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_3]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_2,gTpMemoList_Hour[Element_3]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_2,gTpMemoList_Minute[Element_3]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_2,gTpMemoList_StationName[Element_3]);       
        }
        
        /******'sliding Window' active or 'build-up List'******/
        else if(gTpMemoList_DisplayStatus ==AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gTpMemoList_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_TML_OnOff))
            {   
                Element_1 =0;
                
            //Pos
            putvalue(env_ASG_AudioSD_TML_pos_0, gTpMemoList_Pos[Element_1]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_0, gTpMemoList_Attributes_NewMessage_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_0,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_1]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_0,gTpMemoList_Hour[Element_1]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_0,gTpMemoList_Minute[Element_1]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_0,gTpMemoList_StationName[Element_1]);
            }
            
            //2. Element    
            if(gTpMemoList_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_TML_OnOff))
            {
                Element_2 =1;
                
            //Pos
            putvalue(env_ASG_AudioSD_TML_pos_1, gTpMemoList_Pos[Element_2]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_1, gTpMemoList_Attributes_NewMessage_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_1,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_2]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_1,gTpMemoList_Hour[Element_2]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_1,gTpMemoList_Minute[Element_2]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_1,gTpMemoList_StationName[Element_2]);
            }

            //3. Element    
            if(gTpMemoList_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_TML_OnOff))
            {
                Element_3 =2;
             
                //Pos
            putvalue(env_ASG_AudioSD_TML_pos_2, gTpMemoList_Pos[Element_3]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_2, gTpMemoList_Attributes_NewMessage_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_2,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_3]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_2,gTpMemoList_Hour[Element_3]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_2,gTpMemoList_Minute[Element_3]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_2,gTpMemoList_StationName[Element_3]); 
            }
        }    
            
        else if (gTpMemoList_DisplayStatus ==AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH)
        {          
            //1. Element
            if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gTpMemoList_LastFirstElement; 
            else
                Element_1 =0;

            if(gTpMemoList_ListEntryReceptionInformation[Element_1])
            {
                //Pos
            putvalue(env_ASG_AudioSD_TML_pos_0, gTpMemoList_Pos[Element_1]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_0, gTpMemoList_Attributes_NewMessage_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_0,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_1]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_0,gTpMemoList_Hour[Element_1]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_0,gTpMemoList_Minute[Element_1]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_0,gTpMemoList_StationName[Element_1]);
            }//END: Element_1
                

            //2. Element             
            if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =TpMemoList_GetNextCachedElement(Element_1, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gTpMemoList_ListEntryReceptionInformation[Element_2])
            {
                //Pos
            putvalue(env_ASG_AudioSD_TML_pos_1, gTpMemoList_Pos[Element_2]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_1, gTpMemoList_Attributes_NewMessage_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_1,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_2]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_1,gTpMemoList_Hour[Element_2]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_1,gTpMemoList_Minute[Element_2]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_1,gTpMemoList_StationName[Element_2]);
            
            }//END: Element_2

            //3. Element          
            if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =TpMemoList_GetNextCachedElement(Element_2, AUDIO_TPMEMOLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gTpMemoList_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
            putvalue(env_ASG_AudioSD_TML_pos_2, gTpMemoList_Pos[Element_3]);               

            //Attributes
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_TML_At_bit0_2, gTpMemoList_Attributes_NewMessage_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_TML_At_s_bit0_2,gTpMemoList_Attributes_NewMessage_Bit0_s[gTpMemoList_Attributes_NewMessage_Bit0[Element_3]]);
            }
            
            //MessageTime_Hour
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Hour_2,gTpMemoList_Hour[Element_3]);

            //MessageTime_Minute
            if (gTpMemoList_recordaddress ==0 || gTpMemoList_recordaddress ==1)
                putvalue(env_ASG_AudioSD_TML_Minute_2,gTpMemoList_Minute[Element_3]);

            //StationName
            if (gTpMemoList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_TML_StName_s_2,gTpMemoList_StationName[Element_3]);    
            }
        }
    }
}

on envVar env_ASG_AudioSD_TML_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gTpMemoList_ListHandlingType ==AUDIO_TPMEMOLIST_NOCACHE)
	{
        gTpMemoList_ASGID            =getvalue(env_ASG_AudioSD_TML_ASGID);
        gTpMemoList_TAID             =getvalue(env_ASG_AudioSD_TML_TAID);

        shift                           =getvalue(env_ASG_AudioSD_TML_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_TML_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_TML_AH_PosTrans);
        recordaddress                   =getvalue(env_ASG_AudioSD_TML_AH_RA);
        indexsize                       =getvalue(env_ASG_AudioSD_TML_AH_IS);
        startelement                    =getvalue(env_ASG_AudioSD_TML_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_TML_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        TpMemoList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on envVar env_ASG_AudioSD_TML_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gTpMemoList_ListHandlingType      =AUDIO_TPMEMOLIST_BUILDUPCACHE;             //build-up complete cache...
            gTpMemoList_cacheBuildUp          =AUDIO_TPMEMOLIST_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            TpMemoList_ListHandling ();
        }
        else
        {
            gTpMemoList_SlidingWindow_State   =AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE;
            gTpMemoList_ListHandlingType      =AUDIO_TPMEMOLIST_NOCACHE;
            gTpMemoList_cacheBuildUp          =AUDIO_TPMEMOLIST_BUILDUPCACHENOCACHE;
            gTpMemoList_CallBackReason        =AUDIO_TPMEMOLIST_CALLBACKREASON_NOCALLBACK;

            gTpMemoList_cacheDown             =FALSE;
            gTpMemoList_cacheUp               =FALSE;
            gTpMemoList_LastFirstElement      =0;

            gTpMemoList_recordaddress         =0;
            gTpMemoList_transmitpos           =1;
            gTpMemoList_CursorAction          =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
            gTpMemoList_DisplayStatus         =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_TPMEMOLIST_ASGCACHE_MAX_SIZE; j++)
            {     
                gTpMemoList_Pos[j]                               =0;
                gTpMemoList_Attributes_NewMessage_Bit0[j]        =0;
                gTpMemoList_Attributes[j]                        =0;
                gTpMemoList_Hour[j]                              =0;
                gTpMemoList_Minute[j]                            =0;
                gTpMemoList_ListEntryReceptionInformation[j]     =0;

                for(i=0;i<AUDIO_TPMEMOLIST_STATIONNAME_LENGTH;i++)
			        gTpMemoList_StationName[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_TML_pos_0, 0);
            putvalue(env_ASG_AudioSD_TML_pos_1, 0);
            putvalue(env_ASG_AudioSD_TML_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_TML_At_bit0_0, 0);
            putvalue(env_ASG_AudioSD_TML_At_bit0_1, 0);
            putvalue(env_ASG_AudioSD_TML_At_bit0_2, 0);
            putvalue(env_ASG_AudioSD_TML_At_s_bit0_0, empty_string);
            putvalue(env_ASG_AudioSD_TML_At_s_bit0_1, empty_string);
            putvalue(env_ASG_AudioSD_TML_At_s_bit0_2, empty_string);

            putvalue(env_ASG_AudioSD_TML_Hour_0, 0);
            putvalue(env_ASG_AudioSD_TML_Hour_1, 0);
            putvalue(env_ASG_AudioSD_TML_Hour_2, 0);

            putvalue(env_ASG_AudioSD_TML_Minute_0, 0);
            putvalue(env_ASG_AudioSD_TML_Minute_1, 0);
            putvalue(env_ASG_AudioSD_TML_Minute_2, 0);
            
            putvalue(env_ASG_AudioSD_TML_StName_s_0, empty_string);
            putvalue(env_ASG_AudioSD_TML_StName_s_1, empty_string);
            putvalue(env_ASG_AudioSD_TML_StName_s_2, empty_string);    
        }
    }
}   

on envVar env_ASG_AudioSD_TML_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gTpMemoList_ListHandlingType ==AUDIO_TPMEMOLIST_NOCACHE)
	{      
        gTpMemoList_CursorAction =AUDIO_TPMEMOLIST_CURSORACTION_DOWN;
        
        if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_ACTIVE)
        {   
            gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_DOWN_CACHE;
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
            
            TpMemoList_ListHandling ();
        }
        else if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_DOWN;

            TpMemoList_display();

            //reset values
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_TML_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gTpMemoList_ListHandlingType ==AUDIO_TPMEMOLIST_NOCACHE)
	{   
        gTpMemoList_CursorAction =AUDIO_TPMEMOLIST_CURSORACTION_UP;

        if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_ACTIVE)
        {  
            gTpMemoList_ListHandlingType  =AUDIO_TPMEMOLIST_UP_CACHE;
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
            
            TpMemoList_ListHandling ();
        }
        else if(gTpMemoList_SlidingWindow_State ==AUDIO_TPMEMOLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_UP;

            TpMemoList_ListHandling();
            
            TpMemoList_display();

            //reset values
            gTpMemoList_DisplayStatus     =AUDIO_TPMEMOLIST_DISPLAYLIST_REFRESH;
            gTpMemoList_CursorAction      =AUDIO_TPMEMOLIST_CURSORACTION_NOTHING;
        }    
    }
}

int MediaBrowser_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gMediaBrowser_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gMediaBrowser_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gMediaBrowser_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int MediaBrowser_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_MEDIABROWSER_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_MEDIABROWSER_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

MediaBrowser_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_MB_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gMediaBrowser_DisplayStatus ==AUDIO_MEDIABROWSER_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gMediaBrowser_CursorAction ==AUDIO_MEDIABROWSER_CURSORACTION_DOWN)
                Element_1 =MediaBrowser_GetNextCachedElement(gMediaBrowser_LastFirstElement, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gMediaBrowser_CursorAction ==AUDIO_MEDIABROWSER_CURSORACTION_UP)            
                Element_1 =MediaBrowser_GetNextCachedElement(gMediaBrowser_LastFirstElement, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_MB_pos_0, gMediaBrowser_Pos[Element_1]);               
            
            //FileType
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FileType_0, gMediaBrowser_FileType[Element_1]);

                if(gMediaBrowser_FileType[Element_1] <0x67)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_0,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_1]]);
                else if (gMediaBrowser_FileType[Element_1] ==0xFF)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_not_supported);
                else
                    putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_reserved);
            }

            //FileState
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FS_bit0_0, gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit1_0, gMediaBrowser_FileState_DRM_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit2_0, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit3_0, gMediaBrowser_FileState_DeadLink_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit4_0, gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit5_0, gMediaBrowser_FileState_ImportPending_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit6_0, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]]);
            }

            //FileName
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                putvalue(env_ASG_AudioSD_MB_FileName_s_0,gMediaBrowser_FileName[Element_1]);
                        
            gMediaBrowser_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =MediaBrowser_GetNextCachedElement(Element_1, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            //Pos
            putvalue(env_ASG_AudioSD_MB_pos_1, gMediaBrowser_Pos[Element_2]);               
            
            //FileType
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FileType_1, gMediaBrowser_FileType[Element_2]);

                if(gMediaBrowser_FileType[Element_2] <0x67)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_1,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_2]]);
                else if (gMediaBrowser_FileType[Element_2] ==0xFF)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_not_supported);
                else
                    putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_reserved);
            }

            //FileState
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FS_bit0_1, gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit1_1, gMediaBrowser_FileState_DRM_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit2_1, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit3_1, gMediaBrowser_FileState_DeadLink_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit4_1, gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit5_1, gMediaBrowser_FileState_ImportPending_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit6_1, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]]);
            }

            //FileName
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                putvalue(env_ASG_AudioSD_MB_FileName_s_1,gMediaBrowser_FileName[Element_2]);
             
            
            //3. Element          
            Element_3 =MediaBrowser_GetNextCachedElement(Element_3, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_MB_pos_2, gMediaBrowser_Pos[Element_3]);               
            
            //FileType
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FileType_2, gMediaBrowser_FileType[Element_3]);

                if(gMediaBrowser_FileType[Element_3] <0x67)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_2,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_3]]);
                else if (gMediaBrowser_FileType[Element_3] ==0xFF)
                    putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_not_supported);
                else
                    putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_reserved);
            }

            //FileState
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_MB_FS_bit0_2, gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit1_2, gMediaBrowser_FileState_DRM_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit2_2, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit3_2, gMediaBrowser_FileState_DeadLink_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit4_2, gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit5_2, gMediaBrowser_FileState_ImportPending_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_MB_FS_bit6_2, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]]);
            }

            //FileName
            if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                putvalue(env_ASG_AudioSD_MB_FileName_s_2,gMediaBrowser_FileName[Element_3]);         
        }

        /******'sliding Window' active or 'build-up List'******/
        else if(gMediaBrowser_DisplayStatus ==AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gMediaBrowser_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_MB_OnOff))
            {   
                Element_1 =0;
                
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_0, gMediaBrowser_Pos[Element_1]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_0, gMediaBrowser_FileType[Element_1]);

                    if(gMediaBrowser_FileType[Element_1] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_1]]);
                    else if (gMediaBrowser_FileType[Element_1] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_not_supported);
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_0, gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_0, gMediaBrowser_FileState_DRM_Bit1[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit2_0, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_0, gMediaBrowser_FileState_DeadLink_Bit3[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_0, gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_0, gMediaBrowser_FileState_ImportPending_Bit5[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_0, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_0,gMediaBrowser_FileName[Element_1]);

            }
            
            //2. Element    
            if(gMediaBrowser_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_MB_OnOff))
            {
                Element_2 =1;
                   
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_1, gMediaBrowser_Pos[Element_2]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_1, gMediaBrowser_FileType[Element_2]);

                    if(gMediaBrowser_FileType[Element_2] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_2]]);
                    
                    else if (gMediaBrowser_FileType[Element_2] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_not_supported);
                    
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_1, gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_1, gMediaBrowser_FileState_DRM_Bit1[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit2_1, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_1, gMediaBrowser_FileState_DeadLink_Bit3[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_1, gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_1, gMediaBrowser_FileState_ImportPending_Bit5[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_1, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_1,gMediaBrowser_FileName[Element_2]);
            }

            //3. Element    
            if(gMediaBrowser_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_MB_OnOff))
            {
                Element_3 =2;
                
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_2, gMediaBrowser_Pos[Element_3]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_2, gMediaBrowser_FileType[Element_3]);

                    if(gMediaBrowser_FileType[Element_3] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_3]]);
                    else if (gMediaBrowser_FileType[Element_3] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_not_supported);
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_2, gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_2, gMediaBrowser_FileState_DRM_Bit1[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit2_2, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_2, gMediaBrowser_FileState_DeadLink_Bit3[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_2, gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_2, gMediaBrowser_FileState_ImportPending_Bit5[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_2, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_2,gMediaBrowser_FileName[Element_3]);     
            }
        }
        
        else if (gMediaBrowser_DisplayStatus ==AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH)
        {               
            //1. Element
            if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gMediaBrowser_LastFirstElement; 
            else
                Element_1 =0;

            if(gMediaBrowser_ListEntryReceptionInformation[Element_1])
            {
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_0, gMediaBrowser_Pos[Element_1]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_0, gMediaBrowser_FileType[Element_1]);

                    if(gMediaBrowser_FileType[Element_1] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_1]]);
                    else if (gMediaBrowser_FileType[Element_1] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_not_supported);
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_0,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_0, gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_0, gMediaBrowser_FileState_DRM_Bit1[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_1]]);
    
                    putvalue(env_ASG_AudioSD_MB_FS_bit2_0, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_0, gMediaBrowser_FileState_DeadLink_Bit3[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_0, gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_0, gMediaBrowser_FileState_ImportPending_Bit5[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_1]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_0, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_1]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_0,gMediaBrowser_FileName[Element_1]);
            }

            //2. Element             
            if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =MediaBrowser_GetNextCachedElement(Element_1, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gMediaBrowser_ListEntryReceptionInformation[Element_2])
            {
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_1, gMediaBrowser_Pos[Element_2]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_1, gMediaBrowser_FileType[Element_2]);

                    if(gMediaBrowser_FileType[Element_2] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_2]]);
                    
                    else if (gMediaBrowser_FileType[Element_2] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_not_supported);
                    
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_1,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_1, gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_1, gMediaBrowser_FileState_DRM_Bit1[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit2_1, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_1, gMediaBrowser_FileState_DeadLink_Bit3[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_1, gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_1, gMediaBrowser_FileState_ImportPending_Bit5[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_2]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_1, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_2]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_1,gMediaBrowser_FileName[Element_2]);
            }

            //3. Element          
            if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =MediaBrowser_GetNextCachedElement(Element_2, AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gMediaBrowser_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
                putvalue(env_ASG_AudioSD_MB_pos_2, gMediaBrowser_Pos[Element_3]);               
            
                //FileType
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FileType_2, gMediaBrowser_FileType[Element_3]);

                    if(gMediaBrowser_FileType[Element_3] <0x67)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gMediaBrowser_FileType_s[gMediaBrowser_FileType[Element_3]]);
                    else if (gMediaBrowser_FileType[Element_3] ==0xFF)
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_not_supported);
                    else
                        putvalue(env_ASG_AudioSD_MB_FileType_s_2,gstring_reserved);
                }

                //FileState
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_MB_FS_bit0_2, gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2,gMediaBrowser_FileState_emptyFolder_Bit0_s[gMediaBrowser_FileState_emptyFolder_Bit0[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit1_2, gMediaBrowser_FileState_DRM_Bit1[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2,gMediaBrowser_FileState_DRM_Bit1_s[gMediaBrowser_FileState_DRM_Bit1[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit2_2, gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2,gMediaBrowser_FileState_FileCorrupted_Bit2_s[gMediaBrowser_FileState_FileCorrupted_Bit2[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit3_2, gMediaBrowser_FileState_DeadLink_Bit3[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2,gMediaBrowser_FileState_DeadLink_Bit3_s[gMediaBrowser_FileState_DeadLink_Bit3[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit4_2, gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2,gMediaBrowser_FileState_ImportFinished_Bit4_s[gMediaBrowser_FileState_ImportFinished_Bit4[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit5_2, gMediaBrowser_FileState_ImportPending_Bit5[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2,gMediaBrowser_FileState_ImportPending_Bit5_s[gMediaBrowser_FileState_ImportPending_Bit5[Element_3]]);

                    putvalue(env_ASG_AudioSD_MB_FS_bit6_2, gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]);
                    putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2,gMediaBrowser_FileState_ImportPlayable_Bit6_s[gMediaBrowser_FileState_ImportPlayable_Bit6[Element_3]]);
                }

                //FileName
                if (gMediaBrowser_recordaddress ==0 || gMediaBrowser_recordaddress ==2)
                    putvalue(env_ASG_AudioSD_MB_FileName_s_2,gMediaBrowser_FileName[Element_3]);
            }
        }
    }
}

MediaBrowser_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_FileType, buffer_ReceptionInformation, buffer_FileState_bit0, buffer_FileState_bit1, buffer_FileState_bit2, buffer_FileState_bit3, buffer_FileState_bit4, buffer_FileState_bit5, buffer_FileState_bit6;
    word requested_startelement, startelement, elements, buffer_Pos, buffer_FileState;
    char buffer_FileName[AUDIO_MEDIABROWSER_FILENAME_LENGTH];
    int i,j,k;
    
    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_FileType             =0;
    buffer_ReceptionInformation =0;
    buffer_FileState            =0;
    buffer_FileState_bit0       =0;
    buffer_FileState_bit1       =0;
    buffer_FileState_bit2       =0;
    buffer_FileState_bit3       =0;
    buffer_FileState_bit4       =0;
    buffer_FileState_bit5       =0;
    buffer_FileState_bit6       =0;
    
    /***build-up complete cache***/

    switch (gMediaBrowser_ListHandlingType)
    {
        case AUDIO_MEDIABROWSER_BUILDUPCACHE:
             
            switch (gMediaBrowser_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_UP:  
                    if(gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE && gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gMediaBrowser_CallBackReason)
                        {
                            case AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE:

                                    if(gMediaBrowser_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gMediaBrowser_cacheBuildUp      =AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        MediaBrowser_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gMediaBrowser_cacheBuildUp      =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_NOCACHE;              
                                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK; 
                                        gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
                                        
                                        putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);
                                        MediaBrowser_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gMediaBrowser_CallBackReason  =AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE;

                        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_WINDOW: 
                    if(gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE && gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gMediaBrowser_CallBackReason)
                        {
                            case AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gMediaBrowser_cacheBuildUp      =AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT;    
                                    
                                    MediaBrowser_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        putvalue(env_ASG_AudioSD_MB_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gMediaBrowser_CallBackReason  =AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE;

                        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_DOWN:
                    if(gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE && gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gMediaBrowser_CallBackReason)
                        {
                            case AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gMediaBrowser_cacheBuildUp      =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_NOCACHE;              
                                    gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;
                                    gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
                                    
                                    gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH;
                                    
                                    putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);
                                    MediaBrowser_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gMediaBrowser_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gMediaBrowser_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE;
                        
                        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_MEDIABROWSER_DOWN_CACHE: 
                    if (gMediaBrowser_CallBackReason ==AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gMediaBrowser_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST; 
                            gMediaBrowser_cacheDown         =TRUE;

                            MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gMediaBrowser_CallBackReason =AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST;
                            MediaBrowser_ListHandling(); 
                        }    
                    }
                    else if (gMediaBrowser_CallBackReason ==AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_NOCACHE;
                        gMediaBrowser_cacheDown         =FALSE;
                        gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);
                        MediaBrowser_display();
                        gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH;
                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        putvalue(env_ASG_AudioSD_MB_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gMediaBrowser_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gMediaBrowser_Pos[i];
                                    buffer_FileType         =gMediaBrowser_FileType[i];
                                    buffer_FileState        =gMediaBrowser_FileState[i];
                                    buffer_FileState_bit0   =gMediaBrowser_FileState_emptyFolder_Bit0[i];
                                    buffer_FileState_bit1   =gMediaBrowser_FileState_DRM_Bit1[i];
                                    buffer_FileState_bit2   =gMediaBrowser_FileState_FileCorrupted_Bit2[i];
                                    buffer_FileState_bit3   =gMediaBrowser_FileState_DeadLink_Bit3[i];
                                    buffer_FileState_bit4   =gMediaBrowser_FileState_ImportFinished_Bit4[i];
                                    buffer_FileState_bit5   =gMediaBrowser_FileState_ImportPending_Bit5[i];
                                    buffer_FileState_bit6   =gMediaBrowser_FileState_ImportPlayable_Bit6[i];

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        buffer_FileName[k] =0;                                     

                                    for(k=0;k<strlen(gMediaBrowser_FileName[i]);k++) 
                                        buffer_FileName[k]=gMediaBrowser_FileName[i][k];
                                    
                                    
                                    //copy data from Pos '1' to Pos '0'
                                    gMediaBrowser_Pos[i]                            =gMediaBrowser_Pos[j]; 
                                    gMediaBrowser_FileType[i]                       =gMediaBrowser_FileType[j];
                                    gMediaBrowser_FileState[i]                      =gMediaBrowser_FileState[j];
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =gMediaBrowser_FileState_emptyFolder_Bit0[j];
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =gMediaBrowser_FileState_DRM_Bit1[j];
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =gMediaBrowser_FileState_FileCorrupted_Bit2[j];
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =gMediaBrowser_FileState_DeadLink_Bit3[j];
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =gMediaBrowser_FileState_ImportFinished_Bit4[j];
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =gMediaBrowser_FileState_ImportPending_Bit5[j];
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =gMediaBrowser_FileState_ImportPlayable_Bit6[j];
                               
                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0;                                     

                                    for(k=0;k<strlen(gMediaBrowser_FileName[j]);k++) 
                                        gMediaBrowser_FileName[i][k]=gMediaBrowser_FileName[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gMediaBrowser_ListEntryReceptionInformation[i]  =0;
                                    gMediaBrowser_Pos[i]                            =0;
                                    gMediaBrowser_FileType[i]                       =0;
                                    gMediaBrowser_FileState[i]                      =0;
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =0;
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =0;
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =0;
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =0;
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =0;
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =0;
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =0;

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gMediaBrowser_Pos[i]                            =buffer_Pos; 
                                    gMediaBrowser_FileType[i]                       =buffer_FileType;
                                    gMediaBrowser_FileState[i]                      =buffer_FileState;
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =buffer_FileState_bit0;
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =buffer_FileState_bit1;
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =buffer_FileState_bit2;
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =buffer_FileState_bit3;
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =buffer_FileState_bit4;
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =buffer_FileState_bit5;
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =buffer_FileState_bit6;

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_FileName);k++) 
                                        gMediaBrowser_FileName[i][k]=buffer_FileName[k];
                                    
                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gMediaBrowser_Pos[i]                            =gMediaBrowser_Pos[j]; 
                                    gMediaBrowser_FileType[i]                       =gMediaBrowser_FileType[j];
                                    gMediaBrowser_FileState[i]                      =gMediaBrowser_FileState[j];
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =gMediaBrowser_FileState_emptyFolder_Bit0[j];
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =gMediaBrowser_FileState_DRM_Bit1[j]; 
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =gMediaBrowser_FileState_FileCorrupted_Bit2[j];
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =gMediaBrowser_FileState_DeadLink_Bit3[j];
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =gMediaBrowser_FileState_ImportFinished_Bit4[j];
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =gMediaBrowser_FileState_ImportPending_Bit5[j];
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =gMediaBrowser_FileState_ImportPlayable_Bit6[j];
                                    
                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gMediaBrowser_FileName[j]);k++) 
                                        gMediaBrowser_FileName[i][k]=gMediaBrowser_FileName[j][k];

                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_MEDIABROWSER_UP_CACHE: 
                    if (gMediaBrowser_CallBackReason ==AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gMediaBrowser_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gMediaBrowser_cacheUp        =TRUE;
                            gMediaBrowser_CallBackReason =AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST;
                            
                            MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gMediaBrowser_CallBackReason =AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST;
                            MediaBrowser_ListHandling();
                        }           
                    }

                    else if (gMediaBrowser_CallBackReason ==AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_NOCACHE;
                        gMediaBrowser_cacheUp           =FALSE;
                        gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        putvalue(env_ASG_AudioSD_MB_ListOpState, empty_string);
                        MediaBrowser_display();
                        gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH;
                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        putvalue(env_ASG_AudioSD_MB_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gMediaBrowser_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gMediaBrowser_Pos[i];
                                    buffer_FileType         =gMediaBrowser_FileType[i];
                                    buffer_FileState        =gMediaBrowser_FileState[i];
                                    buffer_FileState_bit0   =gMediaBrowser_FileState_emptyFolder_Bit0[i];
                                    buffer_FileState_bit1   =gMediaBrowser_FileState_DRM_Bit1[i];
                                    buffer_FileState_bit2   =gMediaBrowser_FileState_FileCorrupted_Bit2[i];
                                    buffer_FileState_bit3   =gMediaBrowser_FileState_DeadLink_Bit3[i];
                                    buffer_FileState_bit4   =gMediaBrowser_FileState_ImportFinished_Bit4[i];
                                    buffer_FileState_bit5   =gMediaBrowser_FileState_ImportPending_Bit5[i];
                                    buffer_FileState_bit6   =gMediaBrowser_FileState_ImportPlayable_Bit6[i];

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        buffer_FileName[k] =0;                                     

                                    for(k=0;k<strlen(gMediaBrowser_FileName[i]);k++) 
                                        buffer_FileName[k]=gMediaBrowser_FileName[i][k];

                                    //copy data from Pos '7' to Pos '8'
                                    gMediaBrowser_Pos[i]                            =gMediaBrowser_Pos[j]; 
                                    gMediaBrowser_FileType[i]                       =gMediaBrowser_FileType[j];
                                    gMediaBrowser_FileState[i]                      =gMediaBrowser_FileState[j];
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =gMediaBrowser_FileState_emptyFolder_Bit0[j];
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =gMediaBrowser_FileState_DRM_Bit1[j];
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =gMediaBrowser_FileState_FileCorrupted_Bit2[j];
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =gMediaBrowser_FileState_DeadLink_Bit3[j];
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =gMediaBrowser_FileState_ImportFinished_Bit4[j];
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =gMediaBrowser_FileState_ImportPending_Bit5[j];
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =gMediaBrowser_FileState_ImportPlayable_Bit6[j];

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gMediaBrowser_FileName[j]);k++) 
                                        gMediaBrowser_FileName[i][k]=gMediaBrowser_FileName[j][k];
                                    
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gMediaBrowser_ListEntryReceptionInformation[i]  =0;
                                    gMediaBrowser_Pos[i]                            =0;
                                    gMediaBrowser_FileType[i]                           =0;
                                    gMediaBrowser_FileState[i]                      =0;
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =0;
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =0;
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =0;
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =0;
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =0;
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =0;
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =0;
                                                                
                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gMediaBrowser_Pos[i]                            =buffer_Pos; 
                                    gMediaBrowser_FileType[i]                       =buffer_FileType;
                                    gMediaBrowser_FileState[i]                      =buffer_FileState;
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =buffer_FileState_bit0;
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =buffer_FileState_bit1;
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =buffer_FileState_bit2;
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =buffer_FileState_bit3;
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =buffer_FileState_bit4;
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =buffer_FileState_bit5;
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =buffer_FileState_bit6;
                                    
                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_FileName);k++) 
                                        gMediaBrowser_FileName[i][k]=buffer_FileName[k];

                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gMediaBrowser_Pos[i]                            =gMediaBrowser_Pos[j]; 
                                    gMediaBrowser_FileType[i]                       =gMediaBrowser_FileType[j];
                                    gMediaBrowser_FileState[i]                      =gMediaBrowser_FileState[j];
                                    gMediaBrowser_FileState_emptyFolder_Bit0[i]     =gMediaBrowser_FileState_emptyFolder_Bit0[j];
                                    gMediaBrowser_FileState_DRM_Bit1[i]             =gMediaBrowser_FileState_DRM_Bit1[j];
                                    gMediaBrowser_FileState_FileCorrupted_Bit2[i]   =gMediaBrowser_FileState_FileCorrupted_Bit2[j];
                                    gMediaBrowser_FileState_DeadLink_Bit3[i]        =gMediaBrowser_FileState_DeadLink_Bit3[j];
                                    gMediaBrowser_FileState_ImportFinished_Bit4[i]  =gMediaBrowser_FileState_ImportFinished_Bit4[j];
                                    gMediaBrowser_FileState_ImportPending_Bit5[i]   =gMediaBrowser_FileState_ImportPending_Bit5[j];
                                    gMediaBrowser_FileState_ImportPlayable_Bit6[i]  =gMediaBrowser_FileState_ImportPlayable_Bit6[j];

                                    for (k=0; k<AUDIO_MEDIABROWSER_FILENAME_LENGTH;k++) //clear string
                                        gMediaBrowser_FileName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gMediaBrowser_FileName[j]);k++) 
                                        gMediaBrowser_FileName[i][k]=gMediaBrowser_FileName[j][k];
                                    
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gMediaBrowser_CallBackReason    =AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

on envVar env_ASG_AudioSD_MB_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gMediaBrowser_ListHandlingType ==AUDIO_MEDIABROWSER_NOCACHE)
	{
        gMediaBrowser_ASGID            =getvalue(env_ASG_AudioSD_MB_ASGID);
        gMediaBrowser_TAID             =getvalue(env_ASG_AudioSD_MB_TAID);
        gMediaBrowser_ActiveListPos    =getvalue(env_ASG_AudioSD_MB_ActiveListPos);

        shift                           =getvalue(env_ASG_AudioSD_MB_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_MB_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_MB_AH_PosTrans);
        indexsize                       =getvalue(env_ASG_AudioSD_MB_AH_IS);
        recordaddress                   =getvalue(env_ASG_AudioSD_MB_AH_RA);
        startelement                    =getvalue(env_ASG_AudioSD_MB_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_MB_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        MediaBrowser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on envVar env_ASG_AudioSD_MB_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gMediaBrowser_ListHandlingType      =AUDIO_MEDIABROWSER_BUILDUPCACHE;             //build-up complete cache...
            gMediaBrowser_cacheBuildUp          =AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            MediaBrowser_ListHandling ();
        }
        else
        {
            gMediaBrowser_SlidingWindow_State   =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
            gMediaBrowser_ListHandlingType      =AUDIO_MEDIABROWSER_NOCACHE;
            gMediaBrowser_cacheBuildUp          =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;
            gMediaBrowser_CallBackReason        =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;

            gMediaBrowser_cacheDown             =FALSE;
            gMediaBrowser_cacheUp               =FALSE;
            gMediaBrowser_LastFirstElement      =0;

            gMediaBrowser_recordaddress         =0;
            gMediaBrowser_transmitpos           =1;
            gMediaBrowser_CursorAction          =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
            gMediaBrowser_DisplayStatus         =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; j++)
            {     
                gMediaBrowser_Pos[j]                            =0;
                gMediaBrowser_FileType[j]                       =0;
                gMediaBrowser_FileState_emptyFolder_Bit0[j]     =0;
                gMediaBrowser_FileState_DRM_Bit1[j]             =0;
                gMediaBrowser_FileState_FileCorrupted_Bit2[j]   =0;
                gMediaBrowser_FileState_DeadLink_Bit3[j]        =0;
                gMediaBrowser_FileState_ImportFinished_Bit4[j]  =0;
                gMediaBrowser_FileState_ImportPending_Bit5[j]   =0;
                gMediaBrowser_FileState_ImportPlayable_Bit6[j]  =0;
                gMediaBrowser_FileState[j]                      =0;
                gMediaBrowser_ListEntryReceptionInformation[j]  =0;

                for(i=0;i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++)
			        gMediaBrowser_FileName[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_MB_pos_0, 0);
            putvalue(env_ASG_AudioSD_MB_pos_1, 0);
            putvalue(env_ASG_AudioSD_MB_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_MB_FileType_0, 0);
            putvalue(env_ASG_AudioSD_MB_FileType_1, 0);
            putvalue(env_ASG_AudioSD_MB_FileType_2, 0);

            putvalue(env_ASG_AudioSD_MB_FileType_s_0,empty_string);
            putvalue(env_ASG_AudioSD_MB_FileType_s_1,empty_string);
            putvalue(env_ASG_AudioSD_MB_FileType_s_2,empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit0_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit0_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit0_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit0_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit0_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit0_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit1_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit1_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit1_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit1_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit1_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit1_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit2_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit2_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit2_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit2_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit2_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit2_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit3_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit3_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit3_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit3_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit3_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit3_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit4_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit4_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit4_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit4_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit4_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit4_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit5_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit5_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit5_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit5_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit5_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit5_2, empty_string);

            putvalue(env_ASG_AudioSD_MB_FS_bit6_0, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit6_1, 0);
            putvalue(env_ASG_AudioSD_MB_FS_bit6_2, 0);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit6_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit6_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FS_s_bit6_2, empty_string);
           
            putvalue(env_ASG_AudioSD_MB_FileName_s_0, empty_string);
            putvalue(env_ASG_AudioSD_MB_FileName_s_1, empty_string);
            putvalue(env_ASG_AudioSD_MB_FileName_s_2, empty_string);
            
        }
    }
}   

on envVar env_ASG_AudioSD_MB_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gMediaBrowser_ListHandlingType ==AUDIO_MEDIABROWSER_NOCACHE)
	{      
        gMediaBrowser_CursorAction =AUDIO_MEDIABROWSER_CURSORACTION_DOWN;
        
        if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE)
        {   
            gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_DOWN_CACHE;
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
            
            MediaBrowser_ListHandling ();
        }
        else if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE)
        {
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_SEARCH_ELEMENTS;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_DOWN;

            MediaBrowser_display();

            //reset values
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_MB_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gMediaBrowser_ListHandlingType ==AUDIO_MEDIABROWSER_NOCACHE)
	{   
        gMediaBrowser_CursorAction =AUDIO_MEDIABROWSER_CURSORACTION_UP;

        if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE)
        {  
            gMediaBrowser_ListHandlingType  =AUDIO_MEDIABROWSER_UP_CACHE;
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
            
            MediaBrowser_ListHandling ();
        }
        else if(gMediaBrowser_SlidingWindow_State ==AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE)
        {
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_SEARCH_ELEMENTS;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_UP;

            MediaBrowser_ListHandling();
            
            MediaBrowser_display();

            //reset values
            gMediaBrowser_DisplayStatus     =AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH;
            gMediaBrowser_CursorAction      =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
        }    
    }
}

on timer ASGCapa_startTimer
{
    ASGCapabilities_Request(DataSetGet_REQ);
}

on envVar env_ASG_AudioSD_FSGSetup_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        FSG_Setup_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_SDSState_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        SDSState_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_InfoSt_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        InfoStates_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_ASGCap_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        ASGCapabilities_Request(DataGet_REQ);
    
}

on envVar env_ASG_AudioSD_CSI_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        CurrentStationInfo_Request(DataGet_REQ);   
}

on envVar env_ASG_AudioSD_CSH_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        CurrentStationHandle_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_AS_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        activeSource_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_SrcSt_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        SourceState_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_ASName_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        activeSourceName_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_CurrVol_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        currentVolume_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_Mute_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        Mute_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_GIS_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        GeneralInfoSwitches_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_TPMemInfo_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        TPMemoInfo_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_PrefList_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        PreferredList_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_RecListTy_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        ReceptionListType_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_MePath_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        MediaPath_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_MeBrLevel_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        MediaBrowserFolderLevel_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_AnInf_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        AnnouncementInfo_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_FSGOpState_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        FSG_OperationState_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_FctSyn_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        FunctionSynchronisation_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_FctList_get
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
        FunctionList_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_open_Prop_5
{

    openPanel("ASG_Property_DF41"); 


}

on sysvar sysvar::ASG_AudioSD::MeImSe_InID
{
}

on sysvar sysvar::ASG_AudioSD::MeImSe_ST
{
    if(@sysvar::ASG_AudioSD::MeImSe_ST <0x24 || !temp3)
       gMIS_STact = @sysvar::ASG_AudioSD::MeImSe_ST;
    if(@sysvar::ASG_AudioSD::MeImSe_ST ==255 || !temp3)
       gMIS_STact = @sysvar::ASG_AudioSD::MeImSe_ST;
       temp3 =0;
    if(@sysvar::ASG_AudioSD::MeImSe_SThex != gMIS_STact)
        @sysvar::ASG_AudioSD::MeImSe_SThex =@sysvar::ASG_AudioSD::MeImSe_ST;

}

on sysvar sysvar::ASG_AudioSD::MeImSe_State0
{
    if(@sysvar::ASG_AudioSD::MeImSe_State0 == 1)
        @sysvar::ASG_AudioSD::MeImSe_State1 == 0;
}

on sysvar sysvar::ASG_AudioSD::MeImSe_State1
{
    if(@sysvar::ASG_AudioSD::MeImSe_State1 == 1)
        @sysvar::ASG_AudioSD::MeImSe_State0 == 0;
}

on sysvar sysvar::ASG_AudioSD::MeImSe_Get
{
}

on sysvar sysvar::ASG_AudioSD::MeImSe_SThex
{

    if(@sysvar::ASG_AudioSD::MeImSe_SThex >0x24 && @sysvar::ASG_AudioSD::MeImSe_SThex != 255)
       {
        gMIS_STact =@sysvar::ASG_AudioSD::MeImSe_SThex;
        temp3 =1;
        @sysvar::ASG_AudioSD::MeImSe_ST = @sysvar::ASG_AudioSD::MeImSe_SThex;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::MeImSe_SThex != gMIS_STact)
            @sysvar::ASG_AudioSD::MeImSe_ST =@sysvar::ASG_AudioSD::MeImSe_SThex;
       }
}

on sysvar sysvar::ASG_AudioSD::CuDoSt_Get
{
}

on sysvar sysvar::ASG_AudioSD::CuStHa2_Get
{
}

on sysvar sysvar::ASG_AudioSD::CuVoEx_Get
{
}

on sysvar sysvar::ASG_AudioSD::OnMuSt_Get
{
}

on sysvar sysvar::ASG_AudioSD::CuVoEx_CVT
{
    if(@sysvar::ASG_AudioSD::CuVoEx_CVT <0x0D || !temp1)
       gCVE_CVTact = @sysvar::ASG_AudioSD::CuVoEx_CVT;
    if(@sysvar::ASG_AudioSD::CuVoEx_CVT ==0x10 || !temp1 || @sysvar::ASG_AudioSD::CuVoEx_CVT ==0x11)
       gCVE_CVTact = @sysvar::ASG_AudioSD::CuVoEx_CVT;
       temp1 =0;
    if(@sysvar::ASG_AudioSD::CuVoEx_CVThex != gCVE_CVTact)
        @sysvar::ASG_AudioSD::CuVoEx_CVThex =@sysvar::ASG_AudioSD::CuVoEx_CVT;
}

on sysvar sysvar::ASG_AudioSD::CuVoEx_CVThex
{
    if(@sysvar::ASG_AudioSD::CuVoEx_CVThex >0x0D && @sysvar::ASG_AudioSD::CuVoEx_CVThex != 0x10 && @sysvar::ASG_AudioSD::CuVoEx_CVThex != 0x11)
       {
        gCVE_CVTact =@sysvar::ASG_AudioSD::CuVoEx_CVThex;
        temp1 =1;
        @sysvar::ASG_AudioSD::CuVoEx_CVT = @sysvar::ASG_AudioSD::CuVoEx_CVThex;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::CuVoEx_CVThex != gCVE_CVTact)
            @sysvar::ASG_AudioSD::CuVoEx_CVT =@sysvar::ASG_AudioSD::CuVoEx_CVThex;
       }
}

on sysvar sysvar::ASG_AudioSD::CuVoEx_VolS0
{
    if(@sysvar::ASG_AudioSD::CuVoEx_VolS0==1)
        @sysvar::ASG_AudioSD::CuVoEx_VolS1 = 0;
}

on sysvar sysvar::ASG_AudioSD::CuVoEx_VolS1
{
    if(@sysvar::ASG_AudioSD::CuVoEx_VolS1==1)
        @sysvar::ASG_AudioSD::CuVoEx_VolS0 = 0;

}

on sysvar sysvar::ASG_AudioSD::CuDoSt_CuDoSt
{
    if(@sysvar::ASG_AudioSD::CuDoSt_CuDoSt <4 || !temp2)
       gCDS_CDSact = @sysvar::ASG_AudioSD::CuDoSt_CuDoSt;
    temp2 =0;
    if(@sysvar::ASG_AudioSD::CuDoSt_CuDoSthex != gCDS_CDSact)
        @sysvar::ASG_AudioSD::CuDoSt_CuDoSthex =@sysvar::ASG_AudioSD::CuDoSt_CuDoSt;
}

on sysvar sysvar::ASG_AudioSD::CuDoSt_CuDoSthex
{
    if(@sysvar::ASG_AudioSD::CuDoSt_CuDoSthex >3)
       {
        gCDS_CDSact =@sysvar::ASG_AudioSD::CuDoSt_CuDoSthex;
        temp2 =1;
        @sysvar::ASG_AudioSD::CuDoSt_CuDoSt = @sysvar::ASG_AudioSD::CuDoSt_CuDoSthex;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::CuDoSt_CuDoSthex != gCDS_CDSact)
            @sysvar::ASG_AudioSD::CuDoSt_CuDoSt =@sysvar::ASG_AudioSD::CuDoSt_CuDoSthex;
       }
}

on sysvar sysvar::ASG_AudioSD::OnMuSt_State
{
    if(@sysvar::ASG_AudioSD::OnMuSt_State <0x25 || !temp4)
       gOMS_Sact = @sysvar::ASG_AudioSD::OnMuSt_State;
    temp4 =0;
    if(@sysvar::ASG_AudioSD::OnMuSt_Statehex != gOMS_Sact)
        @sysvar::ASG_AudioSD::OnMuSt_Statehex =@sysvar::ASG_AudioSD::OnMuSt_State;
}

on sysvar sysvar::ASG_AudioSD::OnMuSt_Statehex
{
    if(@sysvar::ASG_AudioSD::OnMuSt_Statehex >0x24)
       {
        gOMS_Sact =@sysvar::ASG_AudioSD::OnMuSt_Statehex;
        temp4 =1;
        @sysvar::ASG_AudioSD::OnMuSt_State = @sysvar::ASG_AudioSD::OnMuSt_Statehex;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::OnMuSt_Statehex != gOMS_Sact)
            @sysvar::ASG_AudioSD::OnMuSt_State =@sysvar::ASG_AudioSD::OnMuSt_Statehex;
       }
}

MediaImportState_Indication (dword Indication_array [], int datalength)
{

		switch (gBAP_Indication[2])
		{
			case Data_IND:
          @sysvar::ASG_AudioSD::MeImSe_State0 = 0;
          @sysvar::ASG_AudioSD::MeImSe_State1 = 0;
          //get data
	        @sysvar::ASG_AudioSD::MeImSe_SThex  = Indication_array[3];
          @sysvar::ASG_AudioSD::MeImSe_InID   = Indication_array[4];
          @sysvar::ASG_AudioSD::MeImSe_State1 = Indication_array[5];         
          if( Indication_array[5] == 0)
          {
              @sysvar::ASG_AudioSD::MeImSe_State0 = 1;
          }
          @sysvar::ASG_AudioSD::MeImSe_Progress = Indication_array[6];      
      break;
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaImportState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaImportState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaImportState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD MediaImportState_Indication: Application-Error: 0x%x", Indication_array[3]);	
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD MediaImportState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

MediaImportState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_MediaImportState;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD MediaImportState_Request: invalid request %d", request);
		break;
	}
}

CurrentVolumeExtended_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
                
                //get data
				@sysvar::ASG_AudioSD::CuVoEx_CVThex =Indication_array[3];
                @sysvar::ASG_AudioSD::CuVoEx_VolS1  =Indication_array[4];         
                if(Indication_array[4] == 0)
                    @sysvar::ASG_AudioSD::CuVoEx_VolS0 = 1;
                @sysvar::ASG_AudioSD::CuVoEx_MaxVol =Indication_array[5];
                @sysvar::ASG_AudioSD::CuVoEx_GenVol =Indication_array[6];



            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentVolumeExtended_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentVolumeExtended_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentVolumeExtended_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentVolumeExtended_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentVolumeExtended_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

CurrentVolumeExtended_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentVolumeExtended;	    //Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentVolumeExtended_Request: invalid request %d", request);
		break;
	}
}

CustomerDownloadState_Indication (dword Indication_array [], int datalength)
{

		switch (gBAP_Indication[2])
		{
			case Data_IND:
          //get data
	        @sysvar::ASG_AudioSD::CuDoSt_CuDoSthex  = Indication_array[3];
          @sysvar::ASG_AudioSD::CuDoSt_PCD        = Indication_array[4];
      break;

      case Error_IND:	
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CustomerDownloadState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CustomerDownloadState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CustomerDownloadState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CustomerDownloadState_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CustomerDownloadState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

OnlineMusic_State_Indication (dword Indication_array [], int datalength)
{

		switch (gBAP_Indication[2])
		{
			case Data_IND:

                //get data
				@sysvar::ASG_AudioSD::OnMuSt_Statehex  = Indication_array[3];
                @sysvar::ASG_AudioSD::OnMuSt_BuLvl   = Indication_array[4];

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD OnlineMusic_State_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD OnlineMusic_State_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD OnlineMusic_State_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD OnlineMusic_State_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD OnlineMusic_State_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

CommonList_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    Offset                  =0;
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;

    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gCommonList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gCommonList_TAID  =Indication_array[3] &0x0F;
                
                gCommonList_TotalNumListElements =Indication_array[4];
                gCommonList_TotalNumListElements +=(Indication_array[5] *0x100);
                              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gCommonList_Pos[i])  
                            i =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> SourceType, Attributes, PresetID, Category, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                
                                  
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends

                     case 1: //recordaddress =1 -> SourceType, Attributes, PresetID, Category, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);

                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =1 ends

                     case 2: //recordaddress =2 -> Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    

                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =2 ends

                     case 3: //recordaddress =3 -> Attributes, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                

                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =3 ends

                     case 15: //recordaddress =15 -> Pos
 
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_Pos  (CacheElements, current_element, Offset, Indication_array);


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    

                                    Offset= CommonList_IndicationCopyElement_Pos  (CacheElements, current_element, Offset, Indication_array);
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =15 ends
                    
                }
                                   
                //Panel
                @sysvar::ASG_AudioSD::ComList_ASG_ID = gCommonList_ASGID;
                @sysvar::ASG_AudioSD::ComList_TAID = gCommonList_TAID;
                @sysvar::ASG_AudioSD::ComList_TNLE = gCommonList_TotalNumListElements;
             //   @sysvar::naviSD_ASG::POI_List_RecordAdd =recordaddress;
             //   @sysvar::naviSD_ASG::POI_List_transmitPos_APNT =transmitpos;             
			break;



//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------



            case Changed_IND:
                //get data      
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }  

                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==0xFFFF) //check 'full range update'?
                {
                sysSetVariableString(sysvar::ASG_AudioSD::ComList_FRUreseved,"FRU reseved");
                
                }
                else if (datalength>8)
                {
                    if(startelement !=0)
                {
                    for (i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gCommonList_Pos[i])  
                            i =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }

                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                

                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends

                     case 1: //recordaddress =1 -> SourceType, Attributes, PresetID, Category, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }

                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_SourceType (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_PresetID   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Category   (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);

                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =1 ends

                     case 2: //recordaddress =2 -> Distance, Unit
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);


                                    if(CacheElements ==TRUE)                                  
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_Name       (CacheElements, current_element, Offset, Indication_array);
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =2 ends

                     case 3: //recordaddress =3 -> Attributes, Frequency
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                

                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_Attributes (CacheElements, current_element, Offset, Indication_array);
                                    Offset= CommonList_IndicationCopyElement_Frequency  (CacheElements, current_element, Offset, Indication_array);                                                                                                                                                
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =3 ends

                     case 15: //recordaddress =15 -> Pos
 
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gCommonList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gCommonList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gCommonList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gCommonList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gCommonList_Pos[i] && gCommonList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gCommonList_ListHandlingType !=AUDIO_COMMONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }


                                    Offset= CommonList_IndicationCopyElement_Pos  (CacheElements, current_element, Offset, Indication_array);


                                    if(CacheElements ==TRUE)                                    
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gCommonList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =CommonList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_COMMONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element alredy exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gCommonList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gCommonList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gCommonList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    Offset= CommonList_IndicationCopyElement_Pos  (CacheElements, current_element, Offset, Indication_array); 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gCommonList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =CommonList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break;         //recordaddress =15 ends
                    
                }
                }
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CommonList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CommonList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CommonList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CommonList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CommonList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept" TODO: noch zu implementieren "sliding window für ASG"
 /*   if(gPOIList_TotalNumListElements<=NAV_POILIST_ASGCACHE_MAX_SIZE)
        gPOIList_SlidingWindow_State =NAV_POILIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gPOIList_SlidingWindow_State =NAV_POILIST_SLIDINGWINDOW_ACTIVE;

    if (gPOIList_CallBackReason !=NAV_POILIST_CALLBACKREASON_NOCALLBACK)
        POIList_ListHandling ();
    else
        POIList_display();
*/}

CurrentStation_Handle2_Indication (dword Indication_array [], int datalength)
{

		switch (gBAP_Indication[2])
		{
			case Data_IND:

                //get data
        				@sysvar::ASG_AudioSD::CuStHa2_CoListhex  = Indication_array[3];
        				@sysvar::ASG_AudioSD::CuStHa2_CoListhex  += Indication_array[4] *0x100;
                @sysvar::ASG_AudioSD::CuStHa2_CoListAbPohex   = Indication_array[5];
                @sysvar::ASG_AudioSD::CuStHa2_CoListAbPohex   += Indication_array[6] *0x100;
                @sysvar::ASG_AudioSD::CuStHa2_LSListhex = Indication_array[7];
                @sysvar::ASG_AudioSD::CuStHa2_LSListAbPohex = Indication_array[8];

            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle2_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle2_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle2_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle2_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStation_Handle2_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
}

CustomerDownloadState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CustomerDownloadState;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CustomerDownloadState_Request: invalid request %d", request);
		break;
	}
}

OnlineMusic_State_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_OnlineMusic_State;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD OnlineMusic_State_Request: invalid request %d", request);
		break;
	}
}

CurrentStation_Handle2_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentStation_Handle2;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
    switch(request)
	{
		case DataGet_REQ:
		
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle2_Request: invalid request %d", request);
		break;
	}
}

on sysvar sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe
{
    if(@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe <5 || !tempSwRaMe2)
       gSwRaMe_SwRaMeReAct = @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe;
    tempSwRaMe2 =0;
    if(@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex != gSwRaMe_SwRaMeReAct)
        @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex =@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe;
}

on sysvar sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex
{
    if(@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex >5)
       {
        gSwRaMe_SwRaMeReAct =@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex;
        tempSwRaMe2 =1;
        @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe =6;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex != gSwRaMe_SwRaMeReAct)
            @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRe =@sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex;
       }

}

on sysvar sysvar::ASG_AudioSD::SwRaMe_Source
{
    if(@sysvar::ASG_AudioSD::SwRaMe_Source <6 || !tempSwRaMe1)
       gSwRaMe_SourceAct = @sysvar::ASG_AudioSD::SwRaMe_Source;
    tempSwRaMe1 =0;
    if(@sysvar::ASG_AudioSD::SwRaMe_Sourcehex != gSwRaMe_SourceAct)
        @sysvar::ASG_AudioSD::SwRaMe_Sourcehex =@sysvar::ASG_AudioSD::SwRaMe_Source;
}

on sysvar sysvar::ASG_AudioSD::SwRaMe_Sourcehex
{
    if(@sysvar::ASG_AudioSD::SwRaMe_Sourcehex >6)
       {
        gSwRaMe_SourceAct =@sysvar::ASG_AudioSD::SwRaMe_Sourcehex;
        tempSwRaMe1 =1;
        @sysvar::ASG_AudioSD::SwRaMe_Source =7;
       }
       else
       {
        if(@sysvar::ASG_AudioSD::SwRaMe_Sourcehex != gSwRaMe_SourceAct)
            @sysvar::ASG_AudioSD::SwRaMe_Source =@sysvar::ASG_AudioSD::SwRaMe_Sourcehex;
       }

}

on sysvar sysvar::ASG_AudioSD::SwRaMe_Abort
{
    if(@sysvar::ASG_AudioSD::SwRaMe_Abort)
        SwitchRadioMedia_Request(AbortResult_REQ);
}

on sysvar sysvar::ASG_AudioSD::SwRaMe_StartResult
{
    if(@sysvar::ASG_AudioSD::SwRaMe_StartResult)
        SwitchRadioMedia_Request(StartResult_REQ);
}

SwitchRadioMedia_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
                @sysvar::ASG_AudioSD::SwRaMe_SwRaMeRehex = Indication_array[3];            
		break;
		case Error_IND:
				
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchRadioMedia_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchRadioMedia_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchRadioMedia_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
				{	
                    writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchRadioMedia_Indication: Application-Error: 0x%x", Indication_array[3]);

                }
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SwitchRadioMedia_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

SwitchRadioMedia_Request (byte request)
{
    int i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init lokal variables
	for(i=0;i<BAP_BUFFER_SIZE;i++)
		requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_SwitchRadioMedia; //Fct.-ID
	requestarray[2] =request;

	switch(request)
	{
		case StartResult_REQ:
        			
		    requestarray[3] = @sysvar::ASG_AudioSD::SwRaMe_Sourcehex;					
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
		break;          
               
        case AbortResult_REQ:

			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default://error
			writelineEx(gError_Trace, 0,"ASG-AudioSD SwitchRadioMedia_Request: unknown request %d", request);
		break;
	}
}

on envVar env_ASG_AudioSD_Method2
{
if(getvalue(this))
    openPanel("Method_2_AudioSD_ASG");


}

CommonList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_CommonList;	//Fct.-ID
	requestarray[2] =request;           //request type

    switch(request)
	{
        case DataGet_REQ:              
                requestarray[3] =((gCommonList_ASGID *0x10) &0xF0) +(gCommonList_TAID &0x0F);
 
                
                /***ArrayHeader***/
			    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                    //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                    //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            sysSetVariableString(sysvar::ASG_AudioSD::ComList_FRUreseved," ");
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CommonList_Request: invalid request %d", request);
		break;
    }
}

on envVar env_ASG_AudioSD_CommomList
{
if(getvalue(this))
    openPanel("CommonList_ASG");
}

on sysvar sysvar::ASG_AudioSD::ComList_direction_b
{
    if (@sysvar::ASG_AudioSD::ComList_direction_b)
        @sysvar::ASG_AudioSD::ComList_direction_f =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_direction_f
{
    if (@sysvar::ASG_AudioSD::ComList_direction_f)
        @sysvar::ASG_AudioSD::ComList_direction_b =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && @sysvar::ASG_AudioSD::ComList_GetArray && gCommonList_ListHandlingType ==AUDIO_COMMONLIST_NOCACHE)
	{
        gCommonList_ASGID               =@sysvar::ASG_AudioSD::ComList_ASG_ID;
        gCommonList_TAID                =@sysvar::ASG_AudioSD::ComList_TAID;
        shift                           =@sysvar::ASG_AudioSD::ComList_shift_1;
        direction                       =@sysvar::ASG_AudioSD::ComList_direction_b;
        transmitpos                     =@sysvar::ASG_AudioSD::ComList_transmitPos_1;
        indexsize                       =@sysvar::ASG_AudioSD::ComList_indexSize_16bit;
        recordaddress                   =@sysvar::ASG_AudioSD::ComList_recordaddress;
        startelement                    =@sysvar::ASG_AudioSD::ComList_start;
        elements                        =@sysvar::ASG_AudioSD::ComList_elements;
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        //writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
        CommonList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on sysvar sysvar::ASG_AudioSD::ComList_indexSize_8bit
{
    if (@sysvar::ASG_AudioSD::ComList_indexSize_8bit)
        @sysvar::ASG_AudioSD::ComList_indexSize_16bit =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_indexSize_16bit
{
    if (@sysvar::ASG_AudioSD::ComList_indexSize_16bit)
        @sysvar::ASG_AudioSD::ComList_indexSize_8bit =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_shift_0
{
    if (@sysvar::ASG_AudioSD::ComList_shift_0)
        @sysvar::ASG_AudioSD::ComList_shift_1 =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_shift_1
{
    if (@sysvar::ASG_AudioSD::ComList_shift_1)
        @sysvar::ASG_AudioSD::ComList_shift_0 =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_transmitPos_0
{
    if (@sysvar::ASG_AudioSD::ComList_transmitPos_0)
        @sysvar::ASG_AudioSD::ComList_transmitPos_1 =0;
}

on sysvar sysvar::ASG_AudioSD::ComList_transmitPos_1
{
    if (@sysvar::ASG_AudioSD::ComList_transmitPos_1)
        @sysvar::ASG_AudioSD::ComList_transmitPos_0 =0;
}

int CommonListGetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_COMMONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_COMMONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gCommonList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gCommonList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gCommonList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int CommonList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;
    
    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_COMMONLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_COMMONLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_COMMONLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }

    return(nextElement);
}

word CommonList_IndicationCopyElement_SourceType (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
    //Direction Symbolic
    if(CacheElements ==TRUE)
      gCommonList_SourceType[current_element] =Indication_array[Offset];
      Offset++;
    return Offset;
}

word CommonList_IndicationCopyElement_Attributes (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
    //Attributes
    if(CacheElements ==TRUE)
      {
        gCommonList_Attributes[current_element] =Indication_array[Offset];
        Offset++;
        gCommonList_Attributes[current_element] +=Indication_array[Offset]*0x100;
        Offset++;
      }
    return Offset;
}      

word CommonList_IndicationCopyElement_PresetID (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
    //Direction Symbolic
    if(CacheElements ==TRUE)
      gCommonList_PresetID[current_element] =Indication_array[Offset];
      Offset++;
    return Offset;
}

word CommonList_IndicationCopyElement_Category (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
    //Direction Symbolic
    if(CacheElements ==TRUE)
      gCommonList_Category[current_element] =Indication_array[Offset];
      Offset++;
    return Offset;
}

word CommonList_IndicationCopyElement_Name  (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
byte length;
int i;
  //City
    if(CacheElements ==TRUE)
    {
        for(i=0; i<AUDIO_ASG_COMMONLIST_NAME_LENGTH;i++) //clear
	        gCommonList_ASG_Name[current_element][i] =0; 
    }
    length =Indication_array[Offset];
    Offset++;
    for(i=0; i<length;i++) //copy data
    {   
        if(CacheElements ==TRUE)
            gCommonList_ASG_Name[current_element][i] =Indication_array[Offset];
        Offset++;
    }

    return Offset;
}

word CommonList_IndicationCopyElement_Frequency  (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{
byte length;
int i;
  //City
    if(CacheElements ==TRUE)
    {
        for(i=0; i<AUDIO_ASG_COMMONLIST_FREQUENCY_LENGTH;i++) //clear
	        gCommonList_ASG_Frequency[current_element][i] =0; 
    }
    length =Indication_array[Offset];
    Offset++;
    for(i=0; i<length;i++) //copy data
    {   
        if(CacheElements ==TRUE)
            gCommonList_ASG_Frequency[current_element][i] =Indication_array[Offset];
        Offset++;
    }

    return Offset;
}

word CommonList_IndicationCopyElement_Pos (byte CacheElements, byte current_element, word Offset, dword Indication_array[])
{

    //Pos
    if(CacheElements ==TRUE)
      gCommonList_Pos[current_element] =Indication_array[Offset];
      Offset++;
    return Offset;
}

on message BAP_only_MQB_MLBevo_v119::BAP_Audio_FSG_01
{
    int i, error;
    byte RX_Data[8];		//received CAN-DATA
    dword RX_Header[3];		//received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
	
	// extract CAN data    																	
	for (i=0; i<this.DLC; i++) 														
	    RX_Data[i]=this.byte(i);		  
	        
	//send recieved CAN-data with CAN-header to BAP-DLL
	error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
	if(error !=0)
	    write("ASG-AudioSD: BAP_CAN_SetRxData: %d", error);   

}

on message BAP_Audio_FSG_02
{
    int i, error;
    byte RX_Data[8];		//received CAN-DATA
    dword RX_Header[3];		//received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
	
	// extract CAN data    																	
	for (i=0; i<this.DLC; i++) 														
	    RX_Data[i]=this.byte(i);		  
	        
	//send recieved CAN-data with CAN-header to BAP-DLL
	error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
	if(error !=0)
	    write("ASG-AudioSD: BAP_CAN_SetRxData: %d", error);  
        
}

on envVar env_ASG_AudioSD_SDSState_setGet
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
        gSDS_State_state =getvalue(env_ASG_AudioSD_SDSState_State);

        SDSState_Request(DataSetGet_REQ);
    }
}

on envVar env_ASG_AudioSD_PrefList_setGet
{
    if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
        PreferredList_Request(DataSetGet_REQ);
    }
}

void SiriusAlertList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;
    word indexsize;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;
    
    indexsize   =0;
    Offset      =0;

    // decode "mode-byte"
    indexsize   =(mode &0x08)/0x08; 

    // Handle request.
    requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_SiriusAlertList;	//Fct.-ID
	requestarray[2] =request;               //request type

    switch(request)
	{
        case DataGet_REQ:              
                requestarray[3] =((gSiriusAlertList_ASGID *0x10) &0xF0) +(gSiriusAlertList_TAID &0x0F);
                
                /***ArrayHeader***/
			          requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
                Offset =5;

                if(indexsize)
                {
                    requestarray[Offset] =requested_startelement &0x00FF;
                    Offset++;
                    requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
                    Offset++;  

                    requestarray[Offset] =elements &0x00FF;
                    Offset++;
                    requestarray[Offset] =(elements &0xFF00) /0x100;
                    Offset++;       
                }
                else
                {
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
         break;

        default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Request: invalid request %d", request);
		break;
    }
}

void SiriusAlertList_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;
    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gSiriusAlertList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gSiriusAlertList_TAID  =Indication_array[3] &0x0F;           

                gSiriusAlertList_TotalNumListElements =Indication_array[4];
                gSiriusAlertList_TotalNumListElements +=(Indication_array[5] *0x100);
              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSiriusAlertList_Pos[i])  
                            i =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Extension
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++) //clear
			                                gSiriusAlertList_Extension[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Extension[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Extension
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++) //clear
			                                gSiriusAlertList_Extension[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Extension[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Attributes, PresetID, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Attributes, PresetID, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Attributes, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends
                        
                    case 5: //recordaddress =5 -> Attributes, PresetID, Name, Frequency, AlertType, AlertName

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends                    
                        
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_SAL_ASGID, gSiriusAlertList_ASGID);
                putvalue(env_ASG_AudioSD_SAL_TAID, gSiriusAlertList_TAID);
                putvalue(env_ASG_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements);

                gSiriusAlertList_recordaddress =recordaddress;
                gSiriusAlertList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:            
              
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_SAL_OnOff, FALSE);
                    //putvalue(env_ASG_AudioSD_SAL_ListOpState, "'full range update' received");
                }
                else if (datalength>11)
                {
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSiriusAlertList_Pos[i])  
                            i =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Extension
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++) //clear
			                                gSiriusAlertList_Extension[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Extension[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Extension
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++) //clear
			                                gSiriusAlertList_Extension[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Extension[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Attributes, PresetID, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Attributes, PresetID, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Attributes, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends
                        
                    case 5: //recordaddress =5 -> Attributes, PresetID, Name, Frequency, AlertType, AlertName

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSiriusAlertList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gSiriusAlertList_Attributes_Bit0[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x01);
                                        gSiriusAlertList_Attributes_Bit1[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x02) /0x02;
                                        gSiriusAlertList_Attributes_Bit2[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x04) /0x04; 
                                        gSiriusAlertList_Attributes_Bit3[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x08) /0x08;
                                        gSiriusAlertList_Attributes_Bit4[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x10) /0x10;
                                        gSiriusAlertList_Attributes_Bit5[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x20) /0x20;
                                        gSiriusAlertList_Attributes_Bit6[current_element]    =(gSiriusAlertList_Attributes[current_element] &0x40) /0x40;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                    gSiriusAlertList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++) //clear
			                                    gSiriusAlertList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //AlertType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSiriusAlertList_AlertType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //AlertName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++) //clear
			                                gSiriusAlertList_AlertName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSiriusAlertList_AlertName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends                    
                        
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSiriusAlertList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSiriusAlertList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSiriusAlertList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSiriusAlertList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gSiriusAlertList_Pos[i] && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSiriusAlertList_ListHandlingType !=AUDIO_SIRIUSALERTLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                                       
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSiriusAlertList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SiriusAlertList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gSiriusAlertList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSiriusAlertList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSiriusAlertList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSiriusAlertList_ListEntryReceptionInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SiriusAlertList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                  
                }                   
                
                //Panel
                putvalue(env_ASG_AudioSD_SAL_ASGID, gSiriusAlertList_ASGID);
                putvalue(env_ASG_AudioSD_SAL_TAID, gSiriusAlertList_TAID);

                gSiriusAlertList_recordaddress =recordaddress;
                gSiriusAlertList_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SiriusAlertList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
    if(gSiriusAlertList_TotalNumListElements<=AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE)
        gSiriusAlertList_SlidingWindow_State =AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gSiriusAlertList_SlidingWindow_State =AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_ACTIVE;

    if (gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK)
        SiriusAlertList_ListHandling ();
    else
        SiriusAlertList_display();
}

int SiriusAlertList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gSiriusAlertList_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gSiriusAlertList_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gSiriusAlertList_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int SiriusAlertList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_SIRIUSALERTLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

void SiriusAlertList_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_AlertType, buffer_PresetID, buffer_ReceptionInformation;
    byte buffer_Attributes_bit0, buffer_Attributes_bit1, buffer_Attributes_bit2, buffer_Attributes_bit3, 
      buffer_Attributes_bit4, buffer_Attributes_bit5, buffer_Attributes_bit6;
    word requested_startelement, startelement, elements, buffer_Pos, buffer_Attributes;
    char buffer_Name[AUDIO_SIRIUSALERTLIST_NAME_LENGTH], buffer_Frequency[AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH],
      buffer_AlertName[AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH], buffer_Extension[AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH];
    int i,j,k;
    
    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_AlertType            =0;
    buffer_PresetID             =0;
    buffer_ReceptionInformation =0;
    buffer_Attributes           =0;
    buffer_Attributes_bit0      =0;
    buffer_Attributes_bit1      =0;
    buffer_Attributes_bit2      =0;
    buffer_Attributes_bit3      =0;
    buffer_Attributes_bit4      =0;
    buffer_Attributes_bit5      =0;
    buffer_Attributes_bit6      =0;
    buffer_PresetID             =0;
    
    /***build-up complete cache***/

    switch (gSiriusAlertList_ListHandlingType)
    {
        case AUDIO_SIRIUSALERTLIST_BUILDUPCACHE:
             
            switch (gSiriusAlertList_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_UP:  
                    if(gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE && gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gSiriusAlertList_CallBackReason)
                        {
                            case AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE:

                                    if(gSiriusAlertList_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gSiriusAlertList_cacheBuildUp      =AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        SiriusAlertList_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gSiriusAlertList_cacheBuildUp      =AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_NOCACHE;              
                                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK; 
                                        gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
                                        
                                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);
                                        SiriusAlertList_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSiriusAlertList_CallBackReason  =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE;

                        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_WINDOW: 
                    if(gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE && gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gSiriusAlertList_CallBackReason)
                        {
                            case AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gSiriusAlertList_cacheBuildUp      =AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT;    
                                    
                                    SiriusAlertList_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =TRUE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSiriusAlertList_CallBackReason  =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE;

                        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_DOWN:
                    if(gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE && gSiriusAlertList_CallBackReason !=AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gSiriusAlertList_CallBackReason)
                        {
                            case AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gSiriusAlertList_cacheBuildUp      =AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_NOCACHE;              
                                    gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;
                                    gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
                                    
                                    gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH;
                                    
                                    //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);
                                    SiriusAlertList_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; i++) //find last cached element
                        {   
                            if(gSiriusAlertList_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; 
                            else
                                startelement    =gSiriusAlertList_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE;
                        
                        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_SIRIUSALERTLIST_DOWN_CACHE: 
                    if (gSiriusAlertList_CallBackReason ==AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gSiriusAlertList_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST; 
                            gSiriusAlertList_cacheDown         =TRUE;

                            SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gSiriusAlertList_CallBackReason =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST;
                            SiriusAlertList_ListHandling(); 
                        }    
                    }
                    else if (gSiriusAlertList_CallBackReason ==AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_NOCACHE;
                        gSiriusAlertList_cacheDown         =FALSE;
                        gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);
                        SiriusAlertList_display();
                        gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH;
                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gSiriusAlertList_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gSiriusAlertList_Pos[i];
                                    buffer_AlertType        =gSiriusAlertList_AlertType[i];
                                    buffer_Attributes       =gSiriusAlertList_Attributes[i];
                                    buffer_Attributes_bit0  =gSiriusAlertList_Attributes_Bit0[i];
                                    buffer_Attributes_bit1  =gSiriusAlertList_Attributes_Bit1[i];
                                    buffer_Attributes_bit2  =gSiriusAlertList_Attributes_Bit2[i];
                                    buffer_Attributes_bit3  =gSiriusAlertList_Attributes_Bit3[i];
                                    buffer_Attributes_bit4  =gSiriusAlertList_Attributes_Bit4[i];
                                    buffer_Attributes_bit5  =gSiriusAlertList_Attributes_Bit5[i];
                                    buffer_Attributes_bit6  =gSiriusAlertList_Attributes_Bit6[i];
                                    buffer_PresetID         =gSiriusAlertList_PresetID[i];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Name[i]);k++) 
                                        buffer_Name[k]=gSiriusAlertList_Name[i][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        buffer_Frequency[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[i]);k++) 
                                        buffer_Frequency[k]=gSiriusAlertList_Frequency[i][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        buffer_AlertName[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[i]);k++) 
                                        buffer_AlertName[k]=gSiriusAlertList_AlertName[i][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        buffer_Extension[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Extension[i]);k++) 
                                        buffer_Extension[k]=gSiriusAlertList_Extension[i][k];
                                    

                                    //copy data from Pos '1' to Pos '0'
                                    gSiriusAlertList_Pos[i]                       =gSiriusAlertList_Pos[j]; 
                                    gSiriusAlertList_AlertType[i]                 =gSiriusAlertList_AlertType[j];
                                    gSiriusAlertList_Attributes[i]                =gSiriusAlertList_Attributes[j];
                                    gSiriusAlertList_Attributes_Bit0[i]           =gSiriusAlertList_Attributes_Bit0[j];
                                    gSiriusAlertList_Attributes_Bit1[i]           =gSiriusAlertList_Attributes_Bit1[j];
                                    gSiriusAlertList_Attributes_Bit2[i]           =gSiriusAlertList_Attributes_Bit2[j];
                                    gSiriusAlertList_Attributes_Bit3[i]           =gSiriusAlertList_Attributes_Bit3[j];
                                    gSiriusAlertList_Attributes_Bit4[i]           =gSiriusAlertList_Attributes_Bit4[j];
                                    gSiriusAlertList_Attributes_Bit5[i]           =gSiriusAlertList_Attributes_Bit5[j];
                                    gSiriusAlertList_Attributes_Bit6[i]           =gSiriusAlertList_Attributes_Bit6[j];
                                    gSiriusAlertList_PresetID[i]                  =gSiriusAlertList_PresetID[j];
                                
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Name[j]);k++) 
                                        gSiriusAlertList_Name[i][k]=gSiriusAlertList_Name[j][k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[j]);k++) 
                                        gSiriusAlertList_Frequency[i][k]=gSiriusAlertList_Frequency[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[j]);k++) 
                                        gSiriusAlertList_AlertName[i][k]=gSiriusAlertList_AlertName[j][k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Extension[j]);k++) 
                                        gSiriusAlertList_Extension[i][k]=gSiriusAlertList_Extension[j][k];

                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gSiriusAlertList_ListEntryReceptionInformation[i] =0;
                                    gSiriusAlertList_Pos[i]                           =0;
                                    gSiriusAlertList_AlertType[i]                          =0;
                                    gSiriusAlertList_Attributes[i]                    =0;
                                    gSiriusAlertList_Attributes_Bit0[i]     =0;
                                    gSiriusAlertList_Attributes_Bit1[i]           =0;
                                    gSiriusAlertList_Attributes_Bit2[i]           =0;
                                    gSiriusAlertList_Attributes_Bit3[i]           =0;
                                    gSiriusAlertList_Attributes_Bit4[i]           =0;
                                    gSiriusAlertList_Attributes_Bit5[i]            =0;
                                    gSiriusAlertList_Attributes_Bit6[i]           =0;
                                    gSiriusAlertList_PresetID[i]                      =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0;
                                                                 
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gSiriusAlertList_Pos[i]                       =buffer_Pos; 
                                    gSiriusAlertList_AlertType[i]                 =buffer_AlertType;
                                    gSiriusAlertList_Attributes[i]                =buffer_Attributes;
                                    gSiriusAlertList_Attributes_Bit0[i]       =buffer_Attributes_bit0;
                                    gSiriusAlertList_Attributes_Bit1[i]       =buffer_Attributes_bit1;
                                    gSiriusAlertList_Attributes_Bit2[i]       =buffer_Attributes_bit2;
                                    gSiriusAlertList_Attributes_Bit3[i]       =buffer_Attributes_bit3;
                                    gSiriusAlertList_Attributes_Bit4[i]       =buffer_Attributes_bit4;
                                    gSiriusAlertList_Attributes_Bit5[i]       =buffer_Attributes_bit5;
                                    gSiriusAlertList_Attributes_Bit6[i]       =buffer_Attributes_bit6;
                                    gSiriusAlertList_PresetID[i]              =buffer_PresetID;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gSiriusAlertList_Name[i][k]=buffer_Name[k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Frequency);k++) 
                                        gSiriusAlertList_Frequency[i][k]=buffer_Frequency[k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_AlertName);k++) 
                                        gSiriusAlertList_AlertName[i][k]=buffer_AlertName[k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Extension);k++) 
                                        gSiriusAlertList_Extension[i][k]=buffer_Extension[k];
                                    
                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gSiriusAlertList_Pos[i]                       =gSiriusAlertList_Pos[j]; 
                                    gSiriusAlertList_AlertType[i]                 =gSiriusAlertList_AlertType[j];
                                    gSiriusAlertList_Attributes[i]                =gSiriusAlertList_Attributes[j];
                                    gSiriusAlertList_Attributes_Bit0[i]           =gSiriusAlertList_Attributes_Bit0[j];
                                    gSiriusAlertList_Attributes_Bit1[i]           =gSiriusAlertList_Attributes_Bit1[j]; 
                                    gSiriusAlertList_Attributes_Bit2[i]           =gSiriusAlertList_Attributes_Bit2[j];
                                    gSiriusAlertList_Attributes_Bit3[i]           =gSiriusAlertList_Attributes_Bit3[j];
                                    gSiriusAlertList_Attributes_Bit4[i]           =gSiriusAlertList_Attributes_Bit4[j];
                                    gSiriusAlertList_Attributes_Bit5[i]           =gSiriusAlertList_Attributes_Bit5[j];
                                    gSiriusAlertList_Attributes_Bit6[i]           =gSiriusAlertList_Attributes_Bit6[j];
                                    gSiriusAlertList_PresetID[i]                  =gSiriusAlertList_PresetID[j]; 
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Name[j]);k++) 
                                        gSiriusAlertList_Name[i][k]=gSiriusAlertList_Name[j][k];
                                        
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[j]);k++) 
                                        gSiriusAlertList_Frequency[i][k]=gSiriusAlertList_Frequency[j][k]; 
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[j]);k++) 
                                        gSiriusAlertList_AlertName[i][k]=gSiriusAlertList_AlertName[j][k];
                                        
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Extension[j]);k++) 
                                        gSiriusAlertList_Extension[i][k]=gSiriusAlertList_Extension[j][k]; 
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_SIRIUSALERTLIST_UP_CACHE: 
                    if (gSiriusAlertList_CallBackReason ==AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gSiriusAlertList_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =TRUE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gSiriusAlertList_cacheUp        =TRUE;
                            gSiriusAlertList_CallBackReason =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST;
                            
                            SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gSiriusAlertList_CallBackReason =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST;
                            SiriusAlertList_ListHandling();
                        }           
                    }

                    else if (gSiriusAlertList_CallBackReason ==AUDIO_SIRIUSALERTLIST_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_NOCACHE;
                        gSiriusAlertList_cacheUp           =FALSE;
                        gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, empty_string);
                        SiriusAlertList_display();
                        gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH;
                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        //putvalue(env_ASG_AudioSD_SAL_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gSiriusAlertList_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gSiriusAlertList_Pos[i];
                                    buffer_AlertType        =gSiriusAlertList_AlertType[i];
                                    buffer_Attributes       =gSiriusAlertList_Attributes[i];
                                    buffer_Attributes_bit0  =gSiriusAlertList_Attributes_Bit0[i];
                                    buffer_Attributes_bit1  =gSiriusAlertList_Attributes_Bit1[i];
                                    buffer_Attributes_bit2  =gSiriusAlertList_Attributes_Bit2[i];
                                    buffer_Attributes_bit3  =gSiriusAlertList_Attributes_Bit3[i];
                                    buffer_Attributes_bit4  =gSiriusAlertList_Attributes_Bit4[i];
                                    buffer_Attributes_bit5  =gSiriusAlertList_Attributes_Bit5[i];
                                    buffer_Attributes_bit6  =gSiriusAlertList_Attributes_Bit6[i];
                                    buffer_PresetID         =gSiriusAlertList_PresetID[i];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        buffer_Name[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Name[i]);k++) 
                                        buffer_Name[k]=gSiriusAlertList_Name[i][k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        buffer_Frequency[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[i]);k++) 
                                        buffer_Frequency[k]=gSiriusAlertList_Frequency[i][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        buffer_AlertName[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[i]);k++) 
                                        buffer_AlertName[k]=gSiriusAlertList_AlertName[i][k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        buffer_Extension[k] =0;                                     

                                    for(k=0;k<strlen(gSiriusAlertList_Extension[i]);k++) 
                                        buffer_Extension[k]=gSiriusAlertList_Extension[i][k];

                                    
                                    //copy data from Pos '7' to Pos '8'
                                    gSiriusAlertList_Pos[i]                       =gSiriusAlertList_Pos[j]; 
                                    gSiriusAlertList_AlertType[i]                 =gSiriusAlertList_AlertType[j];
                                    gSiriusAlertList_Attributes[i]                =gSiriusAlertList_Attributes[j];
                                    gSiriusAlertList_Attributes_Bit0[i]       =gSiriusAlertList_Attributes_Bit0[j];
                                    gSiriusAlertList_Attributes_Bit1[i]       =gSiriusAlertList_Attributes_Bit1[j];
                                    gSiriusAlertList_Attributes_Bit2[i]       =gSiriusAlertList_Attributes_Bit2[j];
                                    gSiriusAlertList_Attributes_Bit3[i]       =gSiriusAlertList_Attributes_Bit3[j];
                                    gSiriusAlertList_Attributes_Bit4[i]       =gSiriusAlertList_Attributes_Bit4[j];
                                    gSiriusAlertList_Attributes_Bit5[i]       =gSiriusAlertList_Attributes_Bit5[j];
                                    gSiriusAlertList_Attributes_Bit6[i]       =gSiriusAlertList_Attributes_Bit6[j];
                                    gSiriusAlertList_PresetID[i]                  =gSiriusAlertList_PresetID[j];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Name[j]);k++) 
                                        gSiriusAlertList_Name[i][k]=gSiriusAlertList_Name[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[j]);k++) 
                                        gSiriusAlertList_Frequency[i][k]=gSiriusAlertList_Frequency[j][k]; 
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[j]);k++) 
                                        gSiriusAlertList_AlertName[i][k]=gSiriusAlertList_AlertName[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Extension[j]);k++) 
                                        gSiriusAlertList_Extension[i][k]=gSiriusAlertList_Extension[j][k]; 
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gSiriusAlertList_ListEntryReceptionInformation[i] =0;
                                    gSiriusAlertList_Pos[i]                           =0;
                                    gSiriusAlertList_AlertType[i]                          =0;
                                    gSiriusAlertList_Attributes[i]                    =0;
                                    gSiriusAlertList_Attributes_Bit0[i]     =0;
                                    gSiriusAlertList_Attributes_Bit1[i]           =0;
                                    gSiriusAlertList_Attributes_Bit2[i]           =0;
                                    gSiriusAlertList_Attributes_Bit3[i]           =0;
                                    gSiriusAlertList_Attributes_Bit4[i]           =0;
                                    gSiriusAlertList_Attributes_Bit5[i]            =0;
                                    gSiriusAlertList_Attributes_Bit6[i]           =0;
                                    gSiriusAlertList_PresetID[i]                      =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0;
                                                                            
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gSiriusAlertList_Pos[i]                       =buffer_Pos; 
                                    gSiriusAlertList_AlertType[i]                      =buffer_AlertType;
                                    gSiriusAlertList_Attributes[i]                =buffer_Attributes;
                                    gSiriusAlertList_Attributes_Bit0[i] =buffer_Attributes_bit0;
                                    gSiriusAlertList_Attributes_Bit1[i]       =buffer_Attributes_bit1;
                                    gSiriusAlertList_Attributes_Bit2[i]       =buffer_Attributes_bit2;
                                    gSiriusAlertList_Attributes_Bit3[i]       =buffer_Attributes_bit3;
                                    gSiriusAlertList_Attributes_Bit4[i]       =buffer_Attributes_bit4;
                                    gSiriusAlertList_Attributes_Bit5[i]        =buffer_Attributes_bit5;
                                    gSiriusAlertList_Attributes_Bit6[i]       =buffer_Attributes_bit6;
                                    gSiriusAlertList_PresetID[i]                  =buffer_PresetID;
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Name);k++) 
                                        gSiriusAlertList_Name[i][k]=buffer_Name[k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Frequency);k++) 
                                        gSiriusAlertList_Frequency[i][k]=buffer_Frequency[k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_AlertName);k++) 
                                        gSiriusAlertList_AlertName[i][k]=buffer_AlertName[k];

                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_Extension);k++) 
                                        gSiriusAlertList_Extension[i][k]=buffer_Extension[k];
                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gSiriusAlertList_Pos[i]                       =gSiriusAlertList_Pos[j]; 
                                    gSiriusAlertList_AlertType[i]                 =gSiriusAlertList_AlertType[j];
                                    gSiriusAlertList_Attributes[i]                =gSiriusAlertList_Attributes[j];
                                    gSiriusAlertList_Attributes_Bit0[i]       =gSiriusAlertList_Attributes_Bit0[j];
                                    gSiriusAlertList_Attributes_Bit1[i]       =gSiriusAlertList_Attributes_Bit1[j];
                                    gSiriusAlertList_Attributes_Bit2[i]       =gSiriusAlertList_Attributes_Bit2[j];
                                    gSiriusAlertList_Attributes_Bit3[i]       =gSiriusAlertList_Attributes_Bit3[j];
                                    gSiriusAlertList_Attributes_Bit4[i]       =gSiriusAlertList_Attributes_Bit4[j];
                                    gSiriusAlertList_Attributes_Bit5[i]       =gSiriusAlertList_Attributes_Bit5[j];
                                    gSiriusAlertList_Attributes_Bit6[i]       =gSiriusAlertList_Attributes_Bit6[j];
                                    gSiriusAlertList_PresetID[i]                  =gSiriusAlertList_PresetID[j];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_Name[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Name[j]);k++) 
                                        gSiriusAlertList_Name[i][k]=gSiriusAlertList_Name[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;k++) //clear string
                                        gSiriusAlertList_Frequency[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Frequency[j]);k++) 
                                        gSiriusAlertList_Frequency[i][k]=gSiriusAlertList_Frequency[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;k++) //clear string
                                        gSiriusAlertList_AlertName[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_AlertName[j]);k++) 
                                        gSiriusAlertList_AlertName[i][k]=gSiriusAlertList_AlertName[j][k];
                                    
                                    for (k=0; k<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;k++) //clear string
                                        gSiriusAlertList_Extension[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gSiriusAlertList_Extension[j]);k++) 
                                        gSiriusAlertList_Extension[i][k]=gSiriusAlertList_Extension[j][k];
                                    
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gSiriusAlertList_CallBackReason    =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

void SiriusAlertList_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_SAL_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gSiriusAlertList_DisplayStatus ==AUDIO_SIRIUSALERTLIST_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gSiriusAlertList_CursorAction ==AUDIO_SIRIUSALERTLIST_CURSORACTION_DOWN)
                Element_1 =SiriusAlertList_GetNextCachedElement(gSiriusAlertList_LastFirstElement, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gSiriusAlertList_CursorAction ==AUDIO_SIRIUSALERTLIST_CURSORACTION_UP)            
                Element_1 =SiriusAlertList_GetNextCachedElement(gSiriusAlertList_LastFirstElement, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_0, gSiriusAlertList_Pos[Element_1]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_0, gSiriusAlertList_AlertType[Element_1]);

                if(gSiriusAlertList_AlertType[Element_1] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, gSiriusAlertList_Attributes_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, gSiriusAlertList_Attributes_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, gSiriusAlertList_Attributes_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, gSiriusAlertList_Attributes_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, gSiriusAlertList_Attributes_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, gSiriusAlertList_Attributes_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, gSiriusAlertList_Attributes_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_1]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_0,gSiriusAlertList_PresetID[Element_1]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_0,gSiriusAlertList_Name[Element_1]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_0,gSiriusAlertList_Frequency[Element_1]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_0,gSiriusAlertList_AlertName[Element_1]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_0,gSiriusAlertList_Extension[Element_1]);

            gSiriusAlertList_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =SiriusAlertList_GetNextCachedElement(Element_1, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_1, gSiriusAlertList_Pos[Element_2]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_1, gSiriusAlertList_AlertType[Element_2]);

                if(gSiriusAlertList_AlertType[Element_2] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, gSiriusAlertList_Attributes_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, gSiriusAlertList_Attributes_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, gSiriusAlertList_Attributes_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, gSiriusAlertList_Attributes_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, gSiriusAlertList_Attributes_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, gSiriusAlertList_Attributes_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, gSiriusAlertList_Attributes_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_2]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_1,gSiriusAlertList_PresetID[Element_2]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_1,gSiriusAlertList_Name[Element_2]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_1,gSiriusAlertList_Frequency[Element_2]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_1,gSiriusAlertList_AlertName[Element_2]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_1,gSiriusAlertList_Extension[Element_2]);
            
            //3. Element          
            Element_3 =SiriusAlertList_GetNextCachedElement(Element_2, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_2, gSiriusAlertList_Pos[Element_3]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_2, gSiriusAlertList_AlertType[Element_3]);

                if(gSiriusAlertList_AlertType[Element_3] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, gSiriusAlertList_Attributes_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, gSiriusAlertList_Attributes_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, gSiriusAlertList_Attributes_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, gSiriusAlertList_Attributes_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, gSiriusAlertList_Attributes_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, gSiriusAlertList_Attributes_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, gSiriusAlertList_Attributes_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_3]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_2,gSiriusAlertList_PresetID[Element_3]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_2,gSiriusAlertList_Name[Element_3]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_2,gSiriusAlertList_Frequency[Element_3]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_2,gSiriusAlertList_AlertName[Element_3]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_2,gSiriusAlertList_Extension[Element_3]);
        }

        /******'sliding Window' active or 'build-up List'******/
        else if(gSiriusAlertList_DisplayStatus ==AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gSiriusAlertList_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_SAL_OnOff))
            {   
                Element_1 =0;
                
            //Pos
            if (gSiriusAlertList_transmitpos)
                putvalue(env_ASG_AudioSD_SAL_pos_0, gSiriusAlertList_Pos[Element_1]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_0, gSiriusAlertList_AlertType[Element_1]);

                if(gSiriusAlertList_AlertType[Element_1] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, gSiriusAlertList_Attributes_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, gSiriusAlertList_Attributes_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, gSiriusAlertList_Attributes_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, gSiriusAlertList_Attributes_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, gSiriusAlertList_Attributes_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, gSiriusAlertList_Attributes_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, gSiriusAlertList_Attributes_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_1]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_0,gSiriusAlertList_PresetID[Element_1]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_0,gSiriusAlertList_Name[Element_1]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_0,gSiriusAlertList_Frequency[Element_1]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_0,gSiriusAlertList_AlertName[Element_1]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_0,gSiriusAlertList_Extension[Element_1]);
             }

            
            //2. Element    
            if(gSiriusAlertList_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_SAL_OnOff))
            {
                Element_2 =1;
            //Pos
            if (gSiriusAlertList_transmitpos)        
                putvalue(env_ASG_AudioSD_SAL_pos_1, gSiriusAlertList_Pos[Element_2]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_1, gSiriusAlertList_AlertType[Element_2]);

                if(gSiriusAlertList_AlertType[Element_2] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, gSiriusAlertList_Attributes_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, gSiriusAlertList_Attributes_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, gSiriusAlertList_Attributes_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, gSiriusAlertList_Attributes_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, gSiriusAlertList_Attributes_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, gSiriusAlertList_Attributes_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, gSiriusAlertList_Attributes_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_2]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_1,gSiriusAlertList_PresetID[Element_2]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_1,gSiriusAlertList_Name[Element_2]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_1,gSiriusAlertList_Frequency[Element_2]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_1,gSiriusAlertList_AlertName[Element_2]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_1,gSiriusAlertList_Extension[Element_2]);
             }

             //3. Element    
            if(gSiriusAlertList_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_SAL_OnOff))
            {
             Element_3 =2;
             //Pos
             if (gSiriusAlertList_transmitpos)       
                putvalue(env_ASG_AudioSD_SAL_pos_2, gSiriusAlertList_Pos[Element_3]);               
            
             //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_2, gSiriusAlertList_AlertType[Element_1]);

                if(gSiriusAlertList_AlertType[Element_3] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, gSiriusAlertList_Attributes_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, gSiriusAlertList_Attributes_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, gSiriusAlertList_Attributes_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, gSiriusAlertList_Attributes_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, gSiriusAlertList_Attributes_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, gSiriusAlertList_Attributes_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, gSiriusAlertList_Attributes_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_3]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_2,gSiriusAlertList_PresetID[Element_3]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_2,gSiriusAlertList_Name[Element_3]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_2,gSiriusAlertList_Frequency[Element_3]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_2,gSiriusAlertList_AlertName[Element_3]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_2,gSiriusAlertList_Extension[Element_3]);   
            }
        }
        else if (gSiriusAlertList_DisplayStatus ==AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH)
        {               
            //1. Element
            if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gSiriusAlertList_LastFirstElement; 
            else
                Element_1 =0;

            if(gSiriusAlertList_ListEntryReceptionInformation[Element_1])
            {
            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_0, gSiriusAlertList_Pos[Element_1]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_0, gSiriusAlertList_AlertType[Element_1]);

                if(gSiriusAlertList_AlertType[Element_1] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_1]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_0,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, gSiriusAlertList_Attributes_Bit0[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, gSiriusAlertList_Attributes_Bit1[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, gSiriusAlertList_Attributes_Bit2[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, gSiriusAlertList_Attributes_Bit3[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, gSiriusAlertList_Attributes_Bit4[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, gSiriusAlertList_Attributes_Bit5[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_1]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, gSiriusAlertList_Attributes_Bit6[Element_1]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_1]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_0,gSiriusAlertList_PresetID[Element_1]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_0,gSiriusAlertList_Name[Element_1]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_0,gSiriusAlertList_Frequency[Element_1]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_0,gSiriusAlertList_AlertName[Element_1]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_0,gSiriusAlertList_Extension[Element_1]);
            }

            //2. Element             
            if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =SiriusAlertList_GetNextCachedElement(Element_1, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gSiriusAlertList_ListEntryReceptionInformation[Element_2])
            {
            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_1, gSiriusAlertList_Pos[Element_2]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_1, gSiriusAlertList_AlertType[Element_2]);

                if(gSiriusAlertList_AlertType[Element_2] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_2]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_1,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, gSiriusAlertList_Attributes_Bit0[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, gSiriusAlertList_Attributes_Bit1[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, gSiriusAlertList_Attributes_Bit2[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, gSiriusAlertList_Attributes_Bit3[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, gSiriusAlertList_Attributes_Bit4[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, gSiriusAlertList_Attributes_Bit5[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_2]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, gSiriusAlertList_Attributes_Bit6[Element_2]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_2]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_1,gSiriusAlertList_PresetID[Element_2]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_1,gSiriusAlertList_Name[Element_2]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_1,gSiriusAlertList_Frequency[Element_2]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_1,gSiriusAlertList_AlertName[Element_2]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_1,gSiriusAlertList_Extension[Element_2]);
            }

            //3. Element          
            if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =SiriusAlertList_GetNextCachedElement(Element_2, AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gSiriusAlertList_ListEntryReceptionInformation[Element_3])
            {    
            //Pos
            putvalue(env_ASG_AudioSD_SAL_pos_2, gSiriusAlertList_Pos[Element_3]);               
            
            //AlertType
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5) 
            {
                putvalue(env_ASG_AudioSD_SAL_AType_2, gSiriusAlertList_AlertType[Element_3]);

                if(gSiriusAlertList_AlertType[Element_3] <0x08)
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gSiriusAlertList_AlertType_s[gSiriusAlertList_AlertType[Element_3]]);
                else
                    putvalue(env_ASG_AudioSD_SAL_AType_s_2,gstring_reserved);
            }

            //Attributes
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1|| gSiriusAlertList_recordaddress ==2|| gSiriusAlertList_recordaddress ==4|| gSiriusAlertList_recordaddress ==6) 
            {
                putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, gSiriusAlertList_Attributes_Bit0[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2,gSiriusAlertList_Attributes_Bit0_s[gSiriusAlertList_Attributes_Bit0[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, gSiriusAlertList_Attributes_Bit1[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2,gSiriusAlertList_Attributes_Bit1_s[gSiriusAlertList_Attributes_Bit1[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, gSiriusAlertList_Attributes_Bit2[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2,gSiriusAlertList_Attributes_Bit2_s[gSiriusAlertList_Attributes_Bit2[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, gSiriusAlertList_Attributes_Bit3[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2,gSiriusAlertList_Attributes_Bit3_s[gSiriusAlertList_Attributes_Bit3[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, gSiriusAlertList_Attributes_Bit4[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2,gSiriusAlertList_Attributes_Bit4_s[gSiriusAlertList_Attributes_Bit4[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, gSiriusAlertList_Attributes_Bit5[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2,gSiriusAlertList_Attributes_Bit5_s[gSiriusAlertList_Attributes_Bit5[Element_3]]);

                putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, gSiriusAlertList_Attributes_Bit6[Element_3]);
                putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2,gSiriusAlertList_Attributes_Bit6_s[gSiriusAlertList_Attributes_Bit6[Element_3]]);
            }

            //PresetID
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_PrID_2,gSiriusAlertList_PresetID[Element_3]);
            
            //Name
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==2 || gSiriusAlertList_recordaddress ==3 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Name_s_2,gSiriusAlertList_Name[Element_3]);
            
            //Frequency
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==1 || gSiriusAlertList_recordaddress ==4 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_Freq_s_2,gSiriusAlertList_Frequency[Element_3]);
                
            //AlertName
            if (gSiriusAlertList_recordaddress ==0 || gSiriusAlertList_recordaddress ==5)
                putvalue(env_ASG_AudioSD_SAL_AName_s_2,gSiriusAlertList_AlertName[Element_3]);
            
            //Extension
            if (gSiriusAlertList_recordaddress ==0)
                putvalue(env_ASG_AudioSD_SAL_Ext_s_2,gSiriusAlertList_Extension[Element_3]);
            }
        }
    }
}

on envVar env_ASG_AudioSD_SAL_GetArray
{
    byte mode, shift, direction, transmitpos, indexsize,recordaddress;
    word requested_startelement, startelement, elements;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSiriusAlertList_ListHandlingType ==AUDIO_SIRIUSALERTLIST_NOCACHE)
	{
        gSiriusAlertList_ASGID            =getvalue(env_ASG_AudioSD_SAL_ASGID);
        gSiriusAlertList_TAID             =getvalue(env_ASG_AudioSD_SAL_TAID);
        
        shift                           =getvalue(env_ASG_AudioSD_SAL_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_SAL_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_SAL_AH_PosTrans);
        indexsize                       =getvalue(env_ASG_AudioSD_SAL_AH_IS);
        recordaddress                   =getvalue(env_ASG_AudioSD_SAL_AH_RA);
        startelement                    =getvalue(env_ASG_AudioSD_SAL_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_SAL_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        SiriusAlertList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

on envVar env_ASG_AudioSD_SAL_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gSiriusAlertList_ListHandlingType      =AUDIO_SIRIUSALERTLIST_BUILDUPCACHE;             //build-up complete cache...
            gSiriusAlertList_cacheBuildUp          =AUDIO_SIRIUSALERTLIST_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            SiriusAlertList_ListHandling ();
        }
        else
        {
            gSiriusAlertList_SlidingWindow_State   =AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE;
            gSiriusAlertList_ListHandlingType      =AUDIO_SIRIUSALERTLIST_NOCACHE;
            gSiriusAlertList_cacheBuildUp          =AUDIO_SIRIUSALERTLIST_BUILDUPCACHENOCACHE;
            gSiriusAlertList_CallBackReason        =AUDIO_SIRIUSALERTLIST_CALLBACKREASON_NOCALLBACK;

            gSiriusAlertList_cacheDown             =FALSE;
            gSiriusAlertList_cacheUp               =FALSE;
            gSiriusAlertList_LastFirstElement      =0;

            gSiriusAlertList_recordaddress         =0;
            gSiriusAlertList_transmitpos           =1;
            gSiriusAlertList_CursorAction          =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
            gSiriusAlertList_DisplayStatus         =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIO_SIRIUSALERTLIST_ASGCACHE_MAX_SIZE; j++)
            {     
                gSiriusAlertList_Pos[j]                            =0;
                gSiriusAlertList_AlertType[j]                           =0;
                gSiriusAlertList_Attributes_Bit0[j]      =0;
                gSiriusAlertList_Attributes_Bit1[j]            =0;
                gSiriusAlertList_Attributes_Bit2[j]            =0;
                gSiriusAlertList_Attributes_Bit3[j]            =0;
                gSiriusAlertList_Attributes_Bit4[j]            =0;
                gSiriusAlertList_Attributes_Bit5[j]             =0;
                gSiriusAlertList_Attributes_Bit6[j]            =0;
                gSiriusAlertList_Attributes[j]                     =0;
                gSiriusAlertList_PresetID[j]                       =0;
                gSiriusAlertList_ListEntryReceptionInformation[j]  =0;

                for(i=0;i<AUDIO_SIRIUSALERTLIST_NAME_LENGTH;i++)
			            gSiriusAlertList_Name[j][i] =0;
                
                for(i=0;i<AUDIO_SIRIUSALERTLIST_FREQUENCY_LENGTH;i++)
			            gSiriusAlertList_Frequency[j][i] =0;
                
                for(i=0;i<AUDIO_SIRIUSALERTLIST_ALERTNAME_LENGTH;i++)
			            gSiriusAlertList_AlertName[j][i] =0;
                
                for(i=0;i<AUDIO_SIRIUSALERTLIST_EXTENSION_LENGTH;i++)
			            gSiriusAlertList_Extension[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_SAL_pos_0, 0);
            putvalue(env_ASG_AudioSD_SAL_pos_1, 0);
            putvalue(env_ASG_AudioSD_SAL_pos_2, 0);
    
            putvalue(env_ASG_AudioSD_SAL_AType_0, 0);
            putvalue(env_ASG_AudioSD_SAL_AType_1, 0);
            putvalue(env_ASG_AudioSD_SAL_AType_2, 0);

            putvalue(env_ASG_AudioSD_SAL_AType_s_0,empty_string);
            putvalue(env_ASG_AudioSD_SAL_AType_s_1,empty_string);
            putvalue(env_ASG_AudioSD_SAL_AType_s_2,empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit0_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit0_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit0_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit0_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit1_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit1_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit1_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit1_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit2_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit2_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit2_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit2_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit3_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit3_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit3_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit3_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit4_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit4_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit4_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit4_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit5_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit5_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit5_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit5_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Attr_bit6_0, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit6_1, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_bit6_2, 0);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Attr_sbit6_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_PrID_0, 0);
            putvalue(env_ASG_AudioSD_SAL_PrID_1, 0);
            putvalue(env_ASG_AudioSD_SAL_PrID_2, 0);

            putvalue(env_ASG_AudioSD_SAL_Name_s_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Name_s_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Name_s_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Freq_s_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Freq_s_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Freq_s_2, empty_string);
            
            putvalue(env_ASG_AudioSD_SAL_AName_s_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_AName_s_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_AName_s_2, empty_string);

            putvalue(env_ASG_AudioSD_SAL_Ext_s_0, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Ext_s_1, empty_string);
            putvalue(env_ASG_AudioSD_SAL_Ext_s_2, empty_string);
            
        }
    }
}   

on envVar env_ASG_AudioSD_SAL_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSiriusAlertList_ListHandlingType ==AUDIO_SIRIUSALERTLIST_NOCACHE)
	{      
        gSiriusAlertList_CursorAction =AUDIO_SIRIUSALERTLIST_CURSORACTION_DOWN;
        
        if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_ACTIVE)
        {   
            gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_DOWN_CACHE;
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
            
            SiriusAlertList_ListHandling ();
        }
        else if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_DOWN;

            SiriusAlertList_display();

            //reset values
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_SAL_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSiriusAlertList_ListHandlingType ==AUDIO_SIRIUSALERTLIST_NOCACHE)
	{   
        gSiriusAlertList_CursorAction =AUDIO_SIRIUSALERTLIST_CURSORACTION_UP;

        if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_ACTIVE)
        {  
            gSiriusAlertList_ListHandlingType  =AUDIO_SIRIUSALERTLIST_UP_CACHE;
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_FIRST_ELEMENTS;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
            
            SiriusAlertList_ListHandling ();
        }
        else if(gSiriusAlertList_SlidingWindow_State ==AUDIO_SIRIUSALERTLIST_SLIDINGWINDOW_NOTACTIVE)
        {
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_SEARCH_ELEMENTS;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_UP;

            SiriusAlertList_ListHandling();
            
            SiriusAlertList_display();

            //reset values
            gSiriusAlertList_DisplayStatus     =AUDIO_SIRIUSALERTLIST_DISPLAYLIST_REFRESH;
            gSiriusAlertList_CursorAction      =AUDIO_SIRIUSALERTLIST_CURSORACTION_NOTHING;
        }    
    }
}

on envVar env_ASG_AudioSD_PP_get
{
}

void PlayPosition_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_PlayPosition;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Request: invalid request %d", request);
  		break;
  	}
}

void PlayPosition_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
  			gAudioSD_PlayPosition_TimePosition = Indication_array[3];
  			gAudioSD_PlayPosition_TimePosition  += Indication_array[4] *0x100;
        gAudioSD_PlayPosition_TotalPlayTime = Indication_array[5];
        gAudioSD_PlayPosition_TotalPlayTime   += Indication_array[6] *0x100;
        gAudioSD_PlayPosition_Attributes = Indication_array[7];
        gAudioSD_PlayPosition_Attributes_Bit0 =gAudioSD_PlayPosition_Attributes &0x01; //Bit '0'
        gAudioSD_PlayPosition_BufferLevel = Indication_array[8];
        
        putvalue(env_ASG_AudioSD_PP_TimePos,gAudioSD_PlayPosition_TimePosition);
        putvalue(env_ASG_AudioSD_PP_TotalPlayTime,gAudioSD_PlayPosition_TotalPlayTime);
        putvalue(env_ASG_AudioSD_PP_Attr_Bit0,gAudioSD_PlayPosition_Attributes_Bit0);
        putvalue(env_ASG_AudioSD_PP_BufferLevel,gAudioSD_PlayPosition_BufferLevel);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD PlayPosition_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_SRS_get
{
}

void SDS_RecognizerState_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_SDS_RecognizerState;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD SDS_RecognizerState_Request: invalid request %d", request);
  		break;
  	}
}

void SDS_RecognizerState_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
  			gAudioSD_SDS_RecognizerState_InputLevel   = Indication_array[3];
  			gAudioSD_SDS_RecognizerState_InputQuality = Indication_array[4];
        gAudioSD_SDS_RecognizerState_Extension1   = Indication_array[5];
        gAudioSD_SDS_RecognizerState_Extension2   = Indication_array[6];
        gAudioSD_SDS_RecognizerState_Extension3   = Indication_array[7];
        gAudioSD_SDS_RecognizerState_Extension4   = Indication_array[8];
        
        putvalue(env_ASG_AudioSD_SRS_InputLevel,gAudioSD_SDS_RecognizerState_InputLevel);
        putvalue(env_ASG_AudioSD_SRS_InputQuality,gAudioSD_SDS_RecognizerState_InputQuality);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SDS_RecognizerState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SDS_RecognizerState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SDS_RecognizerState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SDS_RecognizerState_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD SDS_RecognizerState_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_CSI2_get
{
}

void CurrentStationInfo2_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_CurrentStationInfo2;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Request: invalid request %d", request);
  		break;
  	}
}

void CurrentStationInfo2_Indication (dword Indication_array [], int datalength)
{
		int i =0, Offset =0, length =0;
  
    switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
        length =Indication_array[3];
        Offset =4;
        //Name
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information1[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information1[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType1 =Indication_array[Offset];
        Offset++;
        //ID
        gAudioSD_CSI2_InfoID1 =Indication_array[Offset]; 
        Offset++;
        gAudioSD_CSI2_InfoID1 +=Indication_array[Offset] *0x100;
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information2[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information2[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType2 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information3[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information3[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType3 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information4[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information4[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType4 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information5[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information5[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType5 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information6[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information6[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType6 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information7[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information7[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType7 =Indication_array[Offset];
        Offset++;
        //Name
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<CSI2_INFORMATION_TEXTLENGTH; i++)
            gAudioSD_CSI2_Information8[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_CSI2_Information8[i] =Indication_array[Offset];
            Offset++;
        }
        //Type
        gAudioSD_CSI2_InfoType8 =Indication_array[Offset];
        Offset++;
        //StationInfoSwitches
        gAudioSD_CSI2_StationInfoSwitches =Indication_array[Offset]; 
        Offset++;
        gAudioSD_CSI2_StationInfoSwitches +=Indication_array[Offset] *0x100;
        Offset++;
        gAudioSD_CSI2_StationInfoSwitches_Bit0  =gAudioSD_CSI2_StationInfoSwitches &0x01;
        gAudioSD_CSI2_StationInfoSwitches_Bit1  =(gAudioSD_CSI2_StationInfoSwitches &0x02) /0x02;
        gAudioSD_CSI2_StationInfoSwitches_Bit2  =(gAudioSD_CSI2_StationInfoSwitches &0x04) /0x04;
        gAudioSD_CSI2_StationInfoSwitches_Bit3  =(gAudioSD_CSI2_StationInfoSwitches &0x08) /0x08;
        gAudioSD_CSI2_StationInfoSwitches_Bit4  =(gAudioSD_CSI2_StationInfoSwitches &0x10) /0x10;
        //StationProperties
        gAudioSD_CSI2_StationProperties =Indication_array[Offset]; 
        Offset++;
        gAudioSD_CSI2_StationProperties +=Indication_array[Offset] *0x100;
        Offset++;
        gAudioSD_CSI2_StationProperties_Bit0  =gAudioSD_CSI2_StationProperties &0x01;
        gAudioSD_CSI2_StationProperties_Bit1  =(gAudioSD_CSI2_StationProperties &0x02) /0x02;
        gAudioSD_CSI2_StationProperties_Bit2  =(gAudioSD_CSI2_StationProperties &0x04) /0x04;
        gAudioSD_CSI2_StationProperties_Bit3  =(gAudioSD_CSI2_StationProperties &0x08) /0x08;
        gAudioSD_CSI2_StationProperties_Bit4  =(gAudioSD_CSI2_StationProperties &0x10) /0x10;
        gAudioSD_CSI2_StationProperties_Bit5  =(gAudioSD_CSI2_StationProperties &0x20) /0x20;
        gAudioSD_CSI2_StationProperties_Bit6  =(gAudioSD_CSI2_StationProperties &0x40) /0x40;
        //Channel_ID
        gAudioSD_CSI2_ChannelID =Indication_array[Offset]; 
        Offset++;
        gAudioSD_CSI2_ChannelID +=Indication_array[Offset] *0x100;
        Offset++;
        
        putvalue(env_ASG_AudioSD_CSI2_InfoID1,gAudioSD_CSI2_InfoID1);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy1,gAudioSD_CSI2_InfoType1);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy2,gAudioSD_CSI2_InfoType2);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy3,gAudioSD_CSI2_InfoType3);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy4,gAudioSD_CSI2_InfoType4);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy5,gAudioSD_CSI2_InfoType5);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy6,gAudioSD_CSI2_InfoType6);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy7,gAudioSD_CSI2_InfoType7);
        putvalue(env_ASG_AudioSD_CSI2_InfoTy8,gAudioSD_CSI2_InfoType8);
        putvalue(env_ASG_AudioSD_CSI2_Info1,gAudioSD_CSI2_Information1);
        putvalue(env_ASG_AudioSD_CSI2_Info2,gAudioSD_CSI2_Information2);
        putvalue(env_ASG_AudioSD_CSI2_Info3,gAudioSD_CSI2_Information3);
        putvalue(env_ASG_AudioSD_CSI2_Info4,gAudioSD_CSI2_Information4);
        putvalue(env_ASG_AudioSD_CSI2_Info5,gAudioSD_CSI2_Information5);
        putvalue(env_ASG_AudioSD_CSI2_Info6,gAudioSD_CSI2_Information6);
        putvalue(env_ASG_AudioSD_CSI2_Info7,gAudioSD_CSI2_Information7);
        putvalue(env_ASG_AudioSD_CSI2_Info8,gAudioSD_CSI2_Information8);
        putvalue(env_ASG_AudioSD_CSI2_ChanID,gAudioSD_CSI2_ChannelID);
        putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0,gAudioSD_CSI2_StationInfoSwitches_Bit0);
        putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1,gAudioSD_CSI2_StationInfoSwitches_Bit1);
        putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2,gAudioSD_CSI2_StationInfoSwitches_Bit2);
        putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3,gAudioSD_CSI2_StationInfoSwitches_Bit3);
        putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4,gAudioSD_CSI2_StationInfoSwitches_Bit4);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit0,gAudioSD_CSI2_StationProperties_Bit0);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit1,gAudioSD_CSI2_StationProperties_Bit1);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit2,gAudioSD_CSI2_StationProperties_Bit2);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit3,gAudioSD_CSI2_StationProperties_Bit3);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit4,gAudioSD_CSI2_StationProperties_Bit4);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit5,gAudioSD_CSI2_StationProperties_Bit5);
        putvalue(env_ASG_AudioSD_CSI2_SP_Bit6,gAudioSD_CSI2_StationProperties_Bit6);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStationInfo2_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_CSH3_get
{
}

void CurrentStation_Handle3_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_CurrentStation_Handle3;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle3_Request: invalid request %d", request);
  		break;
  	}
}

void CurrentStation_Handle3_Indication (dword Indication_array [], int datalength)
{
		switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
  			gAudioSD_CurrentStation_Handle3_FavList      = Indication_array[3];
  			gAudioSD_CurrentStation_Handle3_FavListaP    = Indication_array[4];
        gAudioSD_CurrentStation_Handle3_Extension1   = Indication_array[5];
        gAudioSD_CurrentStation_Handle3_Extension2   = Indication_array[6];
        gAudioSD_CurrentStation_Handle3_Extension3   = Indication_array[7];
        gAudioSD_CurrentStation_Handle3_Extension4   = Indication_array[8];
        
        putvalue(env_ASG_AudioSD_CSH3_FavList,gAudioSD_CurrentStation_Handle3_FavList);
        putvalue(env_ASG_AudioSD_CSH3_FLaP,gAudioSD_CurrentStation_Handle3_FavListaP);
        putvalue(env_ASG_AudioSD_CSH3_Extension1,gAudioSD_CurrentStation_Handle3_Extension1);
        putvalue(env_ASG_AudioSD_CSH3_Extension2,gAudioSD_CurrentStation_Handle3_Extension2);
        putvalue(env_ASG_AudioSD_CSH3_Extension3,gAudioSD_CurrentStation_Handle3_Extension3);
        putvalue(env_ASG_AudioSD_CSH3_Extension4,gAudioSD_CurrentStation_Handle3_Extension4);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle3_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle3_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle3_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStation_Handle3_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStation_Handle3_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_SAI_get
{
}

void SiriusAlertInfo_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_SiriusAlertInfo;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertInfo_Request: invalid request %d", request);
  		break;
  	}
}

void SiriusAlertInfo_Indication (dword Indication_array [], int datalength)
{
		int i =0, Offset =0, length =0;
  
    switch (gBAP_Indication[2])
		{
			case Data_IND:
        //get data
        Offset=3;
        //AlertType
        gAudioSD_SAI_AlertType =Indication_array[Offset];
        Offset++;
        //AlertName
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<SAI_ALERTNAME_TEXTLENGTH; i++)
            gAudioSD_SAI_AlertName[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_SAI_AlertName[i] =Indication_array[Offset];
            Offset++;
        }
        //StationName
        length =Indication_array[Offset];
        Offset++;
        for (i=0; i<SAI_STATIONNAME_TEXTLENGTH; i++)
            gAudioSD_SAI_StationName[i] =0;
        for (i=0; i< length; i++)
        { 
            gAudioSD_SAI_StationName[i] =Indication_array[Offset];
            Offset++;
        }
        //SALref
        gAudioSD_SAI_SALref =Indication_array[Offset]; 
        Offset++;
        gAudioSD_SAI_SALref +=Indication_array[Offset] *0x100;
        Offset++;
        //Extension1
        gAudioSD_SAI_Extension1 =Indication_array[Offset];
        Offset++; 
        //Extension2
        gAudioSD_SAI_Extension2 =Indication_array[Offset];
        Offset++; 
        //Extension3
        gAudioSD_SAI_Extension3 =Indication_array[Offset];
        Offset++; 
        
        putvalue(env_ASG_AudioSD_SAI_AlertType,gAudioSD_SAI_AlertType);
        putvalue(env_ASG_AudioSD_SAI_AlertName,gAudioSD_SAI_AlertName);
        putvalue(env_ASG_AudioSD_SAI_StatName,gAudioSD_SAI_StationName);
        putvalue(env_ASG_AudioSD_SAI_SALref,gAudioSD_SAI_SALref);
        putvalue(env_ASG_AudioSD_SAI_Extension1,gAudioSD_SAI_Extension1);
        putvalue(env_ASG_AudioSD_SAI_Extension2,gAudioSD_SAI_Extension2);
        putvalue(env_ASG_AudioSD_SAI_Extension3,gAudioSD_SAI_Extension3);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SiriusAlertInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD SiriusAlertInfo_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_STS_get
{
}

void Station_Track_Switch_Request (byte request)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
	    requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_AudioSD;	            //LSG-ID
  	requestarray[1] =FctID_Station_Track_Switch;	    //Fct.-ID
  	requestarray[2] =request;                 //request type
	
    switch(request)
  	{
  		case DataGet_REQ:
  			set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  		default:	
  			writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Request: invalid request %d", request);
  		break;
  	}
}

void Station_Track_Switch_Indication (dword Indication_array [], int datalength)
{
  byte temp;
		
  switch (gBAP_Indication[2])
		{
			case Data_IND:      
        //get data
        temp = Indication_array[3];
  			gAudioSD_Station_Track_Switch_Event       = (temp & 0xF0)/0x10;
  			gAudioSD_Station_Track_Switch_Direction   = temp & 0x0F;
        temp = Indication_array[4];
        gAudioSD_Station_Track_Switch_PlayState   = (temp & 0xF0)/0x10;
        gAudioSD_Station_Track_Switch_Extension1  = temp & 0x0F;
        gAudioSD_Station_Track_Switch_Extension2  = Indication_array[5];
        gAudioSD_Station_Track_Switch_Extension3  = Indication_array[6];
        gAudioSD_Station_Track_Switch_Extension4  = Indication_array[7];
        gAudioSD_Station_Track_Switch_Extension5  = Indication_array[8];
        
        putvalue(env_ASG_AudioSD_STS_Event,gAudioSD_Station_Track_Switch_Event);
        putvalue(env_ASG_AudioSD_STS_Direction,gAudioSD_Station_Track_Switch_Direction);
        putvalue(env_ASG_AudioSD_STS_PlayState,gAudioSD_Station_Track_Switch_PlayState);
        putvalue(env_ASG_AudioSD_STS_Extension1,gAudioSD_Station_Track_Switch_Extension1);
        putvalue(env_ASG_AudioSD_STS_Extension2,gAudioSD_Station_Track_Switch_Extension2);
        putvalue(env_ASG_AudioSD_STS_Extension3,gAudioSD_Station_Track_Switch_Extension3);
        putvalue(env_ASG_AudioSD_STS_Extension4,gAudioSD_Station_Track_Switch_Extension4);
        putvalue(env_ASG_AudioSD_STS_Extension4,gAudioSD_Station_Track_Switch_Extension5);
      break;	
      case Error_IND:
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  		default:
  			writelineEx(gError_Trace, 0,"ASG-AudioSD Station_Track_Switch_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
		}
}

on envVar env_ASG_AudioSD_Pic_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
    gPicture_ASGID                  =getvalue(env_ASG_AudioSD_Pic_ASGID);
    gPicture_TAID                   =getvalue(env_ASG_AudioSD_Pic_TAID);;
    shift                           =getvalue(env_ASG_AudioSD_Pic_AH_shift);;
    direction                       =getvalue(env_ASG_AudioSD_Pic_AH_dir);;
    transmitpos                     =getvalue(env_ASG_AudioSD_Pic_AH_PosTrans);;
    indexsize                       =getvalue(env_ASG_AudioSD_Pic_AH_IS);;
    recordaddress                   =getvalue(env_ASG_AudioSD_Pic_AH_RA);;
    startelement                    =getvalue(env_ASG_AudioSD_Pic_AH_start);;
    elements                        =getvalue(env_ASG_AudioSD_Pic_AH_elements);;
    
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    //writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
    Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

on envVar env_ASG_AudioSD_Pic_OnOff
{
    int i =0, j =0;
    if(POWER_ON==gASG_PowerOnOff)
	{   
        if(getvalue(this))
        {
            gPicture_ListHandlingType      =AUDIO_PICTURE_BUILDUPCACHE;             //build-up complete cache...
            gPicture_cacheBuildUp          =AUDIO_PICTURE_BUILDUPCACHECACHE_WINDOW; //...and start with area "window"            
        
            Picture_ListHandling ();
        }
        else
        {
            gPicture_SlidingWindow_State   =AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE;
            gPicture_ListHandlingType      =AUDIO_PICTURE_NOCACHE;
            gPicture_cacheBuildUp          =AUDIO_PICTURE_BUILDUPCACHENOCACHE;
            gPicture_CallBackReason        =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;

            gPicture_cacheDown             =FALSE;
            gPicture_cacheUp               =FALSE;
            gPicture_LastFirstElement      =0;

            gPicture_recordaddress         =0;
            gPicture_transmitpos           =1;
            gPicture_CursorAction          =AUDIO_PICTURE_CURSORACTION_NOTHING;
            gPicture_DisplayStatus         =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;
            
            for(j=0; j<AUDIOSD_PICTURE_ENTRIES; j++)
            {     
                gPicture_Pos[j]                            =0;
                gPicture_Type[j]                           =0;
                gPicture_Handle[j]                         =0;
                gPicture_TcpPort[j]                        =0;
                gPicture_ListEntryReceptionInformation[j]  =0;

                for(i=0;i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++)
			            gPicture_IpAddress[j][i] =0;
                
                for(i=0;i<AUDIOSD_PICTURE_URI_LENGTH;i++)
			            gPicture_Uri[j][i] =0;
            }
            putvalue(env_ASG_AudioSD_Pic_Pos_0, 0);
            putvalue(env_ASG_AudioSD_Pic_Pos_1, 0);
            putvalue(env_ASG_AudioSD_Pic_Pos_2, 0);
    
            putvalue(env_ASG_AudioSD_Pic_PType_0, 0);
            putvalue(env_ASG_AudioSD_Pic_PType_1, 0);
            putvalue(env_ASG_AudioSD_Pic_PType_2, 0);

            putvalue(env_ASG_AudioSD_Pic_PType_s_0,empty_string);
            putvalue(env_ASG_AudioSD_Pic_PType_s_1,empty_string);
            putvalue(env_ASG_AudioSD_Pic_PType_s_2,empty_string);

            putvalue(env_ASG_AudioSD_Pic_Handle_0, 0);
            putvalue(env_ASG_AudioSD_Pic_Handle_1, 0);
            putvalue(env_ASG_AudioSD_Pic_Handle_2, 0);

            putvalue(env_ASG_AudioSD_Pic_IPv6_s_0, empty_string);
            putvalue(env_ASG_AudioSD_Pic_IPv6_s_1, empty_string);
            putvalue(env_ASG_AudioSD_Pic_IPv6_s_2, empty_string);
            
            putvalue(env_ASG_AudioSD_Pic_TCPport_0, 0);
            putvalue(env_ASG_AudioSD_Pic_TCPport_1, 0);
            putvalue(env_ASG_AudioSD_Pic_TCPport_2, 0);

            putvalue(env_ASG_AudioSD_Pic_URI_s_0, empty_string);
            putvalue(env_ASG_AudioSD_Pic_URI_s_1, empty_string);
            putvalue(env_ASG_AudioSD_Pic_URI_s_2, empty_string);            
        }
    }
}   

on envVar env_ASG_AudioSD_Pic_down
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gPicture_ListHandlingType ==AUDIO_PICTURE_NOCACHE)
	{      
        gPicture_CursorAction =AUDIO_PICTURE_CURSORACTION_DOWN;
        
        if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE)
        {   
            gPicture_ListHandlingType  =AUDIO_PICTURE_DOWN_CACHE;
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
            
            Picture_ListHandling ();
        }
        else if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE)
        {
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_SEARCH_ELEMENTS;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_DOWN;

            Picture_display();

            //reset values
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_REFRESH;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
        }
    }
}

on envVar env_ASG_AudioSD_Pic_up
{
    int i=0, j=0;

    if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gPicture_ListHandlingType ==AUDIO_PICTURE_NOCACHE)
	{   
        gPicture_CursorAction =AUDIO_PICTURE_CURSORACTION_UP;

        if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE)
        {  
            gPicture_ListHandlingType  =AUDIO_PICTURE_UP_CACHE;
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
            
            Picture_ListHandling ();
        }
        else if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE)
        {
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_SEARCH_ELEMENTS;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_UP;

            //Picture_ListHandling();
            
            Picture_display();

            //reset values
            gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_REFRESH;
            gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
        }    
    }
}

int Picture_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIOSD_PICTURE_ENTRIES) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIOSD_PICTURE_ENTRIES;i++)
                    {
                        if(gPicture_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIOSD_PICTURE_ENTRIES;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIOSD_PICTURE_ENTRIES;i++)
                    {
                        if(gPicture_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIOSD_PICTURE_ENTRIES;
                        }   
                    }
                }
        break;

        case AUDIO_PICTURE_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gPicture_ListEntryReceptionInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gPicture_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIOSD_PICTURE_ENTRIES-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIOSD_PICTURE_ENTRIES-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gPicture_ListEntryReceptionInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gPicture_ListEntryReceptionInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int Picture_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIOSD_PICTURE_ENTRIES-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_PICTURE_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIOSD_PICTURE_ENTRIES && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_PICTURE_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

void Picture_ListHandling () //for sliding window concept, list handling and 'build-up' list...
{
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, buffer_ReceptionInformation,
      buffer_Pos, buffer_PictureType;
    word requested_startelement, startelement, elements, buffer_Handle, buffer_TcpPort;
    char buffer_IPAddress[AUDIOSD_PICTURE_IPADDRESS_LENGTH], buffer_URI[AUDIOSD_PICTURE_URI_LENGTH];
    int i,j,k;
    
    // Init local variables. 
    mode                        =0;
    shift                       =0;
    direction                   =0;
    transmitpos                 =0;
    indexsize                   =0;
    recordaddress               =0;
    requested_startelement      =0;
    startelement                =0;
    elements                    =0;
    i                           =0;
    j                           =0;
    k                           =0;
    buffer_Pos                  =0;
    buffer_PictureType          =0;
    buffer_Handle               =0;
    buffer_ReceptionInformation =0;
    buffer_TcpPort              =0;
    
    /***build-up complete cache***/

    switch (gPicture_ListHandlingType)
    {
        case AUDIO_PICTURE_BUILDUPCACHE:
             
            switch (gPicture_cacheBuildUp)
            {   
                //cache-up  
                case AUDIO_PICTURE_BUILDUPCACHECACHE_UP:  
                    if(gPicture_CallBackReason !=AUDIO_PICTURE_BUILDUPCACHENOCACHE && gPicture_CallBackReason !=AUDIO_PICTURE_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gPicture_CallBackReason)
                        {
                            case AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE:

                                    if(gPicture_ListEntryReceptionInformation[2] ==TRUE) //cache-down required?
                                    {            
                                        gPicture_cacheBuildUp      =AUDIO_PICTURE_BUILDUPCACHECACHE_DOWN;      //next step: build-up upper cache
                                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_CACHENEXT;    
                                        
                                        
                                        Picture_ListHandling ();
                                    }
                                    else //stop caching
                                    {   
                                        gPicture_cacheBuildUp      =AUDIO_PICTURE_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                        gPicture_ListHandlingType  =AUDIO_PICTURE_NOCACHE;              
                                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK; 
                                        gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
                                        
                                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, empty_string);
                                        Picture_display();
                                    }
                            break;
                        }
                    }
                    else
                    {   
                        shift               =TRUE;
                        direction           =BACKWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3;
                
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gPicture_CallBackReason  =AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE;

                        Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache "window"
                case AUDIO_PICTURE_BUILDUPCACHECACHE_WINDOW: 
                    if(gPicture_CallBackReason !=AUDIO_PICTURE_BUILDUPCACHENOCACHE && gPicture_CallBackReason !=AUDIO_PICTURE_CALLBACKREASON_CACHENEXT)
                    {   
                        switch (gPicture_CallBackReason)
                        {
                            case AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE:
                                                 
                                    gPicture_cacheBuildUp      =AUDIO_PICTURE_BUILDUPCACHECACHE_UP;      //next step: build-up upper cache
                                    gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_CACHENEXT;    
                                    
                                    Picture_ListHandling ();
                            break;
                        }
                    }
                    else
                    { 
                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, "build-up list...");
                        shift               =FALSE;
                        direction           =FORWARD;
                        transmitpos         =FALSE;
                        indexsize           =FALSE;
                        recordaddress       =0;
                        startelement        =0;
                        elements            =3; 
    
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gPicture_CallBackReason  =AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE;
                        
                        Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;
                
                //cache-down
                case AUDIO_PICTURE_BUILDUPCACHECACHE_DOWN:
                    if(gPicture_CallBackReason !=AUDIO_PICTURE_BUILDUPCACHENOCACHE && gPicture_CallBackReason !=AUDIO_PICTURE_CALLBACKREASON_CACHENEXT)
                    {
                        switch (gPicture_CallBackReason)
                        {
                            case AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE:
                                    
                                    //stop caching
                                    gPicture_cacheBuildUp      =AUDIO_PICTURE_BUILDUPCACHENOCACHE;  //"build-up cache" finished
                                    gPicture_ListHandlingType  =AUDIO_PICTURE_NOCACHE;              
                                    gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;
                                    gPicture_CursorAction      =AUDIO_PICTURE_CURSORACTION_NOTHING;
                                    
                                    gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_REFRESH;
                                    
                                    //putvalue(env_ASG_AudioSD_Pic_ListOpState, empty_string);
                                    Picture_display();
                            break;
                        }
                    }
                    else
                    { 
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        for(i=0;i<AUDIOSD_PICTURE_ENTRIES; i++) //find last cached element
                        {   
                            if(gPicture_ListEntryReceptionInformation[i] ==FALSE) //abort loop
                                i =AUDIOSD_PICTURE_ENTRIES; 
                            else
                                startelement    =gPicture_Pos[i];
                        }
                        elements                =3;                         
        
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE;
                        
                        Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                    }
                break;

                default:
                break;
            }//build-up cache finished
        break;
        
        /********sliding-window********/
        case AUDIO_PICTURE_DOWN_CACHE: 
                    if (gPicture_CallBackReason ==AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gPicture_ListEntryReceptionInformation[5] ==0) //No valid data in last list pos -> last list element reached, start with element 0!  
                        {    
                            shift                   =FALSE;
                            direction               =FORWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //first element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                            
                            gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST; 
                            gPicture_cacheDown         =TRUE;

                            Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);    
                        }
                        else
                        {
                            gPicture_CallBackReason =AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST;
                            Picture_ListHandling(); 
                        }    
                    }
                    else if (gPicture_CallBackReason ==AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gPicture_ListHandlingType  =AUDIO_PICTURE_NOCACHE;
                        gPicture_cacheDown         =FALSE;
                        gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, empty_string);
                        Picture_display();
                        gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_REFRESH;
                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;
                    }
                    else
                    {   
                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, "list operating...");
                                
                        shift                   =TRUE;
                        direction               =FORWARD;
                        transmitpos             =FALSE;
                        indexsize               =FALSE;
                        recordaddress           =0;
                        startelement            =gPicture_Pos[5]; //last element
                        elements                =1;
                        
                        for(i=0;i<AUDIOSD_PICTURE_ENTRIES;i++)
                        {   
                            j =i+1;
                            
                            switch (i)
                            {   
                                case 0: 
                                    //buffer data of Pos '0' (local)
                                    buffer_Pos              =gPicture_Pos[i];
                                    buffer_PictureType      =gPicture_Type[i];
                                    buffer_Handle           =gPicture_Handle[i];
                                    buffer_TcpPort          =gPicture_TcpPort[i];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        buffer_IPAddress[k] =0;                                     

                                    for(k=0;k<strlen(gPicture_IpAddress[i]);k++) 
                                        buffer_IPAddress[k]=gPicture_IpAddress[i][k];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        buffer_URI[k] =0;                                     

                                    for(k=0;k<strlen(gPicture_Uri[i]);k++) 
                                        buffer_URI[k]=gPicture_Uri[i][k];

                                    //copy data from Pos '1' to Pos '0'
                                    gPicture_Pos[i]             =gPicture_Pos[j]; 
                                    gPicture_Type[i]       =gPicture_Type[j];
                                    gPicture_Handle[i]      =gPicture_Handle[j];
                                    gPicture_TcpPort[i] =gPicture_TcpPort[j];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0;                                     

                                    for(k=0;k<strlen(gPicture_IpAddress[j]);k++) 
                                        gPicture_IpAddress[i][k]=gPicture_IpAddress[j][k];

                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0;                                     

                                    for(k=0;k<strlen(gPicture_Uri[j]);k++) 
                                        gPicture_Uri[i][k]=gPicture_Uri[j][k];
                                break;
                            
                                case 5:
                                    //clear last element in list 
                                    gPicture_ListEntryReceptionInformation[i] =0;
                                    gPicture_Pos[i]                           =0;
                                    gPicture_Type[i]                          =0;
                                    gPicture_Handle[i]                    =0;
                                    gPicture_TcpPort[i]     =0;
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0;
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0;
                                break;
                            
                                case 8:
                                    //copy data from buffer in Pos '8'
                                    gPicture_Pos[i]                       =buffer_Pos; 
                                    gPicture_Type[i]                 =buffer_PictureType;
                                    gPicture_Handle[i]                =buffer_Handle;
                                    gPicture_TcpPort[i]             =buffer_TcpPort;
                                                                        
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_IPAddress);k++) 
                                        gPicture_IpAddress[i][k]=buffer_IPAddress[k];

                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_URI);k++) 
                                        gPicture_Uri[i][k]=buffer_URI[k];
                                break;
                                
                                default://other elements
                                    //copy element on other position
                                    gPicture_Pos[i]                       =gPicture_Pos[j]; 
                                    gPicture_Type[i]                 =gPicture_Type[j];
                                    gPicture_Handle[i]                =gPicture_Handle[j];
                                    gPicture_TcpPort[i]           =gPicture_TcpPort[j];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_IpAddress[j]);k++) 
                                        gPicture_IpAddress[i][k]=gPicture_IpAddress[j][k];
                                        
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_Uri[j]);k++) 
                                        gPicture_Uri[i][k]=gPicture_Uri[j][k]; 
                                 break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        case AUDIO_PICTURE_UP_CACHE: 
                    if (gPicture_CallBackReason ==AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE) //check if valid data received
                    {   
                        if(gPicture_ListEntryReceptionInformation[6] ==0) //No valid data in first list pos -> last list element reached, start with element 0!  
                        {
                            shift                   =TRUE;
                            direction               =BACKWARD;
                            transmitpos             =FALSE;
                            indexsize               =FALSE;
                            recordaddress           =0;
                            startelement            =0; //Last element
                            elements                =1;        
                            
                            requested_startelement  =startelement;
                            mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                            gPicture_cacheUp        =TRUE;
                            gPicture_CallBackReason =AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST;
                            
                            Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
                        }
                        else
                        {
                            gPicture_CallBackReason =AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST;
                            Picture_ListHandling();
                        }           
                    }

                    else if (gPicture_CallBackReason ==AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST)
                    {   
                        gPicture_ListHandlingType  =AUDIO_PICTURE_NOCACHE;
                        gPicture_cacheUp           =FALSE;
                        gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;
                        
                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, empty_string);
                        Picture_display();
                        gPicture_DisplayStatus     =AUDIO_PICTURE_DISPLAYLIST_REFRESH;
                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;
                    }

                    else
                    {           
                        //putvalue(env_ASG_AudioSD_Pic_ListOpState, "list operating...");

                        shift                   =TRUE;
                        direction               =BACKWARD;
                        transmitpos             =FALSE;
                        indexsize               =TRUE;
                        recordaddress           =0;
                        startelement            =gPicture_Pos[6]; //first element
                        elements                =1;
                    
                        for(i=AUDIOSD_PICTURE_ENTRIES-1;i>=0;i--)
                        {  
                            j =i-1;
                            switch (i)
                            {   
                                case 8: 
                                    //buffer data of Pos '8' (local)
                                    buffer_Pos              =gPicture_Pos[i];
                                    buffer_PictureType      =gPicture_Type[i];
                                    buffer_Handle           =gPicture_Handle[i];
                                    buffer_TcpPort          =gPicture_TcpPort[i];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        buffer_IPAddress[k] =0;                                     

                                    for(k=0;k<strlen(gPicture_IpAddress[i]);k++) 
                                        buffer_IPAddress[k]=gPicture_IpAddress[i][k];

                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        buffer_URI[k] =0;                                     

                                    for(k=0;k<strlen(gPicture_Uri[i]);k++) 
                                        buffer_URI[k]=gPicture_Uri[i][k];
                                    
                                    
                                    //copy data from Pos '7' to Pos '8'
                                    gPicture_Pos[i]                       =gPicture_Pos[j]; 
                                    gPicture_Type[i]                 =gPicture_Type[j];
                                    gPicture_Handle[i]                =gPicture_Handle[j];
                                    gPicture_TcpPort[i]           =gPicture_TcpPort[j];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_IpAddress[j]);k++) 
                                        gPicture_IpAddress[i][k]=gPicture_IpAddress[j][k];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_Uri[j]);k++) 
                                        gPicture_Uri[i][k]=gPicture_Uri[j][k]; 
                                    
                                break;
                            
                                case 6: 
                                    //clear first element in list 
                                    gPicture_ListEntryReceptionInformation[i] =0;
                                    gPicture_Pos[i]                           =0;
                                    gPicture_Type[i]                          =0;
                                    gPicture_Handle[i]                    =0;
                                    gPicture_TcpPort[i]     =0;
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0;
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0;                                       
                                break;
                            
                                case 0: 
                                    //copy data from buffer in Pos '0'
                                    gPicture_Pos[i]                       =buffer_Pos; 
                                    gPicture_Type[i]                      =buffer_PictureType;
                                    gPicture_Handle[i]                =buffer_Handle;
                                    gPicture_TcpPort[i]               =buffer_TcpPort;
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_IPAddress);k++) 
                                        gPicture_IpAddress[i][k]=buffer_IPAddress[k];

                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0; 
                                    
                                    for(k=0;k<strlen(buffer_URI);k++) 
                                        gPicture_Uri[i][k]=buffer_URI[k];
                                break;
                                
                                default: //other elements
                                    //copy element on other position
                                    gPicture_Pos[i]                       =gPicture_Pos[j]; 
                                    gPicture_Type[i]                 =gPicture_Type[j];
                                    gPicture_Handle[i]                =gPicture_Handle[j];
                                    gPicture_TcpPort[i]               =gPicture_TcpPort[j];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_IPADDRESS_LENGTH;k++) //clear string
                                        gPicture_IpAddress[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_IpAddress[j]);k++) 
                                        gPicture_IpAddress[i][k]=gPicture_IpAddress[j][k];
                                    
                                    for (k=0; k<AUDIOSD_PICTURE_URI_LENGTH;k++) //clear string
                                        gPicture_Uri[i][k] =0; 
                                    
                                    for(k=0;k<strlen(gPicture_Uri[j]);k++) 
                                        gPicture_Uri[i][k]=gPicture_Uri[j][k];
                                break;
                            } // end of switch 'i'
                        }
                        requested_startelement  =startelement;
                        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                        Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);                        
                        
                        //to check, if valid data received
                        gPicture_CallBackReason    =AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE;
                    }
        break;

        default:
        break;
    } //end of switch 'type of cache handling' 
}

void Picture_display()
{   
    int Element_1 =0, Element_2 =1, Element_3 =2;

    if(POWER_ON==gASG_PowerOnOff && getvalue(env_ASG_AudioSD_Pic_OnOff))
	{   
        /******'sliding window' not active******/         
        if(gPicture_DisplayStatus ==AUDIO_PICTURE_DISPLAYLIST_SEARCH_ELEMENTS)
        {
            //1. Element              
            if(gPicture_CursorAction ==AUDIO_PICTURE_CURSORACTION_DOWN)
                Element_1 =Picture_GetNextCachedElement(gPicture_LastFirstElement, AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            else if(gPicture_CursorAction ==AUDIO_PICTURE_CURSORACTION_UP)            
                Element_1 =Picture_GetNextCachedElement(gPicture_LastFirstElement, AUDIO_PICTURE_DISPLAYLIST_FIND_PREVIUOS_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_Pic_Pos_0, gPicture_Pos[Element_1]);               
            
            //PictureType
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_Pic_PType_0, gPicture_Type[Element_1]);

                if(gPicture_Type[Element_1] <0x06)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_0,gPicture_Type_s[gPicture_Type[Element_1]]);
                else if (gPicture_Type[Element_1] == 0xFF)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_reserved);
            }

            //Handle
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_Handle_0,gPicture_Handle[Element_1]);
            
            //IPv6 address
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_IPv6_s_0,gPicture_IpAddress[Element_1]);
            
            //TCP Port
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_TCPport_0,gPicture_TcpPort[Element_1]);
            
            //URI
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_URI_s_0,gPicture_Uri[Element_1]);
                
            gPicture_LastFirstElement =Element_1;
            
            
            //2. Element             
            Element_2 =Picture_GetNextCachedElement(Element_1, AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT);
            
            //Pos
            putvalue(env_ASG_AudioSD_Pic_Pos_1, gPicture_Pos[Element_2]);               
            
            //PictureType
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_Pic_PType_1, gPicture_Type[Element_2]);

                if(gPicture_Type[Element_2] <0x06)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_1,gPicture_Type_s[gPicture_Type[Element_2]]);
                else if (gPicture_Type[Element_2] == 0xFF)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_reserved);
            }

            //Handle
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_Handle_1,gPicture_Handle[Element_2]);
            
            //IPv6 address
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_IPv6_s_1,gPicture_IpAddress[Element_2]);
            
            //TCP Port
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_TCPport_1,gPicture_TcpPort[Element_2]);
            
            //URI
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_URI_s_1,gPicture_Uri[Element_2]);
            
            //3. Element          
            Element_3 =Picture_GetNextCachedElement(Element_2, AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT);

            //Pos
            putvalue(env_ASG_AudioSD_Pic_Pos_2, gPicture_Pos[Element_3]);               
            
            //PictureType
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
            {
                putvalue(env_ASG_AudioSD_Pic_PType_2, gPicture_Type[Element_3]);

                if(gPicture_Type[Element_3] <0x06)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_2,gPicture_Type_s[gPicture_Type[Element_3]]);
                else if (gPicture_Type[Element_3] == 0xFF)
                    putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_unknown);
                else
                    putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_reserved);
            }

            //Handle
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_Handle_2,gPicture_Handle[Element_3]);
            
            //IPv6 address
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_IPv6_s_2,gPicture_IpAddress[Element_3]);
            
            //TCP Port
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_TCPport_2,gPicture_TcpPort[Element_3]);
            
            //URI
            if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                putvalue(env_ASG_AudioSD_Pic_URI_s_2,gPicture_Uri[Element_3]);
        }

        /******'sliding Window' active or 'build-up List'******/
        else if(gPicture_DisplayStatus ==AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS) 
        {
            //1. Element    
            if(gPicture_ListEntryReceptionInformation [0] ==TRUE && getvalue(env_ASG_AudioSD_Pic_OnOff))
            {   
                Element_1 =0;
                
                //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_0, gPicture_Pos[Element_1]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_0, gPicture_Type[Element_1]);

                    if(gPicture_Type[Element_1] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_0,gPicture_Type_s[gPicture_Type[Element_1]]);
                    else if (gPicture_Type[Element_1] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_0,gPicture_Handle[Element_1]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_0,gPicture_IpAddress[Element_1]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_0,gPicture_TcpPort[Element_1]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_0,gPicture_Uri[Element_1]);
            }
            
            //2. Element    
            if(gPicture_ListEntryReceptionInformation [1] ==TRUE && getvalue(env_ASG_AudioSD_Pic_OnOff))
            {
                Element_2 =1;
                //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_1, gPicture_Pos[Element_2]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_1, gPicture_Type[Element_2]);

                    if(gPicture_Type[Element_2] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_1,gPicture_Type_s[gPicture_Type[Element_2]]);
                    else if (gPicture_Type[Element_2] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_1,gPicture_Handle[Element_2]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_1,gPicture_IpAddress[Element_2]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_1,gPicture_TcpPort[Element_2]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_1,gPicture_Uri[Element_2]);
            }
             //3. Element    
            if(gPicture_ListEntryReceptionInformation [2] ==TRUE && getvalue(env_ASG_AudioSD_Pic_OnOff))
            {
             Element_3 =2;
             //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_2, gPicture_Pos[Element_3]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_2, gPicture_Type[Element_3]);

                    if(gPicture_Type[Element_3] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_2,gPicture_Type_s[gPicture_Type[Element_3]]);
                    else if (gPicture_Type[Element_3] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_2,gPicture_Handle[Element_3]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_2,gPicture_IpAddress[Element_3]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_2,gPicture_TcpPort[Element_3]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_2,gPicture_Uri[Element_3]);
            }
        }
        else if (gPicture_DisplayStatus ==AUDIO_PICTURE_DISPLAYLIST_REFRESH)
        {               
            //1. Element
            if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE)
                Element_1 =gPicture_LastFirstElement; 
            else
                Element_1 =0;

            if(gPicture_ListEntryReceptionInformation[Element_1])
            {
                //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_0, gPicture_Pos[Element_1]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_0, gPicture_Type[Element_1]);

                    if(gPicture_Type[Element_1] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_0,gPicture_Type_s[gPicture_Type[Element_1]]);
                    else if (gPicture_Type[Element_1] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_0,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_0,gPicture_Handle[Element_1]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_0,gPicture_IpAddress[Element_1]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_0,gPicture_TcpPort[Element_1]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_0,gPicture_Uri[Element_1]);
            }
            //2. Element             
            if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE)
                Element_2 =Picture_GetNextCachedElement(Element_1, AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_2 =1;

            if(gPicture_ListEntryReceptionInformation[Element_2])
            {
                //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_1, gPicture_Pos[Element_2]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_1, gPicture_Type[Element_2]);

                    if(gPicture_Type[Element_2] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_1,gPicture_Type_s[gPicture_Type[Element_2]]);
                    else if (gPicture_Type[Element_2] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_1,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_1,gPicture_Handle[Element_2]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_1,gPicture_IpAddress[Element_2]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_1,gPicture_TcpPort[Element_2]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_1,gPicture_Uri[Element_2]);
            }
            //3. Element          
            if(gPicture_SlidingWindow_State ==AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE)
                Element_3 =Picture_GetNextCachedElement(Element_2, AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT);
            else
                Element_3 =2;

            if(gPicture_ListEntryReceptionInformation[Element_3])
            {    
                //Pos
                putvalue(env_ASG_AudioSD_Pic_Pos_2, gPicture_Pos[Element_3]);               
                
                //PictureType
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1) 
                {
                    putvalue(env_ASG_AudioSD_Pic_PType_2, gPicture_Type[Element_3]);

                    if(gPicture_Type[Element_3] <0x06)
                        putvalue(env_ASG_AudioSD_Pic_PType_s_2,gPicture_Type_s[gPicture_Type[Element_3]]);
                    else if (gPicture_Type[Element_3] == 0xFF)
                      putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_unknown);
                    else
                        putvalue(env_ASG_AudioSD_Pic_PType_s_2,gstring_reserved);
                }

                //Handle
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_Handle_2,gPicture_Handle[Element_3]);
                
                //IPv6 address
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_IPv6_s_2,gPicture_IpAddress[Element_3]);
                
                //TCP Port
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_TCPport_2,gPicture_TcpPort[Element_3]);
                
                //URI
                if (gPicture_recordaddress ==0 || gPicture_recordaddress ==1)
                    putvalue(env_ASG_AudioSD_Pic_URI_s_2,gPicture_Uri[Element_3]);
            }
        }
    }
}

void Picture_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_Picture;	//Fct.-ID
	requestarray[2] =request;           //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gPicture_ASGID *0x10) &0xF0) +(gPicture_TAID &0x0F);      
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0x00FF;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
        Offset++;  
        requestarray[Offset] =elements &0x00FF;
        Offset++;
        requestarray[Offset] =(elements &0xFF00) /0x100;
        Offset++;       
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Request_Picture: invalid request %d", request);
		break;
  }
}

void Picture_Indication(dword Indication_array [], int datalength)
{
  byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
  word startelement, elements, current_element;
  int i =0, j=0, Offset =0;
  
  // Init local variables
  mode                    =0;
  direction               =0;
  shift                   =0;
  recordaddress           =0;
  startelement            =0;
  elements                =0;
  current_element         =0;
  transmitpos             =0;
  length                  =0;
  CacheElements =FALSE;
  
  write("Debug: Indication_Picture -> ind-type=%d",gBAP_Indication[2]);
  
	switch (gBAP_Indication[2])
	{
		case Data_IND:
		//get data
      gPicture_ASGID =(Indication_array[3] &0xF0) /0x10;
      gPicture_TAID  =Indication_array[3] &0x0F; 
      gPicture_TotalNumListElements =Indication_array[4];
      /***ArrayHeader***/
      mode            =(Indication_array[5] &0xF0) /0x10;
      recordaddress   =Indication_array[5] &0x0F;
      startelement    =Indication_array[6];
      elements        =Indication_array[7];
      Offset =8;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;             
 
      if(startelement !=0)
      {
        for (i=0;i<AUDIOSD_PICTURE_ENTRIES;i++)
        {
          if(startelement ==gPicture_Pos[i])  
            i =AUDIOSD_PICTURE_ENTRIES;              
        }
      }
      switch (recordaddress)
      { 
        case 0: //recordaddress =0 -> complete record
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }       
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }    
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =0 ends
        case 1: //recordaddress =1 -> PicType, Handle, IPV6_Address, TCP_Port, URI
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }       
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }    
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
      }                             
      //Panel
      putvalue(env_ASG_AudioSD_Pic_ASGID, gPicture_ASGID);
      putvalue(env_ASG_AudioSD_Pic_TAID, gPicture_TAID);
      putvalue(env_ASG_AudioSD_Pic_TotalNumLE, gPicture_TotalNumListElements);
      
      /*
      if (gPicture_CallBackReason !=AUDIOSD_PICTURE_CALLBACKREASON_NOCALLBACK)
        Picture_ListHandling ();
      else
        Picture_display(recordaddress, transmitpos);         
      */
		break;
    case Changed_IND:
      //get data
      /***ArrayHeader***/
      mode            =(Indication_array[3] &0xF0) /0x10;
      recordaddress   =Indication_array[3] &0x0F;
      Offset =4;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;               
      if (indexsize)
      {   
        startelement =Indication_array[Offset];
        Offset++;
        startelement +=(Indication_array[Offset] *0x100);
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
        elements +=(Indication_array[Offset] *0x100);
        Offset++;
      }
      else
      {   
        startelement =Indication_array[Offset];
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
      }           
      if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
      {
        /*
        putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
        putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
        */
      }
      else if (datalength>9)
      {
        if(startelement !=0)
        {
          for (i=0;i<AUDIOSD_PICTURE_ENTRIES;i++)
          {
            if(startelement ==gPicture_Pos[i])  
              i =AUDIOSD_PICTURE_ENTRIES;              
          }
        }
        switch (recordaddress)
        {  
          case 0: //recordaddress =0 -> complete record
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;             
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
   
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }       
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element  
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  			    	{
                current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    } 
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }    
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                                  
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element    
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;         
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =0 ends
          case 1: //recordaddress =1 -> PictureType, Handle, IPV6_Address, TCP_Port, URI
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;             
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
   
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }       
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element  
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  			    	{
                current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    } 
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }    
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                                  
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element    
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;         
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIOSD_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIOSD_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =1 ends
          case 15: //recordaddress =15 -> POS 
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element       
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
      		    {
                current_element =AUDIOSD_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement;
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element++; //go on with next element       
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIOSD_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryReceptionInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =15 ends    
        }
      }
    break;            
    case Error_IND:	
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Indication_Picture: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Indication_Picture: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Indication_Picture: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD Indication_Picture: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD Indication_Picture: unknown indication %x", gBAP_Indication[2]);
		break;
	}  
  //for "sliding window concept"
  /*  
  if(gPicture_TotalNumListElements<=AUDIOSD_PICTURE_ENTRIES)
        gPicture_SlidingWindow_State =AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE;
    else
        gPicture_SlidingWindow_State =AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE;

    if (gPicture_CallBackReason !=AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK)
    {
      write("Pic: handling");  
      Picture_ListHandling ();
    }
    else
    {
      write("Pic: display");
      Picture_display();
    }
  */
}

on envVar env_ASG_AudioSD_LSL_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
    gLSL_ASGID                  =getvalue(env_ASG_AudioSD_LSL_ASGID);
    gLSL_TAID                   =getvalue(env_ASG_AudioSD_LSL_TAID);;
    shift                           =getvalue(env_ASG_AudioSD_LSL_AH_shift);;
    direction                       =getvalue(env_ASG_AudioSD_LSL_AH_dir);;
    transmitpos                     =getvalue(env_ASG_AudioSD_LSL_AH_PosTrans);;
    indexsize                       =getvalue(env_ASG_AudioSD_LSL_AH_IS);;
    recordaddress                   =getvalue(env_ASG_AudioSD_LSL_AH_RA);;
    startelement                    =getvalue(env_ASG_AudioSD_LSL_AH_start);;
    elements                        =getvalue(env_ASG_AudioSD_LSL_AH_elements);;
    
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    //writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
    LastStationList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void LastStationList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_LastStationList;	//Fct.-ID
	requestarray[2] =request;           //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gLSL_ASGID *0x10) &0xF0) +(gLSL_TAID &0x0F);      
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0x00FF;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
        Offset++;  
        requestarray[Offset] =elements &0x00FF;
        Offset++;
        requestarray[Offset] =(elements &0xFF00) /0x100;
        Offset++;       
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Picture: invalid request %d", request);
		break;
  }
}

void LastStationList_Indication(dword Indication_array [], int datalength)
{
  byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
  word startelement, elements, current_element;
  int i =0, j=0, Offset =0;
  
  // Init local variables
  mode                    =0;
  direction               =0;
  shift                   =0;
  recordaddress           =0;
  startelement            =0;
  elements                =0;
  current_element         =0;
  transmitpos             =0;
  length                  =0;
  CacheElements =FALSE;
  
  write("Debug: LastStationList_Indication -> ind-type=%d",gBAP_Indication[2]);
  
	switch (gBAP_Indication[2])
	{
		case Data_IND:
		//get data
      gLSL_ASGID =(Indication_array[3] &0xF0) /0x10;
      gLSL_TAID  =Indication_array[3] &0x0F; 
      gLSL_TotalNumListElements =Indication_array[4];
      /***ArrayHeader***/
      mode            =(Indication_array[5] &0xF0) /0x10;
      recordaddress   =Indication_array[5] &0x0F;
      startelement    =Indication_array[6];
      elements        =Indication_array[7];
      Offset =8;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;             
 
      if(startelement !=0)
      {
        for (i=0;i<AUDIO_LSL_ASGCACHE_MAX_SIZE;i++)
        {
          if(startelement ==gLSL_Pos[i])  
            i =AUDIO_LSL_ASGCACHE_MAX_SIZE;              
        }
      }
      switch (recordaddress)
      { 
        case 1: //recordaddress =1 -> PresetIndex, Waveband, Attributes, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 2: //recordaddress =2 -> PresetIndex, Waveband, Name
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =2 ends
        case 3: //recordaddress =3 -> PresetIndex, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =3 ends  
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
      }                             
      //Panel
      putvalue(env_ASG_AudioSD_LSL_ASGID, gLSL_ASGID);
      putvalue(env_ASG_AudioSD_LSL_TAID, gLSL_TAID);
      putvalue(env_ASG_AudioSD_LSL_TotalNumLE, gLSL_TotalNumListElements);
      
      /*
      if (gLSL_CallBackReason !=AUDIO_LSL_CALLBACKREASON_NOCALLBACK)
        LSL_ListHandling ();
      else
        LSL_display(recordaddress, transmitpos);         
      */
		break;
    case Changed_IND:
      //get data
      /***ArrayHeader***/
      mode            =(Indication_array[3] &0xF0) /0x10;
      recordaddress   =Indication_array[3] &0x0F;
      Offset =4;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;               
      if (indexsize)
      {   
        startelement =Indication_array[Offset];
        Offset++;
        startelement +=(Indication_array[Offset] *0x100);
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
        elements +=(Indication_array[Offset] *0x100);
        Offset++;
      }
      else
      {   
        startelement =Indication_array[Offset];
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
      }           
      if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
      {
        /*
        putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
        putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
        */
      }
      else if (datalength>9)
      {
        if(startelement !=0)
        {
          for (i=0;i<AUDIO_LSL_ASGCACHE_MAX_SIZE;i++)
          {
            if(startelement ==gLSL_Pos[i])  
              i =AUDIO_LSL_ASGCACHE_MAX_SIZE;              
          }
        }
        switch (recordaddress)
        {  
          case 1: //recordaddress =1 -> PresetIndex, Waveband, Attributes, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gLSL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                LastStationList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 2: //recordaddress =2 -> PresetIndex, Waveband, Name
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gLSL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =2 ends
        case 3: //recordaddress =3 -> PresetIndex, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //AUDIO_LSL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gLSL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_LSL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_LSL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gLSL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gLSL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =3 ends  
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIO_LSL_ASGCACHE_MAX_SIZE-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_LSL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gLSL_Pos[i] && gLSL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gLSL_ListHandlingType !=AUDIO_LSL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gLSL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gLSL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
        }
      }
    break;            
    case Error_IND:	
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD LastStationList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}  
}

void LastStationList_GetAttributesBits(word current_element)
{
  gLSL_Attributes_Bit0[current_element]   =gLSL_Attributes[current_element] & 0x0001;
  gLSL_Attributes_Bit1[current_element]   =gLSL_Attributes[current_element] & 0x0002 / 0x0002;
  gLSL_Attributes_Bit2[current_element]   =gLSL_Attributes[current_element] & 0x0004 / 0x0004;
  gLSL_Attributes_Bit3[current_element]   =gLSL_Attributes[current_element] & 0x0008 / 0x0008;
  gLSL_Attributes_Bit4[current_element]   =gLSL_Attributes[current_element] & 0x0010 / 0x0010;
  gLSL_Attributes_Bit5[current_element]   =gLSL_Attributes[current_element] & 0x0020 / 0x0020;
  gLSL_Attributes_Bit6[current_element]   =gLSL_Attributes[current_element] & 0x0040 / 0x0040;
  gLSL_Attributes_Bit7[current_element]   =gLSL_Attributes[current_element] & 0x0080 / 0x0080;
  gLSL_Attributes_Bit8[current_element]   =gLSL_Attributes[current_element] & 0x0100 / 0x0100;
  gLSL_Attributes_Bit9[current_element]   =gLSL_Attributes[current_element] & 0x0200 / 0x0200;
  gLSL_Attributes_Bit10[current_element]  =gLSL_Attributes[current_element] & 0x0400 / 0x0400;
  gLSL_Attributes_Bit11[current_element]  =gLSL_Attributes[current_element] & 0x0800 / 0x0800;
}

on envVar env_ASG_AudioSD_FL_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
    gFL_ASGID                  =getvalue(env_ASG_AudioSD_FL_ASGID);
    gFL_TAID                   =getvalue(env_ASG_AudioSD_FL_TAID);;
    shift                           =getvalue(env_ASG_AudioSD_FL_AH_shift);;
    direction                       =getvalue(env_ASG_AudioSD_FL_AH_dir);;
    transmitpos                     =getvalue(env_ASG_AudioSD_FL_AH_PosTrans);;
    indexsize                       =getvalue(env_ASG_AudioSD_FL_AH_IS);;
    recordaddress                   =getvalue(env_ASG_AudioSD_FL_AH_RA);;
    startelement                    =getvalue(env_ASG_AudioSD_FL_AH_start);;
    elements                        =getvalue(env_ASG_AudioSD_FL_AH_elements);;
    
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    //writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
    FavoriteList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void FavoriteList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_FavoriteList;	//Fct.-ID
	requestarray[2] =request;           //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gFL_ASGID *0x10) &0xF0) +(gFL_TAID &0x0F);      
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0x00FF;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
        Offset++;  
        requestarray[Offset] =elements &0x00FF;
        Offset++;
        requestarray[Offset] =(elements &0xFF00) /0x100;
        Offset++;       
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FavoriteList_Picture: invalid request %d", request);
		break;
  }
}

void FavoriteList_Indication(dword Indication_array [], int datalength)
{
  byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
  word startelement, elements, current_element;
  int i =0, j=0, Offset =0;
  
  // Init local variables
  mode                    =0;
  direction               =0;
  shift                   =0;
  recordaddress           =0;
  startelement            =0;
  elements                =0;
  current_element         =0;
  transmitpos             =0;
  length                  =0;
  CacheElements =FALSE;
  
  write("Debug: FavoriteList_Indication -> ind-type=%d",gBAP_Indication[2]);
  
	switch (gBAP_Indication[2])
	{
		case Data_IND:
		//get data
      gFL_ASGID =(Indication_array[3] &0xF0) /0x10;
      gFL_TAID  =Indication_array[3] &0x0F; 
      gFL_TotalNumListElements =Indication_array[4];
      /***ArrayHeader***/
      mode            =(Indication_array[5] &0xF0) /0x10;
      recordaddress   =Indication_array[5] &0x0F;
      startelement    =Indication_array[6];
      elements        =Indication_array[7];
      Offset =8;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;             
 
      if(startelement !=0)
      {
        for (i=0;i<AUDIO_FL_ASGCACHE_MAX_SIZE;i++)
        {
          if(startelement ==gFL_Pos[i])  
            i =AUDIO_FL_ASGCACHE_MAX_SIZE;              
        }
      }
      switch (recordaddress)
      { 
        case 1: //recordaddress =1 -> PresetIndex, Waveband, Attributes, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 2: //recordaddress =2 -> PresetIndex, Waveband, Name
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =2 ends
        case 3: //recordaddress =3 -> PresetIndex, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =3 ends  
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
      }                             
      //Panel
      putvalue(env_ASG_AudioSD_FL_ASGID, gFL_ASGID);
      putvalue(env_ASG_AudioSD_FL_TAID, gFL_TAID);
      putvalue(env_ASG_AudioSD_FL_TotalNumLE, gFL_TotalNumListElements);
      
      /*
      if (gFL_CallBackReason !=AUDIO_FL_CALLBACKREASON_NOCALLBACK)
        FL_ListHandling ();
      else
        FL_display(recordaddress, transmitpos);         
      */
		break;
    case Changed_IND:
      //get data
      /***ArrayHeader***/
      mode            =(Indication_array[3] &0xF0) /0x10;
      recordaddress   =Indication_array[3] &0x0F;
      Offset =4;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;               
      if (indexsize)
      {   
        startelement =Indication_array[Offset];
        Offset++;
        startelement +=(Indication_array[Offset] *0x100);
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
        elements +=(Indication_array[Offset] *0x100);
        Offset++;
      }
      else
      {   
        startelement =Indication_array[Offset];
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
      }           
      if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
      {
        /*
        putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
        putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
        */
      }
      else if (datalength>9)
      {
        if(startelement !=0)
        {
          for (i=0;i<AUDIO_FL_ASGCACHE_MAX_SIZE;i++)
          {
            if(startelement ==gFL_Pos[i])  
              i =AUDIO_FL_ASGCACHE_MAX_SIZE;              
          }
        }
        switch (recordaddress)
        {  
          case 1: //recordaddress =1 -> PresetIndex, Waveband, Attributes, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Attributes
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gFL_Attributes[current_element] +=Indication_array[Offset] *0x100;
                Offset++;
                FavoriteList_GetAttributesBits(current_element);
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 2: //recordaddress =2 -> PresetIndex, Waveband, Name
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Waveband
                if (CacheElements ==TRUE)
                  gFL_Waveband[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =2 ends
        case 3: //recordaddress =3 -> PresetIndex, Name, Frequency
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //AUDIO_FL_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PresetIndex
                if (CacheElements ==TRUE)
                  gFL_PresetIndex[current_element] =Indication_array[Offset];
                Offset++;
                //Name
                for(i=0; i<AUDIO_FL_NAME_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Name[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Name[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //Frequency
                for(i=0; i<AUDIO_FL_FREQUENCY_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gFL_Frequency[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gFL_Frequency[current_element][i] =Indication_array[Offset];
                  Offset++;
                }   
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =3 ends  
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIO_FL_ASGCACHE_MAX_SIZE-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_FL_ASGCACHE_MAX_SIZE; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gFL_Pos[i] && gFL_ListEntryReceptionInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gFL_ListHandlingType !=AUDIO_FL_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gFL_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gFL_ListEntryReceptionInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
        }
      }
    break;            
    case Error_IND:	
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD LastStationList_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD LastStationList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}  
}

void FavoriteList_GetAttributesBits(word current_element)
{
  gFL_Attributes_Bit0[current_element]   =gFL_Attributes[current_element] & 0x0001;
  gFL_Attributes_Bit1[current_element]   =gFL_Attributes[current_element] & 0x0002 / 0x0002;
  gFL_Attributes_Bit2[current_element]   =gFL_Attributes[current_element] & 0x0004 / 0x0004;
  gFL_Attributes_Bit3[current_element]   =gFL_Attributes[current_element] & 0x0008 / 0x0008;
  gFL_Attributes_Bit4[current_element]   =gFL_Attributes[current_element] & 0x0010 / 0x0010;
  gFL_Attributes_Bit5[current_element]   =gFL_Attributes[current_element] & 0x0020 / 0x0020;
  gFL_Attributes_Bit6[current_element]   =gFL_Attributes[current_element] & 0x0040 / 0x0040;
  gFL_Attributes_Bit7[current_element]   =gFL_Attributes[current_element] & 0x0080 / 0x0080;
  gFL_Attributes_Bit8[current_element]   =gFL_Attributes[current_element] & 0x0100 / 0x0100;
  gFL_Attributes_Bit9[current_element]   =gFL_Attributes[current_element] & 0x0200 / 0x0200;
  gFL_Attributes_Bit10[current_element]  =gFL_Attributes[current_element] & 0x0400 / 0x0400;
  gFL_Attributes_Bit11[current_element]  =gFL_Attributes[current_element] & 0x0800 / 0x0800;
}
