/*@!Encoding:1252*/
/**************************CAPL-File for DoIP-Test-Node***************************
**************************CAPL-Script for DoIP-Test-Node**************************
*********************originally designed by Team DFF ETH BBU**********************
*********************************Robert Gogne*************************************
****************************Rev. 1.0 , 10.07.2019*********************************
**/
includes
{
  #include "DoIP_Testnode1_Sockets.cin"    //TCP- and UDP-Sockets and their Handling-Functions used for DoIP
}

variables
{
/*********************** Variables used for controlling the script ***********************/  
  
/**This enumeration defines the operating-state of this CAPL-Node. It is used to indicate, if the script 
***needs to initialize something and thus the inputs from the control-panels are locked.
***Available values:
DoIP_nNodeControlStateLOCK     Initializing - Inputs from control-panel are locked
DoIP_nNodeControlStateUNLOCK   Running - Inputs from control-panel are unlocked
**/ 
enum DoIP_tenNodeControlState {DoIP_nNodeControlStateLOCK = 0, DoIP_nNodeControlStateUNLOCK = 1};
enum DoIP_tenNodeControlState DoIP_enNodeControlState = DoIP_nNodeControlStateLOCK; //Instantiation of this enum

/**This enumeration defines symbols for the text-colors used for text porinted in the output-box of the panel
**/
enum DoIP_tenOutputTextType {DoIP_nOutputTextTypeINFO, DoIP_nOutputTextTypeWARNING, DoIP_nOutputTextTypeERROR};

/**Marker to indicate an Error occurring during initialization of the script (0 = No error, 1 = error-occurred)
**/
byte DoIP_bInitErrorOccurred; 

/********************** Variables used for <DoIP Message Composer> **********************/

/**Buffer used for the DoIP-Message (Generic-Header + Payload), which should be sent.
**The size is calculated to 10012 Bytes, because biggest message predicted to be sent is 
a DiagMessage with 8 Bytes GenericHeader + 4 Bytes for SA and TA + 10000Bytes Payload)
**/
byte DoIP_abMsgTxBuf[10012];  

/**Buffer used for TCP-Messages, which should be received.
**The size is 100 bytes, because we need only to receive smaller messages.
**/
byte DoIP_acMsgRxBuf[100];
                                
/**This struct represents the data of the Generic Header of a DoIP-Message.
**/
struct DoIP_tstGenHeader{
  byte bProtocolVer;      //Byte 0 of the Generic-Header 'Protocol Version'
  byte bInvProtocolVer;   //Byte 1 of the Generic-Header 'Inverse Protocol Version'
  word wPayloadType;      //Byte 2..3 of the Generic-Header 'Payload Type'
  dword dwpayloadLen;     //Byte 4..7 of the Generic Header 'Payload Length'
}stDoIPGenHeader;

/**This enumeration defines symbolic values for DoIP-Message-Types by the means of ISO13400-2. 
**/
enum DoIP_tenMsgTypes {DoIP_nMsgTypeGHNACK = 0x0000,        //GenericDoIPHeaderNegativeAcknowledge
                       DoIP_nMsgTypeVIDREQ = 0x0001,        //VehicleIdentificationRequestMessage
                       DoIP_nMsgTypeVIDREQEID = 0x0002,     //VehicleIdentificationRequestMessageWithEID
                       DoIP_nMsgTypeVIDREQVIN = 0x0003,     //VehicleIdentificationRequestMessageWithVIN
                       DoIP_nMsgTypeVIDRES = 0x0004,        //VehicleIdentificationResponseMessage/VehicleAnnouncementMessage
                       DoIP_nMsgTypeROUTREQ = 0x0005,       //RoutingActivationRequest
                       DoIP_nMsgTypeROUTRES = 0x0006,       //RoutingActivationResponse
                       DoIP_nMsgTypeACHKREQ = 0x0007,       //AliveCheckRequest
                       DoIP_nMsgTypeACHKRES = 0x0008,       //AliveCheckResponse
                       DoIP_nMsgTypeESTATREQ = 0x4001,      //DoIPEntityStatusRequest
                       DoIP_nMsgTypeESTATRES = 0x4002,      //DoIPEntityStatusResponse
                       DoIP_nMsgTypePMODREQ = 0x4003,       //DiagnosticPowerModeInformationRequest
                       DoIP_nMsgTypePMODRES = 0x4004,       //DiagnosticPowerModeInformationResponse
                       DoIP_nMsgTypeDMESS = 0x8001,         //DiagnosticMessage
                       DoIP_nMsgTypeDACK = 0x8002,          //DiagnosticMessagePositiveAcknowledgement
                       DoIP_nMsgTypeDNACK = 0x8003,         //DiagnosticMessageNegativeAcknowledgement
                       DoIP_nMsgTypeGHNACKUDP = 0xA000,     //GenericDoIPHeaderNegativeAcknowledge on UDP (internal use)
                       DoIP_nMsgTypeGHNACKTCP = 0xA0001 };  //GenericDoIPHeaderNegativeAcknowledge on TCP (internal use)

/********************** Variables used for <TCP Connection Handler> **********************/

/**This enumeration defines symbolic values representing actions for connecting TCP-Sockets 
***and DoIP-Routing on this connections.
**/
enum DoIP_tenTcpConnActions {DoIP_nTcpConnActionCONNECT,    //Open TCP-Connection (3-way-handshake SYN on 'Connect'-Button)
                             DoIP_nTcpConnActionCONNCONF,   //Open TCP-Connection confirmed by Target
                             DoIP_nTcpConnActionDISCONNECT, //Close TCP-Connection (4-way-handshake FIN on 'Disconnect'-Button)
                             DoIP_nTcpConnActionROUTECONF}; //RoutingActivation-Response received

/******************* Variables used for cyclic message sending on TCP ********************/

/*This Array consists of timer-variables with resolution [ms] used to control cyclic message sending 
for each possible TCP-connection*/
msTimer DoIP_mstiCyclicTxTimer[257];

/*This Arrays define DoIP-Messages to be sent by the Cyclic Message Handler as byte-arrays*/
/*DoIP-DiagnosticMessage with SDU 'UDS TesterPresent (suppress response bit set)' as payload.*/
byte DoIP_abCyclicMessage_UDS_3E08[14] = {0x02, 0xFD, 0x80, 0x01, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x80};
/*DoIP-DiagnosticMessage with SDU 'UDS TesterPresent (suppress response bit not set)' as payload.*/
byte DoIP_abCyclicMessage_UDS_3E00[14] = {0x02, 0xFD, 0x80, 0x01, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00};
/*DoIP-AliveCheckResponse*/
byte DoIP_abCyclicMessage_DoIP_ACHKRES[10] = {0x02, 0xFD, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF};

/****** Variables used for storing Panel-Values, which have to be compared when changed *******/

/*Stores the Udp Source Port used before user changed it in the panel*/
long DoIP_lPreviousUdpSrcPort; 
}

on start
{
  word wCount;          //Help-Variable for counting loops
  
  /*Initialize the visibility of some panel-controls (Radonly or read-write)*/
  DoIP_vInitializePanelControlVisibility();
  
  /*Initialize error-marker to 'No error*/
  DoIP_bInitErrorOccurred = 0;
  
  /*Lock Control-Panel-Inputs until everything is inizialized*/
  DoIP_enNodeControlState = DoIP_nNodeControlStateLOCK;
  DoIP_vSendMessageToPanel("Initializing Panel....",DoIP_nOutputTextTypeINFO);
  
  /*Convert IP-Address-Strings given in the INI-File to numerical addresses*/
  if (DoiP_bConvertIpAdressesToNumerical() != 1)
  {
    /*Error occurred - Set Error-Indicator*/
    DoIP_bInitErrorOccurred = 1;
  }
  else
  {
    /*All initial operations are performed here, which need valid Ip-Adresses*/
    
    /*Initialize UDP-Socket-Handle with invalid-value*/
    DoIP_dwUdpSockHdl = ~0;
    
    /*Initialize TCP-Socket-Handles with invalid-value*/
    for (wCount = 0; wCount <= 256; wCount++)
    {
      DoIP_adwTcpSockHdl[wCount] = ~0;
    }
    
    /*Initialize the marker for the currently used UDP-Source-Port with the initially intented Port-number*/
    DoIP_lPreviousUdpSrcPort = @DoIP1::DoIP_i32UDPSrcPort;
    /*Open the UDP-Port with this port number*/
    if (DoIP_bCreateUdpSocket(DoIP_lPreviousUdpSrcPort) != 1)
    {
      /*Set Error-Indicator*/
      DoIP_bInitErrorOccurred = 1;
    }
  }
  
  /*Set the initial-value for the Logical Target Address (TA) to the preferred-value given in the INI-File*/
  if ((DoIP_dwLogAdrPreferredTA > 0) && (DoIP_dwLogAdrPreferredTA <= 0xFFFF)) //Check, if value from INI-File is in the valid range
  {
    /*Set the preferred value from INI-File for all 256 TCP-connection-slots*/
    for(wCount = 0; wCount <= 256; wCount++)
    {
      @DoIP1::DoIP_ai32LogDstAdr[wCount] = DoIP_dwLogAdrPreferredTA;
    }
  }
  else
  {
    /*Inform on pnael-output, that the initial-value from INI-File is out of range 
      and the default-value from environment-variable @DoIP1::DoIP_ai32LogDstAdr will be used instead*/ 
    
    DoIP_vSendMessageToPanel("Panel intialization: Initial Value for Preferred TA not in range 0x0000..0xFFFF. Set to default (0x0001) instead.",DoIP_nOutputTextTypeWARNING);
  }
  
  /*Copy all attributes of a TCP-Connection from the connection-slot indicated by the parameter 
  to the (initially) focussed connection*/
  DoIP_vTcpConnSwapSlotToFocus(@DoIP1::DoIP_u32TcpConnNr);
  
  /*Finalize initialization by checking, if errors occurred during initialization steps*/
  if (DoIP_bInitErrorOccurred)
  {
    /*Initialization steps not successful - send according message to the panel-outpout*/
    DoIP_vSendMessageToPanel("Panel initialization failed! Panel can not be used (Inputs are locked)!",DoIP_nOutputTextTypeERROR);
  }
  else
  {
    /*Initialization steps successful - send according message to the panel-outpout*/
    DoIP_vSendMessageToPanel("Panel initialized!",DoIP_nOutputTextTypeINFO);
  
    /*Initialize the Link-status in the panel (Application-Channel is set in INI-File*/
    @DoIP1::DoIP_i32LinkStatus = ethGetLinkStatus(DoIP_wEthernetLinkMsgChannel); 
    
    /*Panel initialized, thus unlock Control-Panel-Inputs in case Link is up*/
    if (@DoIP1::DoIP_i32LinkStatus)
    {
      DoIP_enNodeControlState = DoIP_nNodeControlStateUNLOCK;
    }
  }
}

on preStop
{
  word wCount;  //Help-Variable for counting loops;
  
  /*Close the UDP-Socket*/
  if(DoIP_dwUdpSockHdl != ~0) //In case the UDP-socket was created successfully (has a valid handle)
  {
    /*Close the used UDP-Socket*/
    DoIP_bCloseUdpPort(DoIP_dwUdpSockHdl);
  }

  /*Disable the related LEDs for Connection and Routing of the focussed connection*/
  @DoIP1::DoIP_i32ConnStat[0] = 0;
  @DoIP1::DoIP_ai32RoutStat[0] = 0;
  
  /*Stop all cyclic-message-timers and Disconnect and Close created TCP-Sockets*/
  for(wCount = 1; wCount <= 256; wCount++)
  {  
    /*Stop sending cyclic-messages on this connection if the timer was started*/
    if (isTimerActive(DoIP_mstiCyclicTxTimer[wCount]))
    {
      cancelTimer(DoIP_mstiCyclicTxTimer[wCount]);
    }
    
    if(DoIP_adwTcpSockHdl[wCount] != ~0) //In case the TCP-socket was created successfully (has a valid handle)
    {  
      /*Disconnect and Close the used TCP-Socket*/
      (DoIP_bCloseTcp(DoIP_adwTcpSockHdl[wCount]));
      
      /*Reinitialize the socket-handle with invalid-value*/
      DoIP_adwTcpSockHdl[wCount] = ~0; 
      
      /*Disable the related slot-LEDs for Connection and Routing*/
      @DoIP1::DoIP_i32ConnStat[wCount] = 0;
      @DoIP1::DoIP_ai32RoutStat[wCount] = 0;
    }
  }
}

on timer DoIP_mstiCyclicTxTimer (dword index)
{
  if (0 < index) //Just call the message-handler for timers associated to connection-number 1..256
  {
    /*Call the message-handler for sending cyclic messages on TCP*/
    DoIP_vSendTcpCyclicMessageHandler(index);
  }
}

on sysvar_update DoIP1::DoIP_i32SendEntityStatus
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeESTATREQ);
    }
  }
}

on sysvar_update DoIP1::DoIP_i32SendID
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeVIDREQ);
    }
  }
}

on sysvar_update DoIP1::DoIP_i32SendIDVIN
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeVIDREQVIN);
    }
  }
}

on sysvar_update DoIP1::DoIP_i32SendIDEID
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeVIDREQEID);
    }
  }
}

on sysvar_update DoIP1::DoIP_i32SendPwrMode
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypePMODREQ);
    }
  }  
}

on sysvar_update DoIP1::DoIP_u32ProtocolVerInvAuto
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Control the related Input-Box-Behaviour:*/
    if (@DoIP1::DoIP_u32ProtocolVerInvAuto) //Check, if 'InverseVersion' should be set automatically
    {
      setControlVisibility(DoIP_acPanelName, "InverseVersionReadOnly", 1);  //Enable  'InverseVersion'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "InverseVersion", 0);          //Disable 'InverseVersion'-ReadWrite
    }
    else
    {
      setControlVisibility(DoIP_acPanelName, "InverseVersionReadOnly", 0);  //Disable  'InverseVersion'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "InverseVersion", 1);          //Enable   'InverseVersion'-ReadWrite
    }
  }
}

on sysvar_update DoIP1::DoIP_u32PayloadTypeAuto
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Control the related Input-Box-Behaviour:*/
    if (@DoIP1::DoIP_u32PayloadTypeAuto) //Check, if 'PayloadType' should be set automatically
    {
      setControlVisibility(DoIP_acPanelName, "PayloadTypeReadOnly", 1);  //Enable  'PayloadType'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadType", 0);          //Disable 'PayloadType'-ReadWrite
    }
    else
    {
      setControlVisibility(DoIP_acPanelName, "PayloadTypeReadOnly", 0);  //Disable  'PayloadType'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadType", 1);          //Enable   'PayloadType'-ReadWrite
    }
  }
}

on sysvar_update DoIP1::DoIP_u32PayloadLengthAuto
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Control the related Input-Box-Behaviour:*/
    if (@DoIP1::DoIP_u32PayloadLengthAuto) //Check, if 'PayloadLength' should be set automatically
    {
      setControlVisibility(DoIP_acPanelName, "PayloadLengthReadOnly", 1);  //Enable  'PayloadLength'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadLength", 0);          //Disable 'PayloadLength'-ReadWrite
      setControlVisibility(DoIP_acPanelName, "PayloadLengthHexReadOnly", 1);  //Enable  'PayloadLengthHex'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadLengthHex", 0);          //Disable 'PayloadLengthHex'-ReadWrite
    }
    else
    {
      setControlVisibility(DoIP_acPanelName, "PayloadLengthReadOnly", 0);  //Disable  'PayloadLength'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadLength", 1);          //Enable   'PayloadLength'-ReadWrite
      setControlVisibility(DoIP_acPanelName, "PayloadLengthHexReadOnly", 0);  //Disable  'PayloadLength'-ReadOnly
      setControlVisibility(DoIP_acPanelName, "PayloadLengthHex", 1);          //Enable   'PayloadLength'-ReadWrite
    }
  }
}

on sysvar_update DoIP1::DoIP_u32TcpConnNr
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  { 
    /*Call the Tcp-Connection Switcher*/
    DoIP_vTcpConnSwitcher(@this);
  }
}

on sysvar_update DoIP1::DoIP_i32SendRoutingAct
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeROUTREQ); 
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendAliveCheckResponse
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vSendMessageHandler(DoIP_nMsgTypeACHKRES);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendAliveCheck
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeACHKREQ);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendDiagMsg
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeDMESS);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendIDResponse
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeVIDRES);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendGenHeaderNackUdp
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeGHNACKUDP);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendGenHeaderNackTcp
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeGHNACKTCP);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendRoutingActResponse
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeROUTRES);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendEntityStatusResponse
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeESTATRES);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendPwrModeResponse
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypePMODRES);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendDiagAck
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeDACK);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32SendDiagNack
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
     DoIP_vSendMessageHandler(DoIP_nMsgTypeDNACK);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32ConnectSrv
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vTcpConnectionHandler(DoIP_nTcpConnActionCONNECT);
    }
  } 
}

on sysvar_update DoIP1::DoIP_i32DisconnectSrv
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /* Execute the operations only in case the button is pressed (not released)*/
    if (@this)
    {
      DoIP_vTcpConnectionHandler(DoIP_nTcpConnActionDISCONNECT);
    }
  } 
}

on sysvar_update DoIP1::DoIP_ai32CycDiagMsgEnable
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /*Check, if the values are different - done to avoid recursive lock of the system-variable, 
    because it is written on it later*/
    if (@DoIP1::DoIP_ai32CycDiagMsgEnable[0] != @DoIP1::DoIP_ai32CycDiagMsgEnable[@DoIP1::DoIP_u32TcpConnNr])
    {
      /*Copy the changed value from the panel to the connection-slot focussed*/
      @DoIP1::DoIP_ai32CycDiagMsgEnable[@DoIP1::DoIP_u32TcpConnNr] = @DoIP1::DoIP_ai32CycDiagMsgEnable[0];
      
      /*Control the cyclic-message-timer along the setting from the panel at the connection-slot focussed*/
      if(@DoIP1::DoIP_ai32CycDiagMsgEnable[0])
      {
        if (@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr] < 250)
        {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 250ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],250,250);
        }
        else
        {
          if (@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr] > 10000)
          {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 10000ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],10000,10000);
          }
          else
          {
          /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period time read from panel*/
          setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr]);
          }
        }
      }
      else
      {
        /*Stop sending cyclic-messages on this connection if the timer was started*/
        if (isTimerActive(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr]))
        {
          cancelTimer(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr]);
        }        
      }
    }
  } 
}

on sysvar_update DoIP1::DoIP_ai32CycDiagMsgSDU
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /*Check, if the values are different - done to avoid recursive lock of the system-variable, 
    because it is written on it later*/
    if (@DoIP1::DoIP_ai32CycDiagMsgSDU[0] != @DoIP1::DoIP_ai32CycDiagMsgSDU[@DoIP1::DoIP_u32TcpConnNr])
    {
      /*Copy the changed value from the panel to the connection-slot focussed*/
      @DoIP1::DoIP_ai32CycDiagMsgSDU[@DoIP1::DoIP_u32TcpConnNr] = @DoIP1::DoIP_ai32CycDiagMsgSDU[0];
    }
  } 
}

on sysvar_update DoIP1::DoIP_ai32CycDiagMsgTime
{
  /*This event will only be processed in case the operating-state of this CAPL-Node is 'Running'*/
  if (DoIP_enNodeControlState == DoIP_nNodeControlStateUNLOCK)
  {
    /*Check, if the values are different - done to avoid recursive lock of the system-variable, 
    because it is written on it later*/
    if (@DoIP1::DoIP_ai32CycDiagMsgTime[0] != @DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr])
    {
      /*Copy the changed value from the panel to the connection-slot focussed*/
      @DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr] = @DoIP1::DoIP_ai32CycDiagMsgTime[0];
      
      /*Restart the cyclic-message-timer with the new period-value in case one is started*/
      if (isTimerActive(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr]))
      {
        if (@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr] < 250)
        {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 250ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],250,250);
        }
        else
        {
          if (@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr] > 10000)
          {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 10000ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],10000,10000);
          }
          else
          {
          /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period time read from panel*/
          setTimerCyclic(DoIP_mstiCyclicTxTimer[@DoIP1::DoIP_u32TcpConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[@DoIP1::DoIP_u32TcpConnNr]);
          }
        }
      }
    }
  } 
}

on sysvar DoIP1::DoIP_i32UDPSrcPort
{
  dword dwTmpHdl;      //Help-Variable for temporarily storing a socket-handle
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
  
  /*Check, if the SrcPort-Number really changed*/
  if (DoIP_lPreviousUdpSrcPort != @this)
  {
    /*Initialize the temp-handle with Socket-Handle of the currently open UDP-Socket*/
    dwTmpHdl = DoIP_dwUdpSockHdl;
  
    /*Open a new UDP-Socket with the new Source-Port-Number (DoIP_dwUdpSockHdl will be overwritten)*/
    if (DoIP_bCreateUdpSocket(@this)) //Check, if opening the new Socket was sccessful
    {
      /*Close the UDP-Socket, which was used until now*/
      DoIP_bCloseUdpPort(dwTmpHdl);
      
      /*Set the marker for the currently used UDP-SourcePort to the new value*/
      DoIP_lPreviousUdpSrcPort = @this;
    }
    else
    {
      /*Opening the new UDP-Socket failed, thus restore DoIP_dwUdpSockHdl with the socket handle used before*/
      DoIP_dwUdpSockHdl = dwTmpHdl;
      
      /*Reset the value in the panel to the SourcePort-number, which is still active*/
      @DoIP1::DoIP_i32UDPSrcPort = DoIP_lPreviousUdpSrcPort;
      /*Note: This will trigger this event-function again, but nothing will happen because 
        of the initial check. Nice, isn't it :-)*/
      
      snprintf(acErrMsg, elcount(acErrMsg), "Failed to switch UDP-Source-Port. Kept the current one: %d.", DoIP_lPreviousUdpSrcPort);
      DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeWARNING);
    }
  }
}

on sysvar DoIP1::DoIP_ai32TcpSrcPort
{
  word wCount;          //Help-Variable for counting in loops
  byte bDoubletteFound; //Indicator for TcpSrcPort-number already in use
  byte wDoubletteSlot;  //Stores the Slot-Number, were a Doublette was found
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
  
  /*Initialize the indicator to 'not found Doublette'*/
  bDoubletteFound = 0;
  
  /*It is checked, if the new Tester-Source-Port-Number is already reserved by another connection.
  This is done to avoid trying to connect with the same Tester-Source-Port-Number, which is not possible*/ 
  if(@DoIP1::DoIP_ai32TcpSrcPort[0] != @DoIP1::DoIP_ai32TcpSrcPort[@DoIP1::DoIP_u32TcpConnNr]) //Check, if the Port-number really changed
  {
    /*Count through the TCP-slots*/
    for (wCount = 1; wCount <= 256; wCount++) 
    {
      /*Check only if the TCP-Slot to investigate is not the one currently in focus*/
      if(wCount != @DoIP1::DoIP_u32TcpConnNr) 
      {
        /*Check, if the new test-number is already in User_data by another slot*/
        if(@DoIP1::DoIP_ai32TcpSrcPort[0] == @DoIP1::DoIP_ai32TcpSrcPort[wCount])
        {
           /*Found Doublette set indicator*/
           bDoubletteFound = 1;
          
           /*Store the Slot-Number the doublette was found*/
           wDoubletteSlot = wCount;
        }
      }
    }
    /*Check, if a Doublette was found*/
    if (bDoubletteFound)
    {
      /*In case a doublette is found, set back tester SourcePort to the value used so far*/
      @DoIP1::DoIP_ai32TcpSrcPort[0] = @DoIP1::DoIP_ai32TcpSrcPort[@DoIP1::DoIP_u32TcpConnNr];
      
      /*Send an information the panel output accordingly*/
      snprintf(acErrMsg, elcount(acErrMsg), "This Source Port is already reserved for connection #%d. Choose another one, please!", wDoubletteSlot);
      DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeWARNING);
    }
    else
    {
      /*Takeover the new TcpSrcPort-number to the slot*/
      @DoIP1::DoIP_ai32TcpSrcPort[@DoIP1::DoIP_u32TcpConnNr] = @DoIP1::DoIP_ai32TcpSrcPort[0];
    }
  }
}

OnTcpConnect(dword dwSocket, long lResult)
{
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
  
  /*Check, if the callback belongs to the connection number currently in focus*/
  if (dwSocket == DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr])
  {
    /*Check, if connection-errors occurred*/ 
    if (lResult == 0)
    {
      /*No Connection-Error occurred - Send confirmation-message to the Panel-Output*/
      snprintf(acErrMsg, elcount(acErrMsg), "Connection to target established. Socket: %d", DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr]);
      DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeINFO);
      
      /*Call Connection-Handler to confirm establishment of connection*/
      DoIP_vTcpConnectionHandler(DoIP_nTcpConnActionCONNCONF);
    }
  else
    { 
      /*Connection-Error occurred - Send error-message to the Panel-Output*/
      snprintf(acErrMsg, elcount(acErrMsg), "Connection to target refused. Socket: %d, Result: %d.", DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr], lResult);
      DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeERROR);
    }
  }
}

OnTcpClose(dword dwSocket, long lResult)
{
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
  word wCount;         //Loop-Counter   
  
  /*Count through the connection-numbers*/
  for (wCount = 1; wCount <= 256; wCount++)
  {
    if(dwSocket == DoIP_adwTcpSockHdl[wCount]) //If a socket is found matching to this event
    {
      /*Check, if closing the connection was done regularly by target or irregularly by an error-event*/ 
      if (lResult == 0)
      {
        /*Connection closed regularly by peer-node (target) - send according info to the Panel-Output*/
        snprintf(acErrMsg, elcount(acErrMsg), "Connection closed by target. Socket: %d", dwSocket);
        DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeINFO);  
      }
      else
      { 
        /*Connection closed irregularly - send according info to the Panel-Output*/
        snprintf(acErrMsg, elcount(acErrMsg), "Connection closed by connection-error-event. Socket: %d, Result: %d.", dwSocket, lResult);
        DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeERROR);
      }

      /*Stop sending cyclic-messages on this connection if the timer was started*/
      if (isTimerActive(DoIP_mstiCyclicTxTimer[wCount]))
      {
        cancelTimer(DoIP_mstiCyclicTxTimer[wCount]);
      }
      
      /*Close/Destroy TCP-Socket - Note: Return-Value of this function is not of interest here*/
      DoIP_bCloseTcp(dwSocket); 
      
      /*Reinitialize the socket-handle with invalid-value*/
      DoIP_adwTcpSockHdl[wCount] = ~0; 
      
      /*Delete connection-status and routing-status of this connection*/
      @DoIP1::DoIP_i32ConnStat[wCount] = 0;
      @DoIP1::DoIP_ai32RoutStat[wCount] = 0;
      
      /*If the connection the close was received on is currently in focus*/
      if(wCount == @DoIP1::DoIP_u32TcpConnNr)
      {
        /*Delete connection-status and routing-status of the connection currently in focus*/
        @DoIP1::DoIP_i32ConnStat[0] = 0;
        @DoIP1::DoIP_ai32RoutStat[0] = 0;
        
        /*Bring the Input-Box-Behaviour "Tcp Source Port" into read/write-state:*/
        setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 0);  //Disable ReadOnly
        setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 1);          //Enable ReadWrite
        setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 0);  //Disable ReadOnly
        setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 1);          //Enable ReadWrite
      }
    }
  }
}

OnTcpReceive(dword dwSocket, long lResult, dword dwAddress, dword dwPort, byte abBuffer[], dword dwSize)
{
  /*TCP-Receive-Callback for IPv4*/
  
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
 
  /*Check if the result is 0, means receive-operation was successful*/ 
  if (lResult == 0)
  {
    /*Receive-Operation was successful*/
    /*Check, if the Sender-IP-Address is the one of the target - messages from other IP-Sdresses will be ignored*/
    if (dwAddress == DoIP_dwIPv4AdrNode)
    { 
      /*Call the handler for received TCP-Messages*/
      DoIP_vReceiveTcpMessageHandler(dwSocket, abBuffer, dwSize);
    } 
  }
    else
  {
    /*Receive-Operation has reported failure - Send a warning to the panel output*/
    snprintf(acErrMsg, elcount(acErrMsg), "A TCP-Receive-Failure occurred on socket %d. Result: %d", dwSocket, lResult);
    DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeWARNING);
  }
  
  /*Start to watch for incoming TCP-Messages on this TCP-connection again*/
  DoIP_bStartTcpReceive(dwSocket);
}

OnTcpReceive(dword dwSocket, long lResult, byte abIpv6Address[], dword dwPort, byte abBuffer[], dword dwSize)
{
  /*TCP-Receive-Callback for IPv6*/
  
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
 
  /*Check if the result is 0, means receive-operation was successful*/ 
  if (lResult == 0)
  {
    /*Receive-Operation was successful*/
    /*Check, if the Sender-IP-Address is the one of the target - messages from other IP-Sdresses will be ignored*/
    if (!(memcmp(abIpv6Address,DoIP_abIPv6AdrNode,elCount(DoIP_abIPv6AdrNode))))
    { 
      /*Call the handler for received TCP-Messages*/
      DoIP_vReceiveTcpMessageHandler(dwSocket, abBuffer, dwSize);
    } 
  }
    else
  {
    /*Receive-Operation has reported failure - Send a warning to the panel output*/
    snprintf(acErrMsg, elcount(acErrMsg), "A TCP-Receive-Failure occurred on socket %d. Result: %d", dwSocket, lResult);
    DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeWARNING);
  }
  
  /*Start to watch for incoming TCP-Messages on this TCP-connection again*/
  DoIP_bStartTcpReceive(dwSocket);
}

/// <DoIP Message Handler>
void DoIP_vSendMessageHandler(enum DoIP_tenMsgTypes enMsgType)
{
  /**This function must be called to trigger the sending of a DoIP-Message.
  ***Depending on the DoIP-Message-type, the DoIP-Message payload must be composed here.
  *** Parameter:
  *** enum DoIP_enMsgTypes enMsgType: Type of the DoIP-Message to be sent
  **/
  
  long lCopiedBytes;            //Needed to store the number of bytes copied from panel-inputs of type 'Data'
  byte abTempBuf[40];           //Help-Buffer for temporary storage of data read from panel.
  dword dwDynamicPayloadLength; //Help-Variable to store the dynamic payload length of DiagMessages
  byte bErrorCount;             //Help-Variable to count errors, which prevent a message to be sent within one switch-case
  struct tstWrapWord            //Help-Structure used when converting words into byte-arrays
    {
      dword wWord;
    } stWordWrapper;
  dword dwCount;                //Help-variable for counting anything
    
  /*Display a warning in the panel-output, in case TCP/UDP-Swap is enabled to inject sendings on wrong protocol-Layoer 4*/
  if(@DoIP1::DoIP_i32Layer4SwapEnable)
  {
    DoIP_vSendMessageToPanel("TCP/UDP-Swap is activated!",DoIP_nOutputTextTypeWARNING);
  }
    
  /*Depending on the DoIP-Message Type given in the function parameter the handler start operations*/ 
  switch(enMsgType)
  {
    case DoIP_nMsgTypeESTATREQ: //DoIP-Message-Type is an EntityStatusRequest
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an EntityStatusRequest is always 0*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeESTATREQ, 0);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 8 
          (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
           DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf,8);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 8 
        (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf,8);
      }
      break;
    }
    case DoIP_nMsgTypePMODREQ: //DoIP-Message-Type is a DiagnosticPowerModeInformationRequest
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of a DiagnosticPowerModeInformationRequest is always 0*/
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypePMODREQ, 0);
      
      /*Send the message on UDP. UDP-Payload-Length is always 8
      (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 8 
          (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf,8);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 8 
        (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf,8);
      }
      break;
    }
    case DoIP_nMsgTypeVIDREQ: //DoIP-Message-Type is a VehicleIdentificationRequest
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of a VehicleIdentificationRequest is always 0*/
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeVIDREQ, 0);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 8 
          (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf,8);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 8 
        (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf,8);
      }
      break;
    }
    case DoIP_nMsgTypeVIDREQVIN: //DoIP-Message-Type is a VehicleIdentificationRequestWithVIN
    {      
      /*Copy the VIN from the panel to a temporary buffer*/
      sysGetVariableData( sysvar::DoIP1::DoIP_dataVIN, abTempBuf, lCopiedBytes );
      
      /*Check, if the expected 17 Bytes for the VIN are copied from the panel correctly*/
      if (lCopiedBytes != 17)
      {
        /*Send a Warning-Message to the Panel-Output in case the read VIN does not contain 17 Elements, thus the message is not sent*/
        DoIP_vSendMessageToPanel("SendMessageHandler: VIN was not read correctly from Panel. Message NOT sent.",DoIP_nOutputTextTypeERROR);
      }
      else 
      {
        /*Compose the GenericHeader for this DoIP-MessageType. 
        DoIP-Message-Payload-Length of a VehicleIdentificationRequest with VIN is always 17*/
        DoIP_vGenericHeaderComposer(DoIP_nMsgTypeVIDREQVIN, 17);
        
        /*Store the 17 Bytes of the VIN behind the GenericHeaderData (offset 8) from the temporary buffer (offset 0)*/ 
        memcpy_off(DoIP_abMsgTxBuf, 8, abTempBuf, 0, 17);

        if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
        {
          if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
          {
            /*Send the message on TCP (irregular). Payload-Length is always 25 
            (8 Bytes GenericHeader + 17 Bytes DoIP-Message-Payload)*/ 
            DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 25);
          }
          else
          {
            /*Send a warning to the panel-output, because the message could not be sent*/
            DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
          }
        }
        else
        {
          /*Send the message on UDP (regularly). Payload-Length is always 25 
          (8 Bytes GenericHeader + 17 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 25);
        }
      }
      break;
    }
    case DoIP_nMsgTypeVIDREQEID: //DoIP-Message-Type is a VehicleIdentificationRequestWithEID
    {
      /*Copy the EID from the panel to a temporary buffer*/
      sysGetVariableData( sysvar::DoIP1::DoIP_dataEID, abTempBuf, lCopiedBytes );
      
      if (lCopiedBytes != 6)
      {
        /*Send a Warning-Message to the Panel-Output in case the read EID does not contain 6 Elements, thus the message is not sent*/
        DoIP_vSendMessageToPanel("SendMessageHandler: EID was not read correctly from Panel. Message NOT sent.",DoIP_nOutputTextTypeERROR);
      }
      else
      {
        /*Compose the GenericHeader for this DoIP-MessageType. 
        DoIP-Message-Payload-Length of a VehicleIdentificationRequest with EID is always 6*/
        DoIP_vGenericHeaderComposer(DoIP_nMsgTypeVIDREQEID, 6);
        
        /*Store the 6 Bytes of the EID behind the GenericHeaderData (offset 8) from the temporary buffer (offset 0)*/ 
        memcpy_off(DoIP_abMsgTxBuf, 8, abTempBuf, 0, 6);
        
        if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
        {
          if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
          {
            /*Send the message on TCP (irregular). Payload-Length is always 14 
            (8 Bytes GenericHeader + 6 Bytes DoIP-Message-Payload)*/ 
            DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 14);
          }
          else
          {
            /*Send a warning to the panel-output, because the message could not be sent*/
            DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
          }
        }
        else
        {
          /*Send the message on UDP (regularly). Payload-Length is always 14 
          (8 Bytes GenericHeader + 17 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 14);
        }
      }
      break;
    }  
    case DoIP_nMsgTypeGHNACKUDP: //DoIP-Message-Type is an GenericDoIPHeaderNegativeAcknowledge on UDP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an GenericDoIPHeaderNegativeAcknowledge is always 1*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeGHNACK, 1); //Note: Type is 0x0000, no matter if sen on Ucp or Tdp
      
      /*Store the 1 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadGHNACK, 0, elCount(DoIP_abDummyPayloadGHNACK));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);

      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 9 
          (8 Bytes GenericHeader + 1 Byte DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 9);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        } 
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 9 
        (8 Bytes GenericHeader + 1 Byte DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 9);
      }
      break;
    }
    case DoIP_nMsgTypeVIDRES: //DoIP-Message-Type is an VehicleIdentificationResponseMessage/VehicleAnnouncementMessage on UDP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an VehicleIdentificationResponseMessage/VehicleAnnouncementMessage is always 33*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeVIDRES, 33);
      
      /*Store the 33 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadVIDRES, 0, elCount(DoIP_abDummyPayloadVIDRES));      

      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
       DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 41 
          (8 Bytes GenericHeader + 33 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 41);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }          
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 41 
        (8 Bytes GenericHeader + 33 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 41);
      }
      break;  
    }
    case DoIP_nMsgTypeESTATRES: //DoIP-Message-Type is an DoIPEntityStatusResponse on UDP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an DoIPEntityStatusResponse is always 7*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeESTATRES, 7);
      
      /*Store the 7 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadESTATRES, 0, elCount(DoIP_abDummyPayloadESTATRES));      

      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 15 
          (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 15);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }        
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 15 
        (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 15);
      }
      break;  
    }
    case DoIP_nMsgTypePMODRES: //DoIP-Message-Type is an DiagnosticPowerModeInformationResponse on UDP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an DiagnosticPowerModeInformationResponse is always 1*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypePMODRES, 1);
      
      /*Store the 1 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadPMODRES, 0, elCount(DoIP_abDummyPayloadPMODRES));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);

      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (irregular). Payload-Length is always 9 
          (8 Bytes GenericHeader + 1 Byte DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 9);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      else
      {
        /*Send the message on UDP (regularly). Payload-Length is always 9 
        (8 Bytes GenericHeader + 1 Byte DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 9);
      }
      break;  
    }
    case DoIP_nMsgTypeROUTREQ: //DoIP-Message-Type is an RoutingActivationRequest on TCP
    {
      /*Compose the GenericHeader for this DoIP-MessageType.*/
      if(@DoIP1::DoIP_u32RoutActOptBytesEnable)
      {
        /*DoIP-Message-Payload-Length of an RoutingActivationRequest is always 11 with the OEM-optional 4 Bytes*/ 
        DoIP_vGenericHeaderComposer(DoIP_nMsgTypeROUTREQ, 11);
        
        /*Copy the Opt. Bytes from the panel to a temporary buffer*/
        sysGetVariableData( sysvar::DoIP1::DoIP_dataRoutActOptBytes, abTempBuf, lCopiedBytes );
      
        /*Check, if the expected 4 Bytes for the Opt. Bytes are copied from the panel correctly*/
        if (lCopiedBytes != 4)
        {
          /*Send a Warning-Message to the Panel-Output in case the read VIN does not contain 17 Elements, thus the message is not sent*/
          DoIP_vSendMessageToPanel("SendMessageHandler: Opt. Bytes were not read correctly from Panel. Message NOT sent.",DoIP_nOutputTextTypeERROR);
        }
        else
        {
          /*Store the Opt. Bytes from the temporary buffer (offset 15)*/
          memcpy_off(DoIP_abMsgTxBuf, 15, abTempBuf, 0, 4);
        }
      }
      else
      {
        /*DoIP-Message-Payload-Length of an RoutingActivationRequest is always 7 without the OEM-optional 4 Bytes*/ 
        DoIP_vGenericHeaderComposer(DoIP_nMsgTypeROUTREQ, 7);
      }
      
      /*Get LogicalSourceAddress (SA) of the focussed TCP-Connection from Panel*/
      stWordWrapper.wWord = @DoIP1::DoIP_ai32LogSrcAdr[0];
      /*Store the 2 Byte of LogicalSourceAddress (SA) behind the GenericHeaderData (offset 8)*/ 
      memcpy(abTempBuf, stWordWrapper);
      DoIP_abMsgTxBuf[8] = abTempBuf[1];
      DoIP_abMsgTxBuf[9] = abTempBuf[0];
      
      /*Get Activation-Type from panel and store it behind the LogicalSourceAddress (SA) (offset 10)*/
      DoIP_abMsgTxBuf[10] = @DoIP1::DoIP_i32ActType;
      
      /*Store the four reserved bytes (always 0) behind Activation-Type (SA) (offset 11)*/
      DoIP_abMsgTxBuf[11] = 0;
      DoIP_abMsgTxBuf[12] = 0;
      DoIP_abMsgTxBuf[13] = 0;
      DoIP_abMsgTxBuf[14] = 0;
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled , DoIP-Message should be send on wrong Layer 4 Protocol
      {
        if((@DoIP1::DoIP_u32RoutActOptBytesEnable) && (lCopiedBytes == 4)) //Optional Bytes enabled and successfully read from panel
        {
          /*Send the message on UDP (irregular). Payload-Length is 19 (with optional Bytes) 
          (8 Bytes GenericHeader + 11 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 19);
        }
        else
        {
          /*Send the message on UDP (irregular). Payload-Length is 15 (with optional Bytes) 
          (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 15);
        }
      } 
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          if((@DoIP1::DoIP_u32RoutActOptBytesEnable) && (lCopiedBytes == 4)) //Optional Bytes enabled and successfully read from panel
          {
            /*Send the message on TCP (regularly). Payload-Length is 19 (with optional Bytes) 
            (8 Bytes GenericHeader + 11 Bytes DoIP-Message-Payload)*/ 
            DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 19);
          }
          else
          {
            /*Send the message on TCP (regularly). Payload-Length is 15 (with optional Bytes) 
            (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
            DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 15);
          }
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }        
      }
      break;
    }
    case DoIP_nMsgTypeACHKRES: //DoIP-Message-Type is an AliveCheckResponse on TCP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an AliveCheckResponse is always 2*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeACHKRES, 2);
      
      /*Get LogicalSourceAddress (SA) of the focussed TCP-Connection from Panel*/
      stWordWrapper.wWord = @DoIP1::DoIP_ai32LogSrcAdr[0];
      /*Store the 2 Byte of LogicalSourceAddress (SA) behind the GenericHeaderData (offset 8)*/ 
      memcpy(abTempBuf, stWordWrapper);
      DoIP_abMsgTxBuf[8] = abTempBuf[1];
      DoIP_abMsgTxBuf[9] = abTempBuf[0];
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 10 
        (8 Bytes GenericHeader + 1 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 10);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (regularly). Payload-Length is always 9 
          (8 Bytes GenericHeader + 1 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 10);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      break;
    }
    case DoIP_nMsgTypeGHNACKTCP: //DoIP-Message-Type is an GenericDoIPHeaderNegativeAcknowledge on TCP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an GenericDoIPHeaderNegativeAcknowledge is always 1*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeGHNACK, 1); //Note: Type is 0x0000, no matter if sen on Tcp or Udp
      
      /*Store the 1 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadGHNACK, 0, elCount(DoIP_abDummyPayloadGHNACK));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 9 
        (8 Bytes GenericHeader + 1 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 9);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (regularly). Payload-Length is always 9 
          (8 Bytes GenericHeader + 1 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 9);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      break;
    }
    case DoIP_nMsgTypeROUTRES: //DoIP-Message-Type is an RoutingActivationResponse on TCP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an RoutingActivationResponse is always 9*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeROUTRES, 9);
      
      /*Store the 9 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadROUTRES, 0, elCount(DoIP_abDummyPayloadROUTRES));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 17 
        (8 Bytes GenericHeader + 9 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 17);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (regularly). Payload-Length is always 17 
          (8 Bytes GenericHeader + 9 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 17);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      break;
    }
    case DoIP_nMsgTypeDACK: //DoIP-Message-Type is an DiagnosticMessagePositiveAcknowledgement on TCP
    {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an DiagnosticMessagePositiveAcknowledgement is always 7*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeDACK, 7);
      
      /*Store the 7 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadDACK, 0, elCount(DoIP_abDummyPayloadDACK));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 15 
        (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 15);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (regularly). Payload-Length is always 15 
          (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 15);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }        
      }
      break;
    }  
    case DoIP_nMsgTypeDNACK: //DoIP-Message-Type is an DiagnosticMessageNegativeAcknowledgement on TCP
      {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an DiagnosticMessageNegativeAcknowledgement is always 7*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeDNACK, 7);
      
      /*Store the 7 Byte of Dummy-Payload behind the GenericHeaderData (offset 8)*/ 
      memcpy_off(DoIP_abMsgTxBuf, 8, DoIP_abDummyPayloadDNACK, 0, elCount(DoIP_abDummyPayloadDNACK));
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 15 
        (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 15);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {
          /*Send the message on TCP (regularly). Payload-Length is always 15 
          (8 Bytes GenericHeader + 7 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 15);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }
      }
      break;
    }
    case DoIP_nMsgTypeACHKREQ: //DoIP-Message-Type is an AliveCheckRequest on TCP
      {
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of an AliveCheckRequest is always 0*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeACHKREQ, 0);
      
      /*Display a warning in the panel-output, because this message-type is regularly not sent by a DoIP-Gateway*/
      DoIP_vSendMessageToPanel("You sent a DoIP-Message-Type, which regularly will NOT be sent by a DoIP-Gateway.",DoIP_nOutputTextTypeWARNING);
      
      if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
      {
        /*Send the message on UDP (irregular). Payload-Length is always 8 
        (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
        DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, 8);
      }
      else
      {
        if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
        {        
          /*Send the message on TCP (regularly). Payload-Length is always 15 
          (8 Bytes GenericHeader + 0 Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, 8);
        }
        else
        {
          /*Send a warning to the panel-output, because the message could not be sent*/
          DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
        }         
      }
      break;
    }
    case DoIP_nMsgTypeDMESS: //DoIP-Message-Type is a DiagnosticMessage on TCP
      {
      /*Initialize Error-Counter to 0*/  
      bErrorCount = 0;
        
      /*Initialize dynamic payload-length to 4 (for SA and TA without UserData)*/
      dwDynamicPayloadLength = 4;
      
      /*Get LogicalSourceAddress (SA) of the focussed TCP-Connection from Panel*/
      stWordWrapper.wWord = @DoIP1::DoIP_ai32LogSrcAdr[0];
      /*Store the 2 Byte of LogicalSourceAddress (SA) behind the GenericHeaderData (offset 8)*/ 
      memcpy(abTempBuf, stWordWrapper);
      DoIP_abMsgTxBuf[8] = abTempBuf[1];
      DoIP_abMsgTxBuf[9] = abTempBuf[0];    
        
      /*Get LogicalTargetAddress (TA) of the focussed TCP-Connection from Panel*/
      stWordWrapper.wWord = @DoIP1::DoIP_ai32LogDstAdr[0];
      /*Store the 2 Byte of LogicalTargetAddress (TA) behind LogicalSourceAddress (SA) (offset 10)*/ 
      memcpy(abTempBuf, stWordWrapper);
      DoIP_abMsgTxBuf[10] = abTempBuf[1];
      DoIP_abMsgTxBuf[11] = abTempBuf[0]; 
      
      if (@DoIP1::DoIP_i32DiagMsgLengthSwitch)  //Check, if DiagMessage should be sent with fix length
      {
        /*Compose the UserData from the Panel-Input for SDUs with fix length and all bytes set to pattern-byte*/
        
        /*Store the UserData with the length given in the panel*/
        for (dwCount = 0; dwCount < @DoIP1::DoIP_i32DiagMsgLengthVal; dwCount++)
        {
          /*Store the Pattern-Byte at every position of the UserData (beginning at offset 12)*/
          DoIP_abMsgTxBuf[(12 + dwCount)] = @DoIP1::DoIP_i32DiagMsgLengthPat;
        }
        
        /*Add the number of copied bytes to the payload*/
        dwDynamicPayloadLength = dwDynamicPayloadLength + @DoIP1::DoIP_i32DiagMsgLengthVal;               
      }
      else
      {
        /*Compose the UserData from the Panel-Input for SDUs limited to 32 Byte*/
        
        /*Copy the UserData from the panel to a temporary buffer*/
        if (sysGetVariableData( sysvar::DoIP1::DoIP_dataDiagCmd, abTempBuf, lCopiedBytes ) == 0)  //Check for cuccessful operation
        {
          /*Check, if the maximum amount of accepted-payload bytes (32 Bytes) is exceeded*/
          if (lCopiedBytes > 32)
          {
            /*Maximum number of payload-bytes exceeded. Send an Error-Message to the Output and set error-counter*/
            DoIP_vSendMessageToPanel("SendMessageHandler: Could not sent message, because you input more than 32 Bytes.",DoIP_nOutputTextTypeERROR);
            bErrorCount = 1;
          }
        }
        else
        {
          /*An error occurred during reading from panel-input*/
          bErrorCount = 1;
        }      
      
        /*Add the number of copied bytes to the payload*/
        dwDynamicPayloadLength = dwDynamicPayloadLength + lCopiedBytes;
        
        /*Store the UserData from the temporary buffer (offset 12)*/
        memcpy_off(DoIP_abMsgTxBuf, 12, abTempBuf, 0, lCopiedBytes);
      }
      
      /*Compose the GenericHeader for this DoIP-MessageType. 
      DoIP-Message-Payload-Length of a DiagnosticMessage is always dynamic*/ 
      DoIP_vGenericHeaderComposer(DoIP_nMsgTypeDMESS, dwDynamicPayloadLength);
      
      /*Add the 8 Bytes of the GenericHeader to the dynamic PayloadLength*/
      dwDynamicPayloadLength = dwDynamicPayloadLength + 8;
      
      if (bErrorCount == 0) //Send message only, if no error occurred
      {
        if(@DoIP1::DoIP_i32Layer4SwapEnable) //If enabled, DoIP-Message should be send on wrong Layer 4 Protocol
        {
          /*Send the message on UDP (irregular). Payload-Length is always dynamic
          (8 Bytes GenericHeader + n Bytes DoIP-Message-Payload)*/ 
          DoIP_bSendUdpMsg(DoIP_abMsgTxBuf, dwDynamicPayloadLength);
        }
        else
        {
          if (@DoIP1::DoIP_i32ConnStat[0]) //Send the message only on TCP in case the TCP-Connection is established
          {
            /*Send the message on TCP (regularly). Payload-Length is always dynamic 
            (8 Bytes GenericHeader + n Bytes DoIP-Message-Payload)*/ 
            DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr],DoIP_abMsgTxBuf, dwDynamicPayloadLength);
          }
          else
          {
            /*Send a warning to the panel-output, because the message could not be sent*/
            DoIP_vSendMessageToPanel("TCP-connection not established! Not able to send this message.",DoIP_nOutputTextTypeWARNING);
          }             
        }
      }
      break;
    }
    default:
    {
      /*In case the DoIP-Message-Type is unknown, send an Error-Message to the Panel-Output*/
      DoIP_vSendMessageToPanel("SendMessageHandler called with unknown Message-Type!.",DoIP_nOutputTextTypeERROR);
    }
  }
}

/// <DoIP Message Handler>
void DoIP_vReceiveTcpMessageHandler(dword dwSocket, byte abBuffer[], dword dwSize)
{
  /**This function handles messages received on the established TCP-Sockets
  ***  Parameter:
  ***  dword socket: TCP-Socket, on which the message was received
  ***  byte buffer[]: Buffer containing the received message (TCP-Payload)
  ***  dword size: Size of the received message 
  **/
  
  char acErrMsg[100];  //For storing the ErrorMessage temporarily
  word wCount;         //Loop-Counter
  byte bInverseversion; //Helps to store the compare-value for inverseversion
  word wMsgtype;        //Helps to store the compare-value for messagetype
  word wTcpConnNr;      //Stores the connection-number calculated from the socket-number
  /*Stores the message of the automticAliveCheckResponse*/
  byte abAliveCheckResponse[10] = {0x02, 0xFD, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF};
  
  /*Initialize the connection number with an invalid value*/
  wTcpConnNr = 0xFFFF; 
      
  /*Retrieve the Tcp-Connection-number belonging to the socket-handle given as parameter*/
  for (wCount = 1; wCount <= 256; wCount++) //Count to all valid connection-numbers
  {
    if (dwSocket == DoIP_adwTcpSockHdl[wCount])  //If found a socket-number, which matches...
    {
      wTcpConnNr = wCount;  //...store the socket-number.      
    }
  }
    
  /*If the message was received on a socket related to this CAPL-Node*/
  if(wTcpConnNr != 0xFFFF)
  {
    /*Check in case the message has a size, means there is really received a message and connection is not closed*/
    if (dwSize > 0)
    {
      
      /*******Catch a RoutingActivationResponse*******/
      if (dwSize == 17) //Check, if message has a size of a RoutingActivationResponse (8 Byte Generic-Header + 9 Byte Payload)
      {
        /*Calculate version from received inverseversion by the means of a DoIP-synchronization-pattern*/
        bInverseversion = ~abBuffer[0];
      
        /*Calculate the received message-type*/
        wMsgtype = ((abBuffer[2] * 256) + abBuffer[3]);
      
        /*Check DoIP-Version and SynchronizationPattern and MessageType*/
        if ( (abBuffer[0] <= 0x02) && (abBuffer[1] == bInverseversion) && (wMsgtype == DoIP_nMsgTypeROUTRES) )
        {
          /*Check, if the RoutingActivationResponse was a positive one*/
          if((abBuffer[12] == 0x10) || (abBuffer[12] == 0x11))
          {
            /*Call the connection-handler for operating on Routing-Confirmation*/
            DoIP_vTcpConnectionHandler(DoIP_nTcpConnActionROUTECONF);
          
            /*Inform in the panel output, that a RoutingActivationResponse was received*/
            snprintf(acErrMsg, elcount(acErrMsg), "Received positive RoutingActivationResponse on connection %d. ACK: 0x%02X", wTcpConnNr, abBuffer[12]);
            DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeINFO);
          }
          else
          {
            /*Inform in the panel output, that a RoutingActivationResponse was received*/
            snprintf(acErrMsg, elcount(acErrMsg), "Received negative RoutingActivationResponse on connection %d. NACK: 0x%02X", wTcpConnNr, abBuffer[12]);
            DoIP_vSendMessageToPanel(acErrMsg,DoIP_nOutputTextTypeINFO);
          }
        }
      }
     
      /*******Catch an AliveCheckRequest*******/
      if (dwSize == 8) //Check, if message has a size of a AliveCheckRequest (8 Byte Generic-Header + 0 Byte Payload)
      {
        /*Calculate version from received inverseversion by the means of a DoIP-synchronization-pattern*/
        bInverseversion = ~abBuffer[0];
        
        /*Calculate the receivbed message-type*/
        wMsgtype = ((abBuffer[2] * 256) + abBuffer[3]);
        
        /*Check DoIP-Version and SynchronizationPattern and MessageType*/
        if ( (abBuffer[0] <= 0x02) && (abBuffer[1] == bInverseversion) && (wMsgtype == DoIP_nMsgTypeACHKREQ) )
        {         
          /*The received message is indicated an AliveCheckRequest, so check if an AliveCheckResponse should be sent
          (Auto-AliveCheckResponse must be activated and connection must be routed)*/
          if ( (@DoIP1::DoIP_ai32AutoAliveResp[wTcpConnNr])  && (@DoIP1::DoIP_ai32RoutStat[wTcpConnNr] == 1) )
          {
            /*Claculate the Tester-Source-Adress and put it to the message-payload*/
            abAliveCheckResponse[8] = (byte)(@DoIP1::DoIP_ai32LogSrcAdr[wTcpConnNr] / 256);
            abAliveCheckResponse[9] = (byte) (@DoIP1::DoIP_ai32LogSrcAdr[wTcpConnNr] & 0x00FF);
            
            /*Send the AliveCheckResponse-message*/
            DoIP_bSendTcpMsg(dwSocket, abAliveCheckResponse, elCount(abAliveCheckResponse));
          }
        }
      }
    }
  }
}

/// <DoIP Message Handler>
void DoIP_vSendTcpCyclicMessageHandler(dword dwConnNr)
{
  /*Check, if the connection indicated by the function-parameter is connected/routed and 
    if cyclic-message-sending for this connection is enabled*/
  if ((@DoIP1::DoIP_ai32RoutStat[dwConnNr]) && (@DoIP1::DoIP_ai32CycDiagMsgEnable[dwConnNr]))
  {
    /*Choose the cyclic message to sent from the connection-settings done in the panel*/
    switch(@DoIP1::DoIP_ai32CycDiagMsgSDU[dwConnNr])
    {
      case 0:
      { 
        /*Set Logical Source Address (SA) of the connection to the DoIP-message-payload*/
        DoIP_abCyclicMessage_UDS_3E08[8] = ((@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] / 256) & 0xFF);
        DoIP_abCyclicMessage_UDS_3E08[9] = (@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] & 0xFF);
        
        /*Set Logical Target Address (TA) of the connection to the DoIP-message-payload*/
        DoIP_abCyclicMessage_UDS_3E08[10] = ((@DoIP1::DoIP_ai32LogDstAdr[dwConnNr] / 256) & 0xFF);
        DoIP_abCyclicMessage_UDS_3E08[11] = (@DoIP1::DoIP_ai32LogDstAdr[dwConnNr] & 0xFF);
        /*Handling for DiagnosticMessage with SDU 'UDS TesterPresent (suppress response bit set)' as payload.*/
        
        /*Send predefined message (corresponding to the definition at system-variable DoIP_ai32CycDiagMsgSDU*/ 
        DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[dwConnNr],DoIP_abCyclicMessage_UDS_3E08,elCount(DoIP_abCyclicMessage_UDS_3E08));
        break;
      }
      case 1:
      {
        /*Set Logical Source Address (SA) of the connection to the DoIP-message-payload*/
        DoIP_abCyclicMessage_UDS_3E00[8] = ((@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] / 256) & 0xFF);
        DoIP_abCyclicMessage_UDS_3E00[9] = (@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] & 0xFF);
        
        /*Set Logical Target Address (TA) of the connection to the DoIP-message-payload*/
        DoIP_abCyclicMessage_UDS_3E00[10] = ((@DoIP1::DoIP_ai32LogDstAdr[dwConnNr] / 256) & 0xFF);
        DoIP_abCyclicMessage_UDS_3E00[11] = (@DoIP1::DoIP_ai32LogDstAdr[dwConnNr] & 0xFF);
        /*Handling for DiagnosticMessage with SDU 'UDS TesterPresent (suppress response bit not set)' as payload.*/
        
        /*Send predefined message (corresponding to the definition at system-variable DoIP_ai32CycDiagMsgSDU*/ 
        DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[dwConnNr],DoIP_abCyclicMessage_UDS_3E00,elCount(DoIP_abCyclicMessage_UDS_3E00));
        break;
      }
      case 2:
      {
        /*Set Logical Source Address (SA) of the connection to the DoIP-message-payload*/
        DoIP_abCyclicMessage_DoIP_ACHKRES[8] = ((@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] / 256) & 0xFF);
        DoIP_abCyclicMessage_DoIP_ACHKRES[9] = (@DoIP1::DoIP_ai32LogSrcAdr[dwConnNr] & 0xFF);
        
        /*Handling for cyclic DoIP-AliveCheckResponse.*/
        /*Send predefined message (corresponding to the definition at system-variable DoIP_ai32CycDiagMsgSDU*/ 
        DoIP_bSendTcpMsg(DoIP_adwTcpSockHdl[dwConnNr],DoIP_abCyclicMessage_DoIP_ACHKRES,elCount(DoIP_abCyclicMessage_DoIP_ACHKRES));
        break;
      }
      default:
      {
         /*Do nothing for undefined signals*/
      }
    }
  }
}

/// <DoIP Message Handler>
void DoIP_vGenericHeaderComposer(enum DoIP_tenMsgTypes enPayloadType, dword dwPayloadLength)
{
  /**This function composes the 8 Bytes representing the Generic-Header of a DoIP-Message. 
  ***The function will be called in case this CAPL-Node likes to send a DoIP Message.
  ***The result is stored in the first 8 Bytes of the Tx-MessageBuffer (DoIP_abMsgTxBuf).
  *** Parameter:
  *** word PayloadType: DoIP-Payload-Type of the DoIP-Message intented to send
  *** dword PayloadLength: Length of the Payload of the DoIP-Message
  **/
  
  /*Composing Byte 0 'Version':*/
  stDoIPGenHeader.bProtocolVer = @DoIP1::DoIP_u32ProtocolVer;  /*Copy 'Version' from panel*/
  
  /*Composing Byte 1 'Inverse-Version':*/
  if (@DoIP1::DoIP_u32ProtocolVerInvAuto)
  {
    /*Calculate 'Inverse-Version' from 'Version' by the means of the ISO13400-2 protocol verification pattern*/
    stDoIPGenHeader.bInvProtocolVer = ~stDoIPGenHeader.bProtocolVer;
    
    /* Write the calculated value to the panel */
    @DoIP1::DoIP_u32ProtocolVerInv = stDoIPGenHeader.bInvProtocolVer;
  }
  else
  {
    /*Manually overwrite 'Inverse-Version' with the value the User entered at the panel*/
    stDoIPGenHeader.bInvProtocolVer = @DoIP1::DoIP_u32ProtocolVerInv;
  }
  
  /*Composing Byte 2..3 'Payload-Type':*/
  if (@DoIP1::DoIP_u32PayloadTypeAuto)
  {
    /*Copy 'Payload-Type from function-parameter*/
    stDoIPGenHeader.wPayloadType = enPayloadType;
    
    /* Write the calculated value to the panel */
    @DoIP1::DoIP_u32PayloadType = stDoIPGenHeader.wPayloadType;
  }
  else
  {
    /*Manually overwrite 'Payload-Type' with the value the User entered at the panel*/
    stDoIPGenHeader.wPayloadType = @DoIP1::DoIP_u32PayloadType;
  }
  
  /*Composing Byte 4..7 'Payload-Length':*/
  if (@DoIP1::DoIP_u32PayloadLengthAuto)
  {
    /*Copy 'Payload-Type from function-parameter*/
    stDoIPGenHeader.dwpayloadLen = dwPayloadLength;
    
    /* Write the calculated value to the panel */
    @DoIP1::DoIP_u32PayloadLength = stDoIPGenHeader.dwpayloadLen;
  }
  else
  {
    /*Manually overwrite 'Payload-Type' with the value the User entered at the panel*/
    stDoIPGenHeader.dwPayloadLen = @DoIP1::DoIP_u32PayloadLength;
  }
  
  /*Store the Generic-Header-Data as an Array of 8 Byte into the first 8 Byte of the Tx-MessageBuffer*/
  memcpy_h2n(DoIP_abMsgTxBuf,stDoIPGenHeader);
  
  /*Send a warning to the Panel-Output in case any header-data (beside 'Version') might be manually overwritten*/
  if ((@DoIP1::DoIP_u32ProtocolVerInvAuto == 0) || (@DoIP1::DoIP_u32PayloadTypeAuto == 0) || (@DoIP1::DoIP_u32PayloadLengthAuto == 0))
  { 
    DoIP_vSendMessageToPanel("The sent message might contain implausible header-data!",DoIP_nOutputTextTypeWARNING);
  }
}

/// <DoIP Prints To Panel>
void DoIP_vSendMessageToPanel(char acMsg[], enum DoIP_tenOutputTextType enTexttype)
{
  /**This function is used to print a message to the output-window of the panel.
  ***Depending on the type of the message, the message is augmented with coloured prefixes.
  ***Note: The message must have \r\n at the end, if the next message should be displayed in a new line.
  *** Parameter:
  *** char msg[]: The message to be displayed
  *** enum DoIP_enOutputTextType texttype: Indicates the message-Type (Info, Warning, Error).
  **/
  
  long alLocTime[9];     //Buffer for storing local time info
  char acLocTime[20];    //Buffer for storing local time string to be printed
  
  /*Get the local time of the PC the script is running on*/
  getLocalTime(alLocTime);
  /*Format the string for printing the time info "hh:mm:ss : "*/
  snprintf(acLocTime, elcount(acLocTime), "%02d:%02d:%02d   ", alLocTime[2],alLocTime[1],alLocTime[0]);
  /*Set textcolor to gray60 for printing the time/date-info*/
  setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(153,153,153));
  /*Print date/time-Info*/
  putValueToControl( DoIP_acPanelName,"DoIPOutput",acLocTime);
  
  /*Chose the prefix of the message to display by the text-type given as function-parameter*/
  switch (enTexttype)
  {
    case DoIP_nOutputTextTypeWARNING:   //Text should be displayed as a Warning
    {
      setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(255,127,0)); //Textcolor DarkOrange1 for "WARNING "
      putValueToControl( DoIP_acPanelName,"DoIPOutput","WARNING: ");  //Print text
      setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(0,0,0)); //Textcolor black for the rest of the line
      break;
    }
    case DoIP_nOutputTextTypeERROR:    //Text should be displayed as an Error
    {
      setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(255,0,0)); //Textcolor red for Errors
      putValueToControl( DoIP_acPanelName,"DoIPOutput","ERROR: ");  //Print text
      setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(0,0,0)); //Textcolor black for the rest of the line
      break;
    }
    default:  //Text should be displayed as an Info (no prefix)
    {
      setControlForeColor(DoIP_acPanelName,"DoIPOutput",MakeRGB(0,0,0)); //Textcolor black for Infos and other unknown texttypes
    }
  }  
  putValueToControl( DoIP_acPanelName,"DoIPOutput",acMsg);  //print the message
  putValueToControl( DoIP_acPanelName,"DoIPOutput","\r\n");  //print a CRLF as line-terminator
}

/// <DoIP Prints To Panel>
void DoIP_vDisplaySentMessageOnPanel(byte abPayload[], long lPayloadlength)
{
  /**This function is used to print a message containing the sent DoIP-Message to the output-window of the panel.
  ***Note: The message must have \r\n at the end, if the next message should be displayed in a new line.
  *** Parameter:
  *** byte payload[]: The sent DoIP-message to be displayed
  *** long payloadlength: The length of the sent DoIP-message to be displayed
  **/ 
  
  char acMsg[300];              //Buffer for keeping the total output-string
  char acMsgtemp[200];          //Temporary buffer for keeping the parts ot the output-string
  long lCount;                  //Loop-counter
  byte bExceed;                 //Indicates, if the payload exceeds the maximum number of payload-bytes to display
  byte bMaxbytestodisplay;      //Maximum number of payload-bytes, which can be displayed
  
  /*Initially set the maximum number of bytes to display to 40*/
  bMaxbytestodisplay = 40;
  
  /*Check, if the number of payload -bytes exceeds the maximum number of bytes, which can be displayed*/
  if (lPayloadlength < bMaxbytestodisplay)
  {  
    /*Payload does not exceed the maximum number od bytes to display*/
    bExceed = 0;
   
    /*The maximum number of bytes to display is set to the payload-length*/
    bMaxbytestodisplay = lPayloadlength;
  }
  else
  {
    /*Payload does not exceed the maximum number od bytes to display*/
    bExceed = 1;
    
    /*The maximum number of bytes to display remains to it's initial value*/
  }
  
  /*Compose the first part of the message-line*/
  strncpy(acMsg,"Sent Message: ",20);

  /*Add the payload byte by byte to the message-line*/
  for (lCount = 0;lCount < bMaxbytestodisplay; lCount++)
  {  
    snprintf(acMsgtemp, elcount(acMsgtemp), "%02X ",abPayload[lCount]);
    strncat(acMsg, acMsgtemp, elcount(acMsgtemp));
  }
  
  /*Add the final part of the message-line*/
  if (bExceed)
  {
    /*In case the number of payload-bytes exceeds the maximum number of bytes, which can be displayed,
    this part contains a note indicating the number of payload-bytes followed by CRLF*/
    snprintf(acMsgtemp, elcount(acMsgtemp), "...(Message contains %d Byte)",lPayloadlength);
    strncat(acMsg, acMsgtemp, elcount(acMsgtemp));
  }
  
/*Send the message to the output on panel*/
DoIP_vSendMessageToPanel(acMsg,DoIP_nOutputTextTypeINFO);
}

/// <DoIP Prints To Panel>
void DoIP_vInitializePanelControlVisibility(void)
{
  /***This function initializes the panel-control-behaviour (read/write or read-only) at 
  ***the start of the measurement of some panel-elements
  ***/

  if (@DoIP1::DoIP_u32ProtocolVerInvAuto) //Check, if 'InverseVersion' should be set automatically
  {
    setControlVisibility(DoIP_acPanelName, "InverseVersionReadOnly", 1);  //Enable  'InverseVersion'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "InverseVersion", 0);          //Disable 'InverseVersion'-ReadWrite
  }
  else
  {
    setControlVisibility(DoIP_acPanelName, "InverseVersionReadOnly", 0);  //Disable  'InverseVersion'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "InverseVersion", 1);          //Enable   'InverseVersion'-ReadWrite
  }
  
  if (@DoIP1::DoIP_u32PayloadTypeAuto) //Check, if 'PayloadType' should be set automatically
  {
    setControlVisibility(DoIP_acPanelName, "PayloadTypeReadOnly", 1);  //Enable  'PayloadType'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadType", 0);          //Disable 'PayloadType'-ReadWrite
  }
  else
  {
    setControlVisibility(DoIP_acPanelName, "PayloadTypeReadOnly", 0);  //Disable  'PayloadType'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadType", 1);          //Enable   'PayloadType'-ReadWrite
  }
  
  if (@DoIP1::DoIP_u32PayloadLengthAuto) //Check, if 'PayloadLength' should be set automatically
  {
    setControlVisibility(DoIP_acPanelName, "PayloadLengthReadOnly", 1);  //Enable  'PayloadLength'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadLength", 0);          //Disable 'PayloadLength'-ReadWrite
    setControlVisibility(DoIP_acPanelName, "PayloadLengthHexReadOnly", 1);  //Enable  'PayloadLengthHex'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadLengthHex", 0);          //Disable 'PayloadLengthHex'-ReadWrite
  }
  else
  {
    setControlVisibility(DoIP_acPanelName, "PayloadLengthReadOnly", 0);  //Disable  'PayloadLength'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadLength", 1);          //Enable   'PayloadLength'-ReadWrite
    setControlVisibility(DoIP_acPanelName, "PayloadLengthHexReadOnly", 0);  //Disable  'PayloadLength'-ReadOnly
    setControlVisibility(DoIP_acPanelName, "PayloadLengthHex", 1);          //Enable   'PayloadLength'-ReadWrite
  } 
  
  setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 0);  //Disable 'Tcp Source Port (dec)'-ReadOnly
  setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 1);          //Enable 'Tcp Source Port (dec)'-ReadWrite
  setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 0);  //Disable 'Tcp Source Port (hex)'-ReadOnly
  setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 1);          //Enable 'Tcp Source Port (hex)'-ReadWrite
}

/// <TCP Connection Handler>
void DoIP_vTcpConnectionHandler(enum DoIP_tenTcpConnActions enTcpConnAction)
{
  /**This handler-function must be called for managing the TCP-Connection/DoIP-Routing.  
  *** Parameter:
  *** enum DoIP_tenTcpConnActions TcpConnAction: Tcp-Connection-number, which should be managed.
  **/
  
  dword dwFocussedConnNr; //local copy of the Tcp-connection-number currently focussed
  
  /*Initialize local copy of the Tcp-connection-number currently focussed*/
  dwFocussedConnNr = @DoIP1::DoIP_u32TcpConnNr;
  
  /*Depending on the Connection-Action given in the function parameter the handler start operations*/
  switch (enTcpConnAction)
  {
    case DoIP_nTcpConnActionCONNECT:      //This case manages actions to be done in case a TCP-Connection must be established 
    {
      if (@DoIP1::DoIP_i32ConnStat[dwFocussedConnNr] == 0)  //React on event only, if TCP-Connection not already established
      {
        /*Create/Bind TCP-Socket on connection-number currently focussed*/
        if(DoIP_bCreateTcpSocket(@DoIP1::DoIP_ai32TcpSrcPort[0], @DoIP1::DoIP_u32TcpConnNr))        
        { 
          /*Try to Connect to target (Handler will be called again with DoIP_nTcpConnActionCONNCONF in case the connection is confirmed*/
          DoIP_bOpenTcpConnection(@DoIP1::DoIP_u32TcpConnNr);
        }
      }
      break;  
    }
    case DoIP_nTcpConnActionCONNCONF: //This case manages actions to be done in case a TCP-Connection is confirmed as established 
    {
      /*Control the Input-Box-Behaviour "Tcp Source Port":*/
      setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 1);  //Enable ReadOnly
      setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 0);          //Disable ReadWrite
      setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 1);  //Enable ReadOnly
      setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 0);          //Disable ReadWrite
      
      /*Set the connection-status of the connection in focus to 'connected'*/
      @DoIP1::DoIP_i32ConnStat[0] = 1;
      
      /*Store the settings of the connection in focus to the slot of the currently chosen connection-number*/
      DoIP_vTcpConnSwapFocusToSlot(dwFocussedConnNr);
      
      /*Start to watch for incoming TCP-Messages on this connection*/
      DoIP_bStartTcpReceive(DoIP_adwTcpSockHdl[dwFocussedConnNr]);
      
      break;  
    }
    case DoIP_nTcpConnActionDISCONNECT:   //This case manages actions to be done in case a TCP-Connection must be closed actively 
    {
      if (@DoIP1::DoIP_i32ConnStat[dwFocussedConnNr] != 0)  //React on event only, if TCP-Connection already established
      {
        /*Stop sending cyclic-messages on this connection if the timer was started*/
        if (isTimerActive(DoIP_mstiCyclicTxTimer[dwFocussedConnNr]))
        {
          cancelTimer(DoIP_mstiCyclicTxTimer[dwFocussedConnNr]);
        }
        
        /*Close/Destroy TCP-Socket on connection-number currently focussed*/
        if (DoIP_bCloseTcp(DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr]))
        {      
          /*Reinitialize the socket-handle with invalid-value*/
          DoIP_adwTcpSockHdl[@DoIP1::DoIP_u32TcpConnNr] = ~0;
      
          /*Control the Input-Box-Behaviour "Tcp Source Port":*/
          setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 0);  //Disable ReadOnly
          setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 1);          //Enable ReadWrite
          setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 0);  //Disable ReadOnly
          setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 1);          //Enable ReadWrite
          
          /*Set the connection-status of the connection in focus to 'not-connected'*/
          @DoIP1::DoIP_i32ConnStat[0] = 0;
          @DoIP1::DoIP_ai32RoutStat[0] = 0;
        
          /*Store the settings of the connection in focus to the slot of the currently chosen connection-number*/
          DoIP_vTcpConnSwapFocusToSlot(dwFocussedConnNr);
        }
      }
      break;
    }
    case DoIP_nTcpConnActionROUTECONF:       //This case manages actions to be done in case a DoIP-Routing is confirmed
    {
      /*If enabled for this connection, start sending Cyclic-Messages with the cycle-time read from 
      the panel for the currently focussed connection. For robustness against false inputs for the time, 
      the time-period is limited to 250..10000ms. Note: Smaller values than 250ms will lead to too 
      high load of the sending queue*/
      if (@DoIP1::DoIP_ai32CycDiagMsgEnable[dwFocussedConnNr])
      {
        if (@DoIP1::DoIP_ai32CycDiagMsgTime[dwFocussedConnNr] < 250)
        {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 250ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[dwFocussedConnNr],250,250);
        }
        else
        {
          if (@DoIP1::DoIP_ai32CycDiagMsgTime[dwFocussedConnNr] > 10000)
          {
            /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period limited to 10000ms*/
            setTimerCyclic(DoIP_mstiCyclicTxTimer[dwFocussedConnNr],10000,10000);
          }
          else
          {
          /*Start the Cyclic-Timer, which triggers the sending via on-timer-callback. Period time read from panel*/
          setTimerCyclic(DoIP_mstiCyclicTxTimer[dwFocussedConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[dwFocussedConnNr],@DoIP1::DoIP_ai32CycDiagMsgTime[dwFocussedConnNr]);
          }
        }
      }
      
      /*Set the routing-status of the connection in focus to 'routed'*/
      @DoIP1::DoIP_ai32RoutStat[0] = 1;
      
      /*Store the settings of the connection in focus to the slot of the currently chosen connection-number*/
      DoIP_vTcpConnSwapFocusToSlot(dwFocussedConnNr);
      break;
    }
  }
}

/// <TCP Connection Handler>
void DoIP_vTcpConnSwitcher(word wConnNr)
{
  /**This function controls all actions to be done, if the TCP-connection-Focus changes to a different 
  ***TCP-Connection.
  *** Parameter:
  *** word ConnNr: New TCP-connection-number, which should be taken into focus.
  **/
 
  char acMsg[400];               //Temporary buffer for keeping strings
  
  /*Copy all attributes of a TCP-Connection from the connection-slot indicated by the parameter to the focussed connection*/
  DoIP_vTcpConnSwapSlotToFocus(wConnNr);
  
  /* Control the Input-Box-Behaviour "Tcp Source Port" and cyclic-SDUs. Must be locked, if the connection is active:*/
  if (@DoIP1::DoIP_i32ConnStat[0])
  {
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 1);  //Enable ReadOnly
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 0);          //Disable ReadWrite
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 1);  //Enable ReadOnly
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 0);          //Disable ReadWrite
  }
	else
  {
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortDecReadOnly", 0);  //Disable ReadOnly
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortDec", 1);          //Enable ReadWrite
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortHexReadOnly", 0);  //Disable ReadOnly
    setControlVisibility(DoIP_acPanelName, "TcpSourcePortHex", 1);          //Enable ReadWrite
  }
  
  /*Inform about the changed connection-number on the output of the panel*/
  snprintf(acMsg, elcount(acMsg), "Focused TCP-Connection #%d.", wConnNr);
  DoIP_vSendMessageToPanel(acMsg, DoIP_nOutputTextTypeINFO);
}

on ethernetStatus *
{
  word wCount;    //Used for counting loops
  byte bCloseInd; //Marker used to indicate, if any TCP-Connection was closed due to LinkDown
  
  /*Check, if the event is received on the Application-Channel of this Node*/
  if (this.msgChannel == DoIP_wEthernetLinkMsgChannel)
  {
    /*Check the Ethernet-link-Status on the channel the node this script is running on is connected to*/
    switch(this.status)
    {
      case 0:  //Case Link-Down
      {
        /*Lock the Node - No inputs possible*/
        DoIP_enNodeControlState = DoIP_nNodeControlStateLOCK;
      
        @DoIP1::DoIP_i32LinkStatus = 0;  //Set the information Link_Down in the panel
      
        /*Disable the related LEDs for Connection and Routing of the focussed connection*/
        @DoIP1::DoIP_i32ConnStat[0] = 0;
        @DoIP1::DoIP_ai32RoutStat[0] = 0;
      
        /*Initialize Marker*/
        bCloseInd = 0;
  
        /*Stop all cyclic-message-timers and Disconnect and Close created TCP-Sockets*/
        for(wCount = 1; wCount <= 256; wCount++)
        {  
          /*Stop sending cyclic-messages on this connection if the timer was started*/
          if (isTimerActive(DoIP_mstiCyclicTxTimer[wCount]))
          {
            cancelTimer(DoIP_mstiCyclicTxTimer[wCount]);
          }

          /*Close all TCP-Connections/Sockets*/
          if(DoIP_adwTcpSockHdl[wCount] != ~0) //In case the TCP-socket was created successfully (has a valid handle)
          {  
            /*Disconnect and Close the used TCP-Socket*/
            (DoIP_bCloseTcp(DoIP_adwTcpSockHdl[wCount]));
        
            /*Reinitialize the socket-handle with invalid-value*/
            DoIP_adwTcpSockHdl[wCount] = ~0; 
      
            /*Disable the related slot-LEDs for Connection and Routing*/
            @DoIP1::DoIP_i32ConnStat[wCount] = 0;
            @DoIP1::DoIP_ai32RoutStat[wCount] = 0;  

            /*Set Marker to indicate, that minimum one TCP-Connection is closed*/
            bCloseInd = 1;
          }
        }
      
        if(bCloseInd)
        {
          /*Inform in the panel output, that this event closed all open connections and the panel is locked*/
          DoIP_vSendMessageToPanel("Ethernet-Link went down - all open connections are closed! Panel is locked!",DoIP_nOutputTextTypeINFO);
        }
        else
        {
          /*Inform in the panel output, that this event locked the panel*/
          DoIP_vSendMessageToPanel("Ethernet-Link went down! Panel is locked!",DoIP_nOutputTextTypeINFO);
        }
        break;
      }
      case 1: //Case Link-Up
      {
        /*Unlock the panel only, if no error occurred during Initialisation of the Node*/
        if (DoIP_bInitErrorOccurred == 0)
        {
          /*Set the information Link_Up in the panel*/
          @DoIP1::DoIP_i32LinkStatus = 1;  
      
          /*Unlock the Node - Inputs possible*/
          DoIP_enNodeControlState = DoIP_nNodeControlStateUNLOCK;
      
          /*Inform in the panel output, that this event closed all open connections and the panel is locked*/
          DoIP_vSendMessageToPanel("Ethernet-Link went up. Panel is unlocked!",DoIP_nOutputTextTypeINFO);
        }
        break;
      }
    }
  }
}

/// <TCP Connection Handler>
void DoIP_vTcpConnSwapSlotToFocus(word wConnNr)
{
  /**This function copies all attributes of a TCP-Connection from a connection-slot to the focussed connection.
  ***All attributes are organized in arrays, where element 0 is the focussed element and the elements 1..256 
  ***represent the connection-slots.
  *** Parameter:
  *** word ConnNr: Slot, from which the attributes shall be copied.
  **/
  @DoIP1::DoIP_i32ConnStat[0] = @DoIP1::DoIP_i32ConnStat[wConnNr];                    //Connection-Status
  @DoIP1::DoIP_ai32RoutStat[0] = @DoIP1::DoIP_ai32RoutStat[wConnNr];                  //Routing-Status
  @DoIP1::DoIP_ai32TcpSrcPort[0] = @DoIP1::DoIP_ai32TcpSrcPort[wConnNr];              //TCP Source-Port
  @DoIP1::DoIP_ai32LogSrcAdr[0] = @DoIP1::DoIP_ai32LogSrcAdr[wConnNr];                //Logical Source Address (SA)
  @DoIP1::DoIP_ai32LogDstAdr[0] = @DoIP1::DoIP_ai32LogDstAdr[wConnNr];                //Logical Target Address (TA)
  @DoIP1::DoIP_ai32CycDiagMsgEnable[0] = @DoIP1::DoIP_ai32CycDiagMsgEnable[wConnNr];  //Enable-State of cyclic Diag-SDU Sending
  @DoIP1::DoIP_ai32CycDiagMsgSDU[0] = @DoIP1::DoIP_ai32CycDiagMsgSDU[wConnNr];        //Type of cyclic Diag-SDU
  @DoIP1::DoIP_ai32CycDiagMsgTime[0] = @DoIP1::DoIP_ai32CycDiagMsgTime[wConnNr];      //Cycle-Time of cyclic Diag-SDU
}

/// <TCP Connection Handler>
void DoIP_vTcpConnSwapFocusToSlot(word wConnNr)
{
  /**This function copies all attributes of a TCP-Connection from the focussed connection to a connection-slot.
  ***All attributes are organized in arrays, where element 0 is the focussed element and the elements 1..256 
  ***represent the connection-slots.
  *** Parameter:
  *** word ConnNr: Slot, to which the attributes shall be copied.
  **/
  @DoIP1::DoIP_i32ConnStat[wConnNr] = @DoIP1::DoIP_i32ConnStat[0];                    //Connection-Status
  @DoIP1::DoIP_ai32RoutStat[wConnNr] = @DoIP1::DoIP_ai32RoutStat[0];                  //Routing-Status
  @DoIP1::DoIP_ai32TcpSrcPort[wConnNr] = @DoIP1::DoIP_ai32TcpSrcPort[0];              //TCP Source-Port
  @DoIP1::DoIP_ai32LogSrcAdr[wConnNr] = @DoIP1::DoIP_ai32LogSrcAdr[0];                //Logical Source Address (SA)
  @DoIP1::DoIP_ai32LogDstAdr[wConnNr] = @DoIP1::DoIP_ai32LogDstAdr[0];                //Logical Target Address (TA)
  @DoIP1::DoIP_ai32CycDiagMsgEnable[wConnNr] = @DoIP1::DoIP_ai32CycDiagMsgEnable[0];  //Enable-State of cyclic Diag-SDU Sending
  @DoIP1::DoIP_ai32CycDiagMsgSDU[wConnNr] = @DoIP1::DoIP_ai32CycDiagMsgSDU[0];        //Type of cyclic Diag-SDU
  @DoIP1::DoIP_ai32CycDiagMsgTime[wConnNr] = @DoIP1::DoIP_ai32CycDiagMsgTime[0];      //Cycle-Time of cyclic Diag-SDU
}
